import './index.css';
import { defineComponent, ref as ref$1, onMounted, onUnmounted, openBlock, createElementBlock } from 'vue';

// compatible with NodeList.prototype.forEach() before chrome 51
// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
if (typeof window === 'object' &&
    window.NodeList &&
    !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
// compatible with ParentNode.append() before chrome 54
// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md
if (typeof window !== 'undefined') {
    (function (arr) {
        arr.forEach((item) => {
            if (Object.prototype.hasOwnProperty.call(item, 'append')) {
                return;
            }
            Object.defineProperty(item, 'append', {
                configurable: true,
                enumerable: true,
                writable: true,
                value(...args) {
                    const docFrag = document.createDocumentFragment();
                    args.forEach((arg) => {
                        const isNode = arg instanceof Node;
                        docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
                    });
                    this.appendChild(docFrag);
                },
            });
        });
    })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
}

/* eslint-disable no-underscore-dangle */
class Disposable {
    get disposed() {
        return this._disposed === true;
    }
    dispose() {
        this._disposed = true;
    }
}
(function (Disposable) {
    function dispose() {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const proto = target.__proto__; // eslint-disable-line
            descriptor.value = function (...args) {
                if (this.disposed) {
                    return;
                }
                raw.call(this, ...args);
                proto.dispose.call(this);
            };
        };
    }
    Disposable.dispose = dispose;
})(Disposable || (Disposable = {}));
/**
 * An object which manages a collection of disposable items.
 */
class DisposableSet {
    constructor() {
        this.isDisposed = false; // eslint-disable-line:variable-name
        this.items = new Set();
    }
    /**
     * Test whether the set has been disposed.
     */
    get disposed() {
        return this.isDisposed;
    }
    /**
     * Dispose of the set and the items it contains.
     *
     * #### Notes
     * Items are disposed in the order they are added to the set.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.items.forEach((item) => {
            item.dispose();
        });
        this.items.clear();
    }
    /**
     * Test whether the set contains a specific item.
     *
     * @param item - The item of interest.
     *
     * @returns `true` if the set contains the item, `false` otherwise.
     */
    contains(item) {
        return this.items.has(item);
    }
    /**
     * Add a disposable item to the set.
     *
     * @param item - The item to add to the set.
     *
     * #### Notes
     * If the item is already contained in the set, this is a no-op.
     */
    add(item) {
        this.items.add(item);
    }
    /**
     * Remove a disposable item from the set.
     *
     * @param item - The item to remove from the set.
     *
     * #### Notes
     * If the item is not contained in the set, this is a no-op.
     */
    remove(item) {
        this.items.delete(item);
    }
    /**
     * Remove all items from the set.
     */
    clear() {
        this.items.clear();
    }
}
(function (DisposableSet) {
    /**
     * Create a disposable set from an iterable of items.
     *
     * @param items - The iterable or array-like object of interest.
     *
     * @returns A new disposable initialized with the given items.
     */
    function from(items) {
        const set = new DisposableSet();
        items.forEach((item) => {
            set.add(item);
        });
        return set;
    }
    DisposableSet.from = from;
})(DisposableSet || (DisposableSet = {}));

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

const freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

const root$1 = root;

/** Built-in value references. */
var Symbol$1 = root$1.Symbol;

const Symbol$2 = Symbol$1;

/** Used for built-in method references. */
var objectProto$j = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$g = objectProto$j.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$j.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$i = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$i.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$3 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

const isArray$1 = isArray;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

const coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$h = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$f).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root$1, 'WeakMap');

const WeakMap$2 = WeakMap$1;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

const baseCreate$1 = baseCreate;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$1() {
  // No operation performed.
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

const defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

const baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString$1);

const setToString$1 = setToString;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$g.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply$1(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$f;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$e.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$d.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

const isArguments$1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

const isBuffer$1 = isBuffer;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$6 = '[object Map]',
    numberTag$4 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$6 = '[object Set]',
    stringTag$3 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$6] = typedArrayTags[numberTag$4] =
typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal$1.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

const nodeUtil$1 = nodeUtil;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

const isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$c.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

const nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$b.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$a.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

const nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map');

const Map$2 = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$2 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

const stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments$1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

const getPrototype$1 = getPrototype;

/** `Object#toString` result references. */
var objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$8 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange$2 = '\\ud800-\\udfff',
    rsComboMarksRange$3 = '\\u0300-\\u036f',
    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$2 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$3 + rsVarRange$2 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$2 = '\\u0300-\\u036f',
    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

const upperFirst$1 = upperFirst;

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst$1(toString(string).toLowerCase());
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

const deburrLetter$1 = deburrLetter;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboRange$1 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

const camelCase$1 = camelCase;

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$2 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE$2 - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root$1.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

const getSymbols$1 = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};

const getSymbolsIn$1 = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root$1, 'DataView');

const DataView$1 = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root$1, 'Promise');

const Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root$1, 'Set');

const Set$2 = Set$1;

/** `Object#toString` result references. */
var mapTag$5 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$5 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$3 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3) ||
    (Map$2 && getTag(new Map$2) != mapTag$5) ||
    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
    (Set$2 && getTag(new Set$2) != setTag$5) ||
    (WeakMap$2 && getTag(new WeakMap$2) != weakMapTag$1)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$3;
        case mapCtorString: return mapTag$5;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$5;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

const getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$6.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root$1.Uint8Array;

const Uint8Array$2 = Uint8Array$1;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$4 = '[object Map]',
    numberTag$3 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);

    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$4:
      return new Ctor;

    case numberTag$3:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$2:
      return cloneRegExp(object);

    case setTag$4:
      return new Ctor;

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate$1(getPrototype$1(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$3;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

const isMap$1 = isMap;

/** `Object#toString` result references. */
var setTag$3 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$3;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

const isSet$1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$2 = 4;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$2 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag$2] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
cloneableTags[regexpTag$1] = cloneableTags[setTag$2] =
cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray$1(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray$1(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

const baseFor$1 = baseFor;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

const baseEach$1 = baseEach;

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$1(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root$1.Date.now();
};

const now$1 = now;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin$1 = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults$3 = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

const defaults$4 = defaults$3;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray$1(srcValue),
        isBuff = !isArr && isBuffer$1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

const mergeWith$1 = mergeWith;

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, customDefaultsMerge);
  return apply$1(mergeWith$1, undefined, args);
});

const defaultsDeep$1 = defaultsDeep;

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE$1) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

const difference$1 = difference;

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach$1(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty$2.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

const groupBy$1 = groupBy;

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty$1.call(object, key);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray$1(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

/**
 * Converts the first character of `string` to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.lowerFirst('Fred');
 * // => 'fred'
 *
 * _.lowerFirst('FRED');
 * // => 'fRED'
 */
var lowerFirst = createCaseFirst('toLowerCase');

const lowerFirst$1 = lowerFirst;

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

const merge$1 = merge;

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray$1(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

const sortBy$1 = sortBy;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$1 = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$1 - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeMin = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin(high, MAX_ARRAY_INDEX);
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array == null ? low : array.length;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = (low + high) >>> 1,
          computed = array[mid];

      if (computed !== null && !isSymbol(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy(array, value, identity, retHighest);
}

/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */
function sortedIndex(array, value) {
  return baseSortedIndex(array, value);
}

/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee));
}

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst$1(word);
});

const startCase$1 = startCase;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce$1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$2 && (1 / setToArray(new Set$2([,-0]))[1]) == INFINITY) ? noop$1 : function(values) {
  return new Set$2(values);
};

const createSet$1 = createSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet$1(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

const union$1 = union;

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

function apply(fn, ctx, args) {
    if (args) {
        switch (args.length) {
            case 0:
                return fn.call(ctx);
            case 1:
                return fn.call(ctx, args[0]);
            case 2:
                return fn.call(ctx, args[0], args[1]);
            case 3:
                return fn.call(ctx, args[0], args[1], args[2]);
            case 4:
                return fn.call(ctx, args[0], args[1], args[2], args[3]);
            case 5:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
            case 6:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
            default:
                return fn.apply(ctx, args);
        }
    }
    return fn.call(ctx);
}
function call$1(fn, ctx, ...args) {
    return apply(fn, ctx, args);
}

function isAsyncLike(obj) {
    return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
}
function isAsync(obj) {
    return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
    const results = [];
    inputs.forEach((arg) => {
        if (Array.isArray(arg)) {
            results.push(...arg);
        }
        else {
            results.push(arg);
        }
    });
    const hasAsync = results.some((res) => isAsync(res));
    if (hasAsync) {
        const deferres = results.map((res) => isAsync(res) ? res : Promise.resolve(res !== false));
        return Promise.all(deferres).then((arr) => arr.reduce((memo, item) => item !== false && memo, true));
    }
    return results.every((res) => res !== false);
}

function call(list, args) {
    const results = [];
    for (let i = 0; i < list.length; i += 2) {
        const handler = list[i];
        const context = list[i + 1];
        const params = Array.isArray(args) ? args : [args];
        const ret = apply(handler, context, params);
        results.push(ret);
    }
    return toAsyncBoolean(results);
}

class Events {
    constructor() {
        this.listeners = {};
    }
    on(name, handler, context) {
        if (handler == null) {
            return this;
        }
        if (!this.listeners[name]) {
            this.listeners[name] = [];
        }
        const cache = this.listeners[name];
        cache.push(handler, context);
        return this;
    }
    once(name, handler, context) {
        const cb = (...args) => {
            this.off(name, cb);
            return call([handler, context], args);
        };
        return this.on(name, cb, this);
    }
    off(name, handler, context) {
        // remove all events.
        if (!(name || handler || context)) {
            this.listeners = {};
            return this;
        }
        const listeners = this.listeners;
        const names = name ? [name] : Object.keys(listeners);
        names.forEach((n) => {
            const cache = listeners[n];
            if (!cache) {
                return;
            }
            // remove all events with specified name.
            if (!(handler || context)) {
                delete listeners[n];
                return;
            }
            for (let i = cache.length - 2; i >= 0; i -= 2) {
                if (!((handler && cache[i] !== handler) ||
                    (context && cache[i + 1] !== context))) {
                    cache.splice(i, 2);
                }
            }
        });
        return this;
    }
    trigger(name, ...args) {
        let returned = true;
        if (name !== '*') {
            const list = this.listeners[name];
            if (list != null) {
                returned = call([...list], args);
            }
        }
        const list = this.listeners['*'];
        if (list != null) {
            return toAsyncBoolean([
                returned,
                call([...list], [name, ...args]),
            ]);
        }
        return returned;
    }
    emit(name, ...args) {
        return this.trigger(name, ...args);
    }
}

/**
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 */
function applyMixins(derivedCtor, ...baseCtors) {
    baseCtors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            if (name !== 'constructor') {
                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
        });
    });
}

const extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array &&
        function (d, b) {
            d.__proto__ = b; // eslint-disable-line no-proto
        }) ||
    function (d, b) {
        // eslint-disable-next-line no-restricted-syntax
        for (const p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) {
                d[p] = b[p];
            }
        }
    };
/**
 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
 */
// eslint-disable-next-line
function inherit(cls, base) {
    extendStatics(cls, base);
    function tmp() {
        this.constructor = cls;
    }
    cls.prototype =
        base === null
            ? Object.create(base)
            : ((tmp.prototype = base.prototype), new tmp());
}
class A {
}
const isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {
}}`);
/**
 * Extends class with specified class name.
 */
function createClass(className, base) {
    let cls;
    if (isNativeClass) {
        cls = class extends base {
        };
    }
    else {
        cls = function () {
            return base.apply(this, arguments); // eslint-disable-line
        };
        inherit(cls, base);
    }
    Object.defineProperty(cls, 'name', { value: className });
    return cls;
}

function isMaliciousProp(prop) {
    return prop === '__proto__';
}
function getByPath(obj, path, delimiter = '/') {
    let ret;
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    if (keys.length) {
        ret = obj;
        while (keys.length) {
            const key = keys.shift();
            if (Object(ret) === ret && key && key in ret) {
                ret = ret[key];
            }
            else {
                return undefined;
            }
        }
    }
    return ret;
}
function setByPath(obj, path, value, delimiter = '/') {
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    const lastKey = keys.pop();
    if (lastKey && !isMaliciousProp(lastKey)) {
        let diver = obj;
        keys.forEach((key) => {
            if (!isMaliciousProp(key)) {
                if (diver[key] == null) {
                    diver[key] = {};
                }
                diver = diver[key];
            }
        });
        diver[lastKey] = value;
    }
    return obj;
}
function unsetByPath(obj, path, delimiter = '/') {
    const keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
    const propertyToRemove = keys.pop();
    if (propertyToRemove) {
        if (keys.length > 0) {
            const parent = getByPath(obj, keys);
            if (parent) {
                delete parent[propertyToRemove];
            }
        }
        else {
            delete obj[propertyToRemove];
        }
    }
    return obj;
}

var __decorate$j = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Basecoat extends Events {
    dispose() {
        this.off();
    }
}
__decorate$j([
    Disposable.dispose()
], Basecoat.prototype, "dispose", null);
(function (Basecoat) {
    Basecoat.dispose = Disposable.dispose;
})(Basecoat || (Basecoat = {}));
applyMixins(Basecoat, Disposable);

// @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const kebabCase = cacheStringFunction((s) => s.replace(/\B([A-Z])/g, '-$1').toLowerCase());
const pascalCase = cacheStringFunction((s) => startCase$1(camelCase$1(s)).replace(/ /g, ''));

/* eslint-disable no-bitwise */
/**
 * Return a simple hash code from a string.
 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
 */
function hashcode(str) {
    let hash = 2166136261;
    let isUnicoded = false;
    let string = str;
    for (let i = 0, ii = string.length; i < ii; i += 1) {
        let characterCode = string.charCodeAt(i);
        // Non-ASCII characters trigger the Unicode escape logic
        if (characterCode > 0x7f && !isUnicoded) {
            string = unescape(encodeURIComponent(string));
            characterCode = string.charCodeAt(i);
            isUnicoded = true;
        }
        hash ^= characterCode;
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return hash >>> 0;
}

/* eslint-disable no-bitwise */
function uuid() {
    // credit: http://stackoverflow.com/posts/2117523/revisions
    // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    //   const r = (Math.random() * 16) | 0
    //   const v = c === 'x' ? r : (r & 0x3) | 0x8
    //   return v.toString(16)
    // })
    let res = '';
    const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    for (let i = 0, len = template.length; i < len; i += 1) {
        const s = template[i];
        const r = (Math.random() * 16) | 0;
        const v = s === 'x' ? r : s === 'y' ? (r & 0x3) | 0x8 : s;
        res += v.toString(16);
    }
    return res;
}

// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts
/**
 * Given a name and a list of names that are not equal to the name, return a
 * spelling suggestion if there is one that is close enough. Names less than
 * length 3 only check for case-insensitive equality, not Levenshtein distance.
 *
 * - If there is a candidate that's the same except for case, return that.
 * - If there is a candidate that's within one edit of the name, return that.
 * - Otherwise, return the candidate with the smallest Levenshtein distance,
 *     except for candidates:
 *       * With no name
 *       * Whose length differs from the target name by more than 0.34 of the
 *         length of the name.
 *       * Whose levenshtein distance is more than 0.4 of the length of the
 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */
function getSpellingSuggestion(name, candidates, getName) {
    const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
    // If the best result isn't better than this, don't bother.
    let bestDistance = Math.floor(name.length * 0.4) + 1;
    let bestCandidate;
    let justCheckExactMatches = false;
    const nameLowerCase = name.toLowerCase();
    // eslint-disable-next-line
    for (const candidate of candidates) {
        const candidateName = getName(candidate);
        if (candidateName !== undefined &&
            Math.abs(candidateName.length - nameLowerCase.length) <=
                maximumLengthDifference) {
            const candidateNameLowerCase = candidateName.toLowerCase();
            if (candidateNameLowerCase === nameLowerCase) {
                if (candidateName === name) {
                    continue;
                }
                return candidate;
            }
            if (justCheckExactMatches) {
                continue;
            }
            if (candidateName.length < 3) {
                // Don't bother, user would have noticed a
                // 2-character name having an extra character.
                continue;
            }
            // Only care about a result better than the best so far.
            const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
            if (distance === undefined) {
                continue;
            }
            if (distance < 3) {
                justCheckExactMatches = true;
                bestCandidate = candidate;
            }
            else {
                // Debug.assert(distance < bestDistance)
                bestDistance = distance;
                bestCandidate = candidate;
            }
        }
    }
    return bestCandidate;
}
function levenshteinWithMax(s1, s2, max) {
    let previous = new Array(s2.length + 1); // eslint-disable-line
    let current = new Array(s2.length + 1); // eslint-disable-line
    /** Represents any value > max. We don't care about the particular value. */
    const big = max + 1;
    for (let i = 0; i <= s2.length; i += 1) {
        previous[i] = i;
    }
    for (let i = 1; i <= s1.length; i += 1) {
        const c1 = s1.charCodeAt(i - 1);
        const minJ = i > max ? i - max : 1;
        const maxJ = s2.length > max + i ? max + i : s2.length;
        current[0] = i;
        /** Smallest value of the matrix in the ith column. */
        let colMin = i;
        for (let j = 1; j < minJ; j += 1) {
            current[j] = big;
        }
        for (let j = minJ; j <= maxJ; j += 1) {
            const dist = c1 === s2.charCodeAt(j - 1)
                ? previous[j - 1]
                : Math.min(
                /* delete */ previous[j] + 1, 
                /* insert */ current[j - 1] + 1, 
                /* substitute */ previous[j - 1] + 2);
            current[j] = dist;
            colMin = Math.min(colMin, dist);
        }
        for (let j = maxJ + 1; j <= s2.length; j += 1) {
            current[j] = big;
        }
        if (colMin > max) {
            // Give up -- everything in this column is > max
            // and it can't get better in future columns.
            return undefined;
        }
        const temp = previous;
        previous = current;
        current = temp;
    }
    const res = previous[s2.length];
    return res > max ? undefined : res;
}

function isPercentage(val) {
    return typeof val === 'string' && val.slice(-1) === '%';
}
function normalizePercentage(num, ref) {
    if (num == null) {
        return 0;
    }
    let raw;
    if (typeof num === 'string') {
        raw = parseFloat(num);
        if (isPercentage(num)) {
            raw /= 100;
            if (Number.isFinite(raw)) {
                return raw * ref;
            }
        }
    }
    else {
        raw = num;
    }
    if (!Number.isFinite(raw)) {
        return 0;
    }
    if (raw > 0 && raw < 1) {
        return raw * ref;
    }
    return raw;
}
function normalizeSides(box) {
    if (typeof box === 'object') {
        let left = 0;
        let top = 0;
        let right = 0;
        let bottom = 0;
        if (box.vertical != null && Number.isFinite(box.vertical)) {
            top = bottom = box.vertical;
        }
        if (box.horizontal != null && Number.isFinite(box.horizontal)) {
            right = left = box.horizontal;
        }
        if (box.left != null && Number.isFinite(box.left))
            left = box.left;
        if (box.top != null && Number.isFinite(box.top))
            top = box.top;
        if (box.right != null && Number.isFinite(box.right))
            right = box.right;
        if (box.bottom != null && Number.isFinite(box.bottom))
            bottom = box.bottom;
        return { top, right, bottom, left };
    }
    let val = 0;
    if (box != null && Number.isFinite(box)) {
        val = box;
    }
    return { top: val, right: val, bottom: val, left: val };
}

/* eslint-disable no-underscore-dangle */
let _IS_MAC = false;
let _IS_IOS = false;
let _IS_WINDOWS = false;
let _IS_IE = false;
let _IS_IE11 = false;
let _IS_EDGE = false;
let _IS_NETSCAPE = false;
let _IS_CHROME_APP = false;
let _IS_CHROME = false;
let _IS_OPERA = false;
let _IS_FIREFOX = false;
let _IS_SAFARI = false;
let _SUPPORT_TOUCH = false;
let _SUPPORT_POINTER = false;
let _SUPPORT_PASSIVE = false;
let _NO_FOREIGNOBJECT = false;
if (typeof navigator === 'object') {
    const ua = navigator.userAgent;
    _IS_MAC = ua.indexOf('Macintosh') >= 0;
    _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
    _IS_WINDOWS = ua.indexOf('Windows') >= 0;
    _IS_IE = ua.indexOf('MSIE') >= 0;
    _IS_IE11 = !!ua.match(/Trident\/7\./);
    _IS_EDGE = !!ua.match(/Edge\//);
    _IS_NETSCAPE =
        ua.indexOf('Mozilla/') >= 0 &&
            ua.indexOf('MSIE') < 0 &&
            ua.indexOf('Edge/') < 0;
    _IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
    _IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
    _IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
    _IS_SAFARI =
        ua.indexOf('AppleWebKit/') >= 0 &&
            ua.indexOf('Chrome/') < 0 &&
            ua.indexOf('Edge/') < 0;
    if (typeof document === 'object') {
        _NO_FOREIGNOBJECT =
            !document.createElementNS ||
                `${document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')}` !== '[object SVGForeignObjectElement]' ||
                ua.indexOf('Opera/') >= 0;
    }
}
if (typeof window === 'object') {
    _IS_CHROME_APP =
        window.chrome != null &&
            window.chrome.app != null &&
            window.chrome.app.runtime != null;
    _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
}
if (typeof document === 'object') {
    _SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get() {
                _SUPPORT_PASSIVE = true;
            },
        });
        const div = document.createElement('div');
        if (div.addEventListener) {
            div.addEventListener('click', () => { }, options);
        }
    }
    catch (err) {
        // pass
    }
}
var Platform;
(function (Platform) {
    Platform.IS_MAC = _IS_MAC;
    Platform.IS_IOS = _IS_IOS;
    Platform.IS_WINDOWS = _IS_WINDOWS;
    Platform.IS_IE = _IS_IE;
    Platform.IS_IE11 = _IS_IE11;
    Platform.IS_EDGE = _IS_EDGE;
    /**
     * A flag indicating whether the browser is Netscape (including Firefox).
     */
    Platform.IS_NETSCAPE = _IS_NETSCAPE;
    /**
     * A flag indicating whether the the this is running inside a Chrome App.
     */
    Platform.IS_CHROME_APP = _IS_CHROME_APP;
    Platform.IS_CHROME = _IS_CHROME;
    Platform.IS_OPERA = _IS_OPERA;
    Platform.IS_FIREFOX = _IS_FIREFOX;
    Platform.IS_SAFARI = _IS_SAFARI;
    /**
     * A flag indicating whether this device supports touchstart/-move/-end
     * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
     * devices).
     */
    Platform.SUPPORT_TOUCH = _SUPPORT_TOUCH;
    /**
     * A flag indicating whether this device supports Microsoft pointer events.
     */
    Platform.SUPPORT_POINTER = _SUPPORT_POINTER;
    Platform.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
    /**
     * A flag indicating whether foreignObject support is not available. This
     * is the case for Opera, older SVG-based browsers and all versions of IE.
     */
    Platform.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
    Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));
(function (Platform) {
    function getHMRStatus() {
        const mod = window.module;
        if (mod != null && mod.hot != null && mod.hot.status != null) {
            return mod.hot.status();
        }
        return 'unkonwn';
    }
    Platform.getHMRStatus = getHMRStatus;
    function isApplyingHMR() {
        return getHMRStatus() === 'apply';
    }
    Platform.isApplyingHMR = isApplyingHMR;
    // This function checks if the specified event is supported by the browser.
    // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    const TAGNAMES = {
        select: 'input',
        change: 'input',
        submit: 'form',
        reset: 'form',
        error: 'img',
        load: 'img',
        abort: 'img',
    };
    function isEventSupported(event) {
        const elem = document.createElement(TAGNAMES[event] || 'div');
        const eventName = `on${event}`;
        let isSupported = eventName in elem;
        if (!isSupported) {
            elem.setAttribute(eventName, 'return;');
            isSupported = typeof elem[eventName] === 'function';
        }
        return isSupported;
    }
    Platform.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));

const rclass = /[\t\r\n\f]/g;
const rnotwhite = /\S+/g;
const fillSpaces = (str) => ` ${str} `;
function getClass(elem) {
    return (elem && elem.getAttribute && elem.getAttribute('class')) || '';
}
function hasClass(elem, selector) {
    if (elem == null || selector == null) {
        return false;
    }
    const classNames = fillSpaces(getClass(elem));
    const className = fillSpaces(selector);
    return elem.nodeType === 1
        ? classNames.replace(rclass, ' ').includes(className)
        : false;
}
function addClass(elem, selector) {
    if (elem == null || selector == null) {
        return;
    }
    if (typeof selector === 'function') {
        return addClass(elem, selector(getClass(elem)));
    }
    if (typeof selector === 'string' && elem.nodeType === 1) {
        const classes = selector.match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            if (memo.indexOf(fillSpaces(cls)) < 0) {
                return `${memo}${cls} `;
            }
            return memo;
        }, oldValue);
        newValue = newValue.trim();
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function removeClass(elem, selector) {
    if (elem == null) {
        return;
    }
    if (typeof selector === 'function') {
        return removeClass(elem, selector(getClass(elem)));
    }
    if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
        const classes = (selector || '').match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            const className = fillSpaces(cls);
            if (memo.indexOf(className) > -1) {
                return memo.replace(className, ' ');
            }
            return memo;
        }, oldValue);
        newValue = selector ? newValue.trim() : '';
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function toggleClass(elem, selector, stateVal) {
    if (elem == null || selector == null) {
        return;
    }
    if (stateVal != null && typeof selector === 'string') {
        stateVal ? addClass(elem, selector) : removeClass(elem, selector);
        return;
    }
    if (typeof selector === 'function') {
        return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
    }
    if (typeof selector === 'string') {
        const metches = selector.match(rnotwhite) || [];
        metches.forEach((cls) => {
            hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
        });
    }
}

let idCounter = 0;
function uniqueId() {
    idCounter += 1;
    return `v${idCounter}`;
}
function ensureId(elem) {
    if (elem.id == null || elem.id === '') {
        elem.id = uniqueId();
    }
    return elem.id;
}
/**
 * Returns true if object is an instance of SVGGraphicsElement.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
 */
function isSVGGraphicsElement(elem) {
    if (elem == null) {
        return false;
    }
    return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
}
const ns = {
    svg: 'http://www.w3.org/2000/svg',
    xmlns: 'http://www.w3.org/2000/xmlns/',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xlink: 'http://www.w3.org/1999/xlink',
    xhtml: 'http://www.w3.org/1999/xhtml',
};
const svgVersion = '1.1';
function createElement(tagName, doc = document) {
    return doc.createElement(tagName);
}
function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {
    return doc.createElementNS(namespaceURI, tagName);
}
function createSvgElement(tagName, doc = document) {
    return createElementNS(tagName, ns.svg, doc);
}
function createSvgDocument(content) {
    if (content) {
        const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content}</svg>`; // lgtm[js/html-constructed-from-input]
        const { documentElement } = parseXML(xml, { async: false });
        return documentElement;
    }
    const svg = document.createElementNS(ns.svg, 'svg');
    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);
    svg.setAttribute('version', svgVersion);
    return svg;
}
function parseXML(data, options = {}) {
    let xml;
    try {
        const parser = new DOMParser();
        if (options.async != null) {
            const instance = parser;
            instance.async = options.async;
        }
        xml = parser.parseFromString(data, options.mimeType || 'text/xml');
    }
    catch (error) {
        xml = undefined;
    }
    if (!xml || xml.getElementsByTagName('parsererror').length) {
        throw new Error(`Invalid XML: ${data}`);
    }
    return xml;
}
function tagName(node, lowercase = true) {
    const nodeName = node.nodeName;
    return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index(elem) {
    let index = 0;
    let node = elem.previousSibling;
    while (node) {
        if (node.nodeType === 1) {
            index += 1;
        }
        node = node.previousSibling;
    }
    return index;
}
function find(elem, selector) {
    return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
    return elem.querySelector(selector);
}
function findParentByClass(elem, className, terminator) {
    const ownerSVGElement = elem.ownerSVGElement;
    let node = elem.parentNode;
    while (node && node !== terminator && node !== ownerSVGElement) {
        if (hasClass(node, className)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function contains(parent, child) {
    const bup = child && child.parentNode;
    return (parent === bup ||
        !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise
    );
}
function remove(elem) {
    if (elem) {
        const elems = Array.isArray(elem) ? elem : [elem];
        elems.forEach((item) => {
            if (item.parentNode) {
                item.parentNode.removeChild(item);
            }
        });
    }
}
function empty(elem) {
    while (elem.firstChild) {
        elem.removeChild(elem.firstChild);
    }
}
function append(elem, elems) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
        if (child != null) {
            elem.appendChild(child);
        }
    });
}
function prepend(elem, elems) {
    const child = elem.firstChild;
    return child ? before(child, elems) : append(elem, elems);
}
function before(elem, elems) {
    const parent = elem.parentNode;
    if (parent) {
        const arr = Array.isArray(elems) ? elems : [elems];
        arr.forEach((child) => {
            if (child != null) {
                parent.insertBefore(child, elem);
            }
        });
    }
}
function appendTo(elem, target) {
    if (target != null) {
        target.appendChild(elem);
    }
}
// Determines whether a node is an HTML node
function isHTMLElement(elem) {
    try {
        // Using W3 DOM2 (works for FF, Opera and Chrome)
        return elem instanceof HTMLElement;
    }
    catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have (works on IE7)
        return (typeof elem === 'object' &&
            elem.nodeType === 1 &&
            typeof elem.style === 'object' &&
            typeof elem.ownerDocument === 'object');
    }
}

const CASE_SENSITIVE_ATTR = [
    'viewBox',
    'attributeName',
    'attributeType',
    'repeatCount',
    'textLength',
    'lengthAdjust',
    'gradientUnits',
];
function getAttribute(elem, name) {
    return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
    const qualified = qualifyAttr(name);
    if (qualified.ns) {
        if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
            elem.removeAttributeNS(qualified.ns, qualified.local);
        }
    }
    else if (elem.hasAttribute(name)) {
        elem.removeAttribute(name);
    }
}
function setAttribute(elem, name, value) {
    if (value == null) {
        return removeAttribute(elem, name);
    }
    const qualified = qualifyAttr(name);
    if (qualified.ns && typeof value === 'string') {
        elem.setAttributeNS(qualified.ns, name, value);
    }
    else if (name === 'id') {
        elem.id = `${value}`;
    }
    else {
        elem.setAttribute(name, `${value}`);
    }
}
function setAttributes(elem, attrs) {
    Object.keys(attrs).forEach((name) => {
        setAttribute(elem, name, attrs[name]);
    });
}
function attr(elem, name, value) {
    if (name == null) {
        const attrs = elem.attributes;
        const ret = {};
        for (let i = 0; i < attrs.length; i += 1) {
            ret[attrs[i].name] = attrs[i].value;
        }
        return ret;
    }
    if (typeof name === 'string' && value === undefined) {
        return elem.getAttribute(name);
    }
    if (typeof name === 'object') {
        setAttributes(elem, name);
    }
    else {
        setAttribute(elem, name, value);
    }
}
function qualifyAttr(name) {
    if (name.indexOf(':') !== -1) {
        const combinedKey = name.split(':');
        return {
            ns: ns[combinedKey[0]],
            local: combinedKey[1],
        };
    }
    return {
        ns: null,
        local: name,
    };
}
function kebablizeAttrs(attrs) {
    const result = {};
    Object.keys(attrs).forEach((key) => {
        const name = CASE_SENSITIVE_ATTR.includes(key) ? key : kebabCase(key);
        result[name] = attrs[key];
    });
    return result;
}
function styleToObject(styleString) {
    const ret = {};
    const styles = styleString.split(';');
    styles.forEach((item) => {
        const section = item.trim();
        if (section) {
            const pair = section.split('=');
            if (pair.length) {
                ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
            }
        }
    });
    return ret;
}
function mergeAttrs(target, source) {
    Object.keys(source).forEach((attr) => {
        if (attr === 'class') {
            target[attr] = target[attr]
                ? `${target[attr]} ${source[attr]}`
                : source[attr];
        }
        else if (attr === 'style') {
            const to = typeof target[attr] === 'object';
            const so = typeof source[attr] === 'object';
            let tt;
            let ss;
            if (to && so) {
                tt = target[attr];
                ss = source[attr];
            }
            else if (to) {
                tt = target[attr];
                ss = styleToObject(source[attr]);
            }
            else if (so) {
                tt = styleToObject(target[attr]);
                ss = source[attr];
            }
            else {
                tt = styleToObject(target[attr]);
                ss = styleToObject(source[attr]);
            }
            target[attr] = mergeAttrs(tt, ss);
        }
        else {
            target[attr] = source[attr];
        }
    });
    return target;
}

function annotate(t, annotations, opt = {}) {
    const offset = opt.offset || 0;
    const compacted = [];
    const ret = [];
    let curr;
    let prev;
    let batch = null;
    for (let i = 0; i < t.length; i += 1) {
        curr = ret[i] = t[i];
        for (let j = 0, jj = annotations.length; j < jj; j += 1) {
            const annotation = annotations[j];
            const start = annotation.start + offset;
            const end = annotation.end + offset;
            if (i >= start && i < end) {
                if (typeof curr === 'string') {
                    curr = ret[i] = {
                        t: t[i],
                        attrs: annotation.attrs,
                    };
                }
                else {
                    curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);
                }
                if (opt.includeAnnotationIndices) {
                    if (curr.annotations == null) {
                        curr.annotations = [];
                    }
                    curr.annotations.push(j);
                }
            }
        }
        prev = ret[i - 1];
        if (!prev) {
            batch = curr;
        }
        else if (isObject(curr) && isObject(prev)) {
            batch = batch;
            // Both previous item and the current one are annotations.
            // If the attributes didn't change, merge the text.
            if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
                batch.t += curr.t;
            }
            else {
                compacted.push(batch);
                batch = curr;
            }
        }
        else if (isObject(curr)) {
            // Previous item was a string, current item is an annotation.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else if (isObject(prev)) {
            // Previous item was an annotation, current item is a string.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else {
            // Both previous and current item are strings.
            batch = (batch || '') + curr;
        }
    }
    if (batch != null) {
        compacted.push(batch);
    }
    return compacted;
}

/**
 * Replaces all spaces with the Unicode No-break space.
 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
 *
 * IE would otherwise collapse all spaces into one. This is useful
 * e.g. in tests when you want to compare the actual DOM text content
 * without having to add the unicode character in the place of all spaces.
 */
function sanitize(text) {
    return text.replace(/ /g, '\u00A0');
}

var DataUri;
(function (DataUri) {
    function isDataUrl(url) {
        const prefix = 'data:';
        return url.substr(0, prefix.length) === prefix;
    }
    DataUri.isDataUrl = isDataUrl;
    /**
     * Converts an image at `url` to base64-encoded data uri.
     * The mime type of the image is inferred from the `url` file extension.
     */
    function imageToDataUri(url, callback) {
        // No need to convert to data uri if it is already in data uri.
        if (!url || isDataUrl(url)) {
            // Keep the async nature of the function.
            setTimeout(() => callback(null, url));
            return;
        }
        const onError = () => {
            callback(new Error(`Failed to load image: ${url}`));
        };
        const onLoad = window.FileReader
            ? // chrome, IE10+
                (xhr) => {
                    if (xhr.status === 200) {
                        const reader = new FileReader();
                        reader.onload = (evt) => {
                            const dataUri = evt.target.result;
                            callback(null, dataUri);
                        };
                        reader.onerror = onError;
                        reader.readAsDataURL(xhr.response);
                    }
                    else {
                        onError();
                    }
                }
            : (xhr) => {
                const toString = (u8a) => {
                    const CHUNK_SZ = 0x8000;
                    const c = [];
                    for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
                    }
                    return c.join('');
                };
                if (xhr.status === 200) {
                    let suffix = url.split('.').pop() || 'png';
                    if (suffix === 'svg') {
                        suffix = 'svg+xml';
                    }
                    const meta = `data:image/${suffix};base64,`;
                    const bytes = new Uint8Array(xhr.response);
                    const base64 = meta + btoa(toString(bytes));
                    callback(null, base64);
                }
                else {
                    onError();
                }
            };
        const xhr = new XMLHttpRequest();
        xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
        xhr.open('GET', url, true);
        xhr.addEventListener('error', onError);
        xhr.addEventListener('load', () => onLoad(xhr));
        xhr.send();
    }
    DataUri.imageToDataUri = imageToDataUri;
    function dataUriToBlob(dataUrl) {
        let uri = dataUrl.replace(/\s/g, '');
        uri = decodeURIComponent(uri);
        const index = uri.indexOf(',');
        const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'
        const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'
        const data = uri.slice(index + 1);
        let decodedString;
        if (dataType.indexOf('base64') >= 0) {
            // data may be encoded in base64
            decodedString = atob(data);
        }
        else {
            // convert the decoded string to UTF-8
            decodedString = unescape(encodeURIComponent(data));
        }
        // write the bytes of the string to a typed array
        const ia = new Uint8Array(decodedString.length);
        for (let i = 0; i < decodedString.length; i += 1) {
            ia[i] = decodedString.charCodeAt(i);
        }
        return new Blob([ia], { type: mime });
    }
    DataUri.dataUriToBlob = dataUriToBlob;
    function downloadBlob(blob, fileName) {
        const msSaveBlob = window.navigator.msSaveBlob;
        if (msSaveBlob) {
            // requires IE 10+
            // pulls up a save dialog
            msSaveBlob(blob, fileName);
        }
        else {
            // other browsers
            // downloads directly in Chrome and Safari
            // presents a save/open dialog in Firefox
            // Firefox bug: `from` field in save dialog always shows `from:blob:`
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            // mark the url for garbage collection
            window.URL.revokeObjectURL(url);
        }
    }
    DataUri.downloadBlob = downloadBlob;
    function downloadDataUri(dataUrl, fileName) {
        const blob = dataUriToBlob(dataUrl);
        downloadBlob(blob, fileName);
    }
    DataUri.downloadDataUri = downloadDataUri;
    function parseViewBox(svg) {
        const matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        if (matches && matches[2]) {
            return matches[2].replace(/\s+/, ' ').split(' ');
        }
        return null;
    }
    function getNumber(str) {
        const ret = parseFloat(str);
        return Number.isNaN(ret) ? null : ret;
    }
    function svgToDataUrl(svg, options = {}) {
        let viewBox = null;
        const getNumberFromViewBox = (index) => {
            if (viewBox == null) {
                viewBox = parseViewBox(svg);
            }
            if (viewBox != null) {
                return getNumber(viewBox[index]);
            }
            return null;
        };
        const getNumberFromMatches = (reg) => {
            const matches = svg.match(reg);
            if (matches && matches[2]) {
                return getNumber(matches[2]);
            }
            return null;
        };
        let w = options.width;
        if (w == null) {
            w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (w == null) {
            w = getNumberFromViewBox(2);
        }
        if (w == null) {
            throw new Error('Can not parse width from svg string');
        }
        let h = options.height;
        if (h == null) {
            h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (h == null) {
            h = getNumberFromViewBox(3);
        }
        if (h == null) {
            throw new Error('Can not parse height from svg string');
        }
        const decoded = encodeURIComponent(svg)
            .replace(/'/g, '%27')
            .replace(/"/g, '%22');
        const header = 'data:image/svg+xml';
        const dataUrl = `${header},${decoded}`;
        return dataUrl;
    }
    DataUri.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));

let millimeterSize;
const supportedUnits = {
    px(val) {
        return val;
    },
    mm(val) {
        return millimeterSize * val;
    },
    cm(val) {
        return millimeterSize * val * 10;
    },
    in(val) {
        return millimeterSize * val * 25.4;
    },
    pt(val) {
        return millimeterSize * ((25.4 * val) / 72);
    },
    pc(val) {
        return millimeterSize * ((25.4 * val) / 6);
    },
};
// eslint-disable-next-line
var Unit;
(function (Unit) {
    function measure(cssWidth, cssHeight, unit) {
        const div = document.createElement('div');
        const style = div.style;
        style.display = 'inline-block';
        style.position = 'absolute';
        style.left = '-15000px';
        style.top = '-15000px';
        style.width = cssWidth + (unit || 'px');
        style.height = cssHeight + (unit || 'px');
        document.body.appendChild(div);
        const rect = div.getBoundingClientRect();
        const size = {
            width: rect.width || 0,
            height: rect.height || 0,
        };
        document.body.removeChild(div);
        return size;
    }
    Unit.measure = measure;
    function toPx(val, unit) {
        if (millimeterSize == null) {
            millimeterSize = measure('1', '1', 'mm').width;
        }
        const convert = unit ? supportedUnits[unit] : null;
        if (convert) {
            return convert(val);
        }
        return val;
    }
    Unit.toPx = toPx;
})(Unit || (Unit = {}));

const hyphenPattern = /-(.)/g;
function camelize(str) {
    return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}
const memoized = {};
const prefixes = ['webkit', 'ms', 'moz', 'o'];
const testStyle = typeof document !== 'undefined' ? document.createElement('div').style : {};
function getWithPrefix(name) {
    for (let i = 0; i < prefixes.length; i += 1) {
        const prefixedName = prefixes[i] + name;
        if (prefixedName in testStyle) {
            return prefixedName;
        }
    }
    return null;
}
function getVendorPrefixedName(property) {
    const name = camelize(property);
    if (memoized[name] == null) {
        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
        memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
    }
    return memoized[name];
}

function getComputedStyle$1(elem, name) {
    // IE9+
    const computed = elem.ownerDocument &&
        elem.ownerDocument.defaultView &&
        elem.ownerDocument.defaultView.opener
        ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)
        : window.getComputedStyle(elem, null);
    if (computed && name) {
        return computed.getPropertyValue(name) || computed[name];
    }
    return computed;
}

const numericProps = {
    animationIterationCount: true,
    columnCount: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    gridArea: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnStart: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowStart: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
};
function isCSSVariable(prop) {
    return /^--/.test(prop);
}
function computeStyle(elem, prop, isVariable) {
    const style = window.getComputedStyle(elem, null);
    return isVariable
        ? style.getPropertyValue(prop) || undefined
        : style[prop] || elem.style[prop];
}
function getSuffixedValue(prop, value) {
    return !numericProps[prop] && typeof value === 'number' ? `${value}px` : value;
}
function css(elem, prop, value) {
    if (typeof prop === 'string') {
        const isVariable = isCSSVariable(prop);
        if (!isVariable) {
            prop = getVendorPrefixedName(prop); // eslint-disable-line
        }
        if (value === undefined) {
            return computeStyle(elem, prop, isVariable);
        }
        if (!isVariable) {
            value = getSuffixedValue(prop, value); // eslint-disable-line
        }
        const style = elem.style;
        if (isVariable) {
            style.setProperty(prop, value);
        }
        else {
            style[prop] = value;
        }
        return;
    }
    // eslint-disable-next-line
    for (const key in prop) {
        css(elem, key, prop[key]);
    }
}

const dataset = new WeakMap();
function getData(elem, name) {
    const key = camelCase$1(name);
    const cache = dataset.get(elem);
    if (cache) {
        return cache[key];
    }
}
function setData(elem, name, value) {
    const key = camelCase$1(name);
    const cache = dataset.get(elem);
    if (cache) {
        cache[key] = value;
    }
    else {
        dataset.set(elem, {
            [key]: value,
        });
    }
}
function data(elem, name, value) {
    if (!name) {
        const datas = {};
        Object.keys(dataset).forEach((key) => {
            datas[key] = getData(elem, key);
        });
        return datas;
    }
    if (typeof name === 'string') {
        if (value === undefined) {
            return getData(elem, name);
        }
        setData(elem, name, value);
        return;
    }
    // eslint-disable-next-line
    for (const key in name) {
        data(elem, key, name[key]);
    }
}

class Vector {
    get [Symbol.toStringTag]() {
        return Vector.toStringTag;
    }
    get type() {
        return this.node.nodeName;
    }
    get id() {
        return this.node.id;
    }
    set id(id) {
        this.node.id = id;
    }
    constructor(elem, attrs, children) {
        if (!elem) {
            throw new TypeError('Invalid element to create vector');
        }
        let node;
        if (Vector.isVector(elem)) {
            node = elem.node;
        }
        else if (typeof elem === 'string') {
            if (elem.toLowerCase() === 'svg') {
                node = createSvgDocument();
            }
            else if (elem[0] === '<') {
                const doc = createSvgDocument(elem);
                // only import the first child
                node = document.importNode(doc.firstChild, true);
            }
            else {
                node = document.createElementNS(ns.svg, elem);
            }
        }
        else {
            node = elem;
        }
        this.node = node;
        if (attrs) {
            this.setAttributes(attrs);
        }
        if (children) {
            this.append(children);
        }
    }
    transform(matrix, options) {
        if (matrix == null) {
            return transform(this.node);
        }
        transform(this.node, matrix, options);
        return this;
    }
    translate(tx, ty = 0, options = {}) {
        if (tx == null) {
            return translate(this.node);
        }
        translate(this.node, tx, ty, options);
        return this;
    }
    rotate(angle, cx, cy, options = {}) {
        if (angle == null) {
            return rotate$1(this.node);
        }
        rotate$1(this.node, angle, cx, cy, options);
        return this;
    }
    scale(sx, sy) {
        if (sx == null) {
            return scale(this.node);
        }
        scale(this.node, sx, sy);
        return this;
    }
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    getTransformToElement(target) {
        const ref = Vector.toNode(target);
        return getTransformToElement(this.node, ref);
    }
    removeAttribute(name) {
        removeAttribute(this.node, name);
        return this;
    }
    getAttribute(name) {
        return getAttribute(this.node, name);
    }
    setAttribute(name, value) {
        setAttribute(this.node, name, value);
        return this;
    }
    setAttributes(attrs) {
        setAttributes(this.node, attrs);
        return this;
    }
    attr(name, value) {
        if (name == null) {
            return attr(this.node);
        }
        if (typeof name === 'string' && value === undefined) {
            return attr(this.node, name);
        }
        if (typeof name === 'object') {
            attr(this.node, name);
        }
        else {
            attr(this.node, name, value);
        }
        return this;
    }
    svg() {
        return this.node instanceof SVGSVGElement
            ? this
            : Vector.create(this.node.ownerSVGElement);
    }
    defs() {
        const context = this.svg() || this;
        const defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) {
            return Vector.create(defsNode);
        }
        return Vector.create('defs').appendTo(context);
    }
    text(content, options = {}) {
        text$1(this.node, content, options);
        return this;
    }
    tagName() {
        return tagName(this.node);
    }
    clone() {
        return Vector.create(this.node.cloneNode(true));
    }
    remove() {
        remove(this.node);
        return this;
    }
    empty() {
        empty(this.node);
        return this;
    }
    append(elems) {
        append(this.node, Vector.toNodes(elems));
        return this;
    }
    appendTo(target) {
        appendTo(this.node, Vector.isVector(target) ? target.node : target);
        return this;
    }
    prepend(elems) {
        prepend(this.node, Vector.toNodes(elems));
        return this;
    }
    before(elems) {
        before(this.node, Vector.toNodes(elems));
        return this;
    }
    replace(elem) {
        if (this.node.parentNode) {
            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);
        }
        return Vector.create(elem);
    }
    first() {
        return this.node.firstChild
            ? Vector.create(this.node.firstChild)
            : null;
    }
    last() {
        return this.node.lastChild
            ? Vector.create(this.node.lastChild)
            : null;
    }
    get(index) {
        const child = this.node.childNodes[index];
        return child ? Vector.create(child) : null;
    }
    indexOf(elem) {
        const children = Array.prototype.slice.call(this.node.childNodes);
        return children.indexOf(Vector.toNode(elem));
    }
    find(selector) {
        const vels = [];
        const nodes = find(this.node, selector);
        if (nodes) {
            for (let i = 0, ii = nodes.length; i < ii; i += 1) {
                vels.push(Vector.create(nodes[i]));
            }
        }
        return vels;
    }
    findOne(selector) {
        const found = findOne(this.node, selector);
        return found ? Vector.create(found) : null;
    }
    findParentByClass(className, terminator) {
        const node = findParentByClass(this.node, className, terminator);
        return node ? Vector.create(node) : null;
    }
    matches(selector) {
        const node = this.node;
        this.node.matches;
        const matcher = node.matches ||
            node.matchesSelector ||
            node.msMatchesSelector ||
            node.mozMatchesSelector ||
            node.webkitMatchesSelector ||
            node.oMatchesSelector ||
            null;
        return matcher && matcher.call(node, selector);
    }
    contains(child) {
        return contains(this.node, Vector.isVector(child) ? child.node : child);
    }
    wrap(node) {
        const vel = Vector.create(node);
        const parentNode = this.node.parentNode;
        if (parentNode != null) {
            parentNode.insertBefore(vel.node, this.node);
        }
        return vel.append(this);
    }
    parent(type) {
        let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias
        // check for parent
        if (parent.node.parentNode == null) {
            return null;
        }
        // get parent element
        parent = Vector.create(parent.node.parentNode);
        if (type == null) {
            return parent;
        }
        // loop trough ancestors if type is given
        do {
            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {
                return parent;
            }
        } while ((parent = Vector.create(parent.node.parentNode)));
        return parent;
    }
    children() {
        const children = this.node.childNodes;
        const vels = [];
        for (let i = 0; i < children.length; i += 1) {
            const currentChild = children[i];
            if (currentChild.nodeType === 1) {
                vels.push(Vector.create(children[i]));
            }
        }
        return vels;
    }
    eachChild(fn, deep) {
        const children = this.children();
        for (let i = 0, l = children.length; i < l; i += 1) {
            fn.call(children[i], children[i], i, children);
            if (deep) {
                children[i].eachChild(fn, deep);
            }
        }
        return this;
    }
    index() {
        return index(this.node);
    }
    hasClass(className) {
        return hasClass(this.node, className);
    }
    addClass(className) {
        addClass(this.node, className);
        return this;
    }
    removeClass(className) {
        removeClass(this.node, className);
        return this;
    }
    toggleClass(className, stateVal) {
        toggleClass(this.node, className, stateVal);
        return this;
    }
    toLocalPoint(x, y) {
        return toLocalPoint(this.node, x, y);
    }
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    sample(interval = 1) {
        if (this.node instanceof SVGPathElement) {
            return sample(this.node, interval);
        }
        return [];
    }
    toPath() {
        return Vector.create(toPath(this.node));
    }
    toPathData() {
        return toPathData(this.node);
    }
}
(function (Vector) {
    Vector.toStringTag = `X6.${Vector.name}`;
    function isVector(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Vector) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const vector = instance;
        if ((tag == null || tag === Vector.toStringTag) &&
            vector.node instanceof SVGElement &&
            typeof vector.sample === 'function' &&
            typeof vector.toPath === 'function') {
            return true;
        }
        return false;
    }
    Vector.isVector = isVector;
    function create(elem, attrs, children) {
        return new Vector(elem, attrs, children);
    }
    Vector.create = create;
    function createVectors(markup) {
        if (markup[0] === '<') {
            const svgDoc = createSvgDocument(markup);
            const vels = [];
            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
                const childNode = svgDoc.childNodes[i];
                vels.push(create(document.importNode(childNode, true)));
            }
            return vels;
        }
        return [create(markup)];
    }
    Vector.createVectors = createVectors;
    function toNode(elem) {
        if (isVector(elem)) {
            return elem.node;
        }
        return elem;
    }
    Vector.toNode = toNode;
    function toNodes(elems) {
        if (Array.isArray(elems)) {
            return elems.map((elem) => toNode(elem));
        }
        return [toNode(elems)];
    }
    Vector.toNodes = toNodes;
})(Vector || (Vector = {}));

/* eslint-disable no-control-regex */
function createTextPathNode(attrs, elem) {
    const vel = Vector.create(elem);
    const textPath = Vector.create('textPath');
    const d = attrs.d;
    if (d && attrs['xlink:href'] === undefined) {
        const path = Vector.create('path').attr('d', d).appendTo(vel.defs());
        textPath.attr('xlink:href', `#${path.id}`);
    }
    if (typeof attrs === 'object') {
        textPath.attr(attrs);
    }
    return textPath.node;
}
function annotateTextLine(lineNode, lineAnnotations, options) {
    const eol = options.eol;
    const baseSize = options.baseSize;
    const lineHeight = options.lineHeight;
    let maxFontSize = 0;
    let tspanNode;
    const fontMetrics = {};
    const lastJ = lineAnnotations.length - 1;
    for (let j = 0; j <= lastJ; j += 1) {
        let annotation = lineAnnotations[j];
        let fontSize = null;
        if (typeof annotation === 'object') {
            const annotationAttrs = annotation.attrs;
            const vTSpan = Vector.create('tspan', annotationAttrs);
            tspanNode = vTSpan.node;
            let t = annotation.t;
            if (eol && j === lastJ) {
                t += eol;
            }
            tspanNode.textContent = t;
            // Per annotation className
            const annotationClass = annotationAttrs.class;
            if (annotationClass) {
                vTSpan.addClass(annotationClass);
            }
            // set the list of indices of all the applied annotations
            // in the `annotations` attribute. This list is a comma
            // separated list of indices.
            if (options.includeAnnotationIndices) {
                vTSpan.attr('annotations', annotation.annotations.join(','));
            }
            // Check for max font size
            fontSize = parseFloat(annotationAttrs['font-size']);
            if (fontSize === undefined)
                fontSize = baseSize;
            if (fontSize && fontSize > maxFontSize)
                maxFontSize = fontSize;
        }
        else {
            if (eol && j === lastJ) {
                annotation += eol;
            }
            tspanNode = document.createTextNode(annotation || ' ');
            if (baseSize && baseSize > maxFontSize) {
                maxFontSize = baseSize;
            }
        }
        lineNode.appendChild(tspanNode);
    }
    if (maxFontSize) {
        fontMetrics.maxFontSize = maxFontSize;
    }
    if (lineHeight) {
        fontMetrics.lineHeight = lineHeight;
    }
    else if (maxFontSize) {
        fontMetrics.lineHeight = maxFontSize * 1.2;
    }
    return fontMetrics;
}
const emRegex = /em$/;
function emToPx(em, fontSize) {
    const numerical = parseFloat(em);
    if (emRegex.test(em)) {
        return numerical * fontSize;
    }
    return numerical;
}
function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
    if (!Array.isArray(linesMetrics)) {
        return 0;
    }
    const n = linesMetrics.length;
    if (!n)
        return 0;
    let lineMetrics = linesMetrics[0];
    const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let rLineHeights = 0;
    const lineHeightPx = emToPx(lineHeight, baseSizePx);
    for (let i = 1; i < n; i += 1) {
        lineMetrics = linesMetrics[i];
        const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
        rLineHeights += iLineHeight;
    }
    const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let dy;
    switch (alignment) {
        case 'middle':
            dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
            break;
        case 'bottom':
            dy = -(0.25 * llMaxFont) - rLineHeights;
            break;
        case 'top':
        default:
            dy = 0.8 * flMaxFont;
            break;
    }
    return dy;
}
function text$1(elem, content, options = {}) {
    content = sanitize(content); // eslint-disable-line
    const eol = options.eol;
    let textPath = options.textPath;
    const verticalAnchor = options.textVerticalAnchor;
    const namedVerticalAnchor = verticalAnchor === 'middle' ||
        verticalAnchor === 'bottom' ||
        verticalAnchor === 'top';
    // Horizontal shift applied to all the lines but the first.
    let x = options.x;
    if (x === undefined) {
        x = elem.getAttribute('x') || 0;
    }
    // Annotations
    const iai = options.includeAnnotationIndices;
    let annotations = options.annotations;
    if (annotations && !Array.isArray(annotations)) {
        annotations = [annotations];
    }
    // Shift all the <tspan> but first by one line (`1em`)
    const defaultLineHeight = options.lineHeight;
    const autoLineHeight = defaultLineHeight === 'auto';
    const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
    let needEmpty = true;
    const childNodes = elem.childNodes;
    if (childNodes.length === 1) {
        const node = childNodes[0];
        if (node && node.tagName.toUpperCase() === 'TITLE') {
            needEmpty = false;
        }
    }
    if (needEmpty) {
        empty(elem);
    }
    attr(elem, {
        // Preserve spaces, do not consecutive spaces to get collapsed to one.
        'xml:space': 'preserve',
        // An empty text gets rendered into the DOM in webkit-based browsers.
        // In order to unify this behaviour across all browsers
        // we rather hide the text element when it's empty.
        display: content || options.displayEmpty ? null : 'none',
    });
    // Set default font-size if none
    const strFontSize = attr(elem, 'font-size');
    let fontSize = parseFloat(strFontSize);
    if (!fontSize) {
        fontSize = 16;
        if ((namedVerticalAnchor || annotations) && !strFontSize) {
            attr(elem, 'font-size', `${fontSize}`);
        }
    }
    let containerNode;
    if (textPath) {
        // Now all the `<tspan>`s will be inside the `<textPath>`.
        if (typeof textPath === 'string') {
            textPath = { d: textPath };
        }
        containerNode = createTextPathNode(textPath, elem);
    }
    else {
        containerNode = document.createDocumentFragment();
    }
    let dy;
    let offset = 0;
    let annotatedY;
    const lines = content.split('\n');
    const linesMetrics = [];
    const lastI = lines.length - 1;
    for (let i = 0; i <= lastI; i += 1) {
        dy = lineHeight;
        let lineClassName = 'v-line';
        const lineNode = createSvgElement('tspan');
        let lineMetrics;
        let line = lines[i];
        if (line) {
            if (annotations) {
                // Find the *compacted* annotations for this line.
                const lineAnnotations = annotate(line, annotations, {
                    offset: -offset,
                    includeAnnotationIndices: iai,
                });
                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                    eol: i !== lastI && eol,
                    baseSize: fontSize,
                    lineHeight: autoLineHeight ? null : lineHeight,
                    includeAnnotationIndices: iai,
                });
                // Get the line height based on the biggest font size
                // in the annotations for this line.
                const iLineHeight = lineMetrics.lineHeight;
                if (iLineHeight && autoLineHeight && i !== 0) {
                    dy = iLineHeight;
                }
                if (i === 0) {
                    annotatedY = lineMetrics.maxFontSize * 0.8;
                }
            }
            else {
                if (eol && i !== lastI) {
                    line += eol;
                }
                lineNode.textContent = line;
            }
        }
        else {
            // Make sure the textContent is never empty. If it is, add a dummy
            // character and make it invisible, making the following lines correctly
            // relatively positioned. `dy=1em` won't work with empty lines otherwise.
            lineNode.textContent = '-';
            lineClassName += ' v-empty-line';
            const lineNodeStyle = lineNode.style;
            lineNodeStyle.fillOpacity = 0;
            lineNodeStyle.strokeOpacity = 0;
            if (annotations) {
                lineMetrics = {};
            }
        }
        if (lineMetrics) {
            linesMetrics.push(lineMetrics);
        }
        if (i > 0) {
            lineNode.setAttribute('dy', dy);
        }
        // Firefox requires 'x' to be set on the first line
        if (i > 0 || textPath) {
            lineNode.setAttribute('x', x);
        }
        lineNode.className.baseVal = lineClassName;
        containerNode.appendChild(lineNode);
        offset += line.length + 1; // + 1 = newline character.
    }
    // Y Alignment calculation
    if (namedVerticalAnchor) {
        if (annotations) {
            dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
        }
        else if (verticalAnchor === 'top') {
            // A shortcut for top alignment. It does not depend on font-size nor line-height
            dy = '0.8em';
        }
        else {
            let rh; // remaining height
            if (lastI > 0) {
                rh = parseFloat(lineHeight) || 1;
                rh *= lastI;
                if (!emRegex.test(lineHeight))
                    rh /= fontSize;
            }
            else {
                // Single-line text
                rh = 0;
            }
            switch (verticalAnchor) {
                case 'middle':
                    dy = `${0.3 - rh / 2}em`;
                    break;
                case 'bottom':
                    dy = `${-rh - 0.3}em`;
                    break;
            }
        }
    }
    else if (verticalAnchor === 0) {
        dy = '0em';
    }
    else if (verticalAnchor) {
        dy = verticalAnchor;
    }
    else {
        // No vertical anchor is defined
        dy = 0;
        // Backwards compatibility - we change the `y` attribute instead of `dy`.
        if (elem.getAttribute('y') == null) {
            elem.setAttribute('y', `${annotatedY || '0.8em'}`);
        }
    }
    const firstLine = containerNode.firstChild;
    firstLine.setAttribute('dy', dy);
    elem.appendChild(containerNode);
}
function measureText(text, styles = {}) {
    const canvasContext = document.createElement('canvas').getContext('2d');
    if (!text) {
        return { width: 0 };
    }
    const font = [];
    const fontSize = styles['font-size']
        ? `${parseFloat(styles['font-size'])}px`
        : '14px';
    font.push(styles['font-style'] || 'normal');
    font.push(styles['font-variant'] || 'normal');
    font.push(styles['font-weight'] || 400);
    font.push(fontSize);
    font.push(styles['font-family'] || 'sans-serif');
    canvasContext.font = font.join(' ');
    return canvasContext.measureText(text);
}
function splitTextByLength(text, splitWidth, totalWidth, style = {}) {
    if (splitWidth >= totalWidth) {
        return [text, ''];
    }
    const length = text.length;
    const caches = {};
    let index = Math.round((splitWidth / totalWidth) * length - 1);
    if (index < 0) {
        index = 0;
    }
    // eslint-disable-next-line
    while (index >= 0 && index < length) {
        const frontText = text.slice(0, index);
        const frontWidth = caches[frontText] || measureText(frontText, style).width;
        const behindText = text.slice(0, index + 1);
        const behindWidth = caches[behindText] || measureText(behindText, style).width;
        caches[frontText] = frontWidth;
        caches[behindText] = behindWidth;
        if (frontWidth > splitWidth) {
            index -= 1;
        }
        else if (behindWidth <= splitWidth) {
            index += 1;
        }
        else {
            break;
        }
    }
    return [text.slice(0, index), text.slice(index)];
}
function breakText(text, size, styles = {}, options = {}) {
    const width = size.width;
    const height = size.height;
    const eol = options.eol || '\n';
    const fontSize = styles.fontSize || 14;
    const lineHeight = styles.lineHeight
        ? parseFloat(styles.lineHeight)
        : Math.ceil(fontSize * 1.4);
    const maxLines = Math.floor(height / lineHeight);
    if (text.indexOf(eol) > -1) {
        const delimiter = uuid();
        const splitText = [];
        text.split(eol).map((line) => {
            const part = breakText(line, Object.assign(Object.assign({}, size), { height: Number.MAX_SAFE_INTEGER }), styles, Object.assign(Object.assign({}, options), { eol: delimiter }));
            if (part) {
                splitText.push(...part.split(delimiter));
            }
        });
        return splitText.slice(0, maxLines).join(eol);
    }
    const { width: textWidth } = measureText(text, styles);
    if (textWidth < width) {
        return text;
    }
    const lines = [];
    let remainText = text;
    let remainWidth = textWidth;
    let ellipsis = options.ellipsis;
    let ellipsisWidth = 0;
    if (ellipsis) {
        if (typeof ellipsis !== 'string') {
            ellipsis = '\u2026';
        }
        ellipsisWidth = measureText(ellipsis, styles).width;
    }
    for (let i = 0; i < maxLines; i += 1) {
        if (remainWidth > width) {
            const isLast = i === maxLines - 1;
            if (isLast) {
                const [front] = splitTextByLength(remainText, width - ellipsisWidth, remainWidth, styles);
                lines.push(ellipsis ? `${front}${ellipsis}` : front);
            }
            else {
                const [front, behind] = splitTextByLength(remainText, width, remainWidth, styles);
                lines.push(front);
                remainText = behind;
                remainWidth = measureText(remainText, styles).width;
            }
        }
        else {
            lines.push(remainText);
            break;
        }
    }
    return lines.join(eol);
}

const KAPPA = 0.551784;
function getNumbericAttribute(elem, attr, defaultValue = NaN) {
    const v = elem.getAttribute(attr);
    if (v == null) {
        return defaultValue;
    }
    const n = parseFloat(v);
    return Number.isNaN(n) ? defaultValue : n;
}
function sample(elem, interval = 1) {
    const length = elem.getTotalLength();
    const samples = [];
    let distance = 0;
    let sample;
    while (distance < length) {
        sample = elem.getPointAtLength(distance);
        samples.push({ distance, x: sample.x, y: sample.y });
        distance += interval;
    }
    return samples;
}
function lineToPathData(line) {
    return [
        'M',
        getNumbericAttribute(line, 'x1'),
        getNumbericAttribute(line, 'y1'),
        'L',
        getNumbericAttribute(line, 'x2'),
        getNumbericAttribute(line, 'y2'),
    ].join(' ');
}
function polygonToPathData(polygon) {
    const points = getPointsFromSvgElement(polygon);
    if (points.length === 0) {
        return null;
    }
    return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
    const points = getPointsFromSvgElement(polyline);
    if (points.length === 0) {
        return null;
    }
    return svgPointsToPath(points);
}
function svgPointsToPath(points) {
    const arr = points.map((p) => `${p.x} ${p.y}`);
    return `M ${arr.join(' L')}`;
}
function getPointsFromSvgElement(elem) {
    const points = [];
    const nodePoints = elem.points;
    if (nodePoints) {
        for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
            points.push(nodePoints.getItem(i));
        }
    }
    return points;
}
function circleToPathData(circle) {
    const cx = getNumbericAttribute(circle, 'cx', 0);
    const cy = getNumbericAttribute(circle, 'cy', 0);
    const r = getNumbericAttribute(circle, 'r');
    const cd = r * KAPPA; // Control distance.
    return [
        'M',
        cx,
        cy - r,
        'C',
        cx + cd,
        cy - r,
        cx + r,
        cy - cd,
        cx + r,
        cy,
        'C',
        cx + r,
        cy + cd,
        cx + cd,
        cy + r,
        cx,
        cy + r,
        'C',
        cx - cd,
        cy + r,
        cx - r,
        cy + cd,
        cx - r,
        cy,
        'C',
        cx - r,
        cy - cd,
        cx - cd,
        cy - r,
        cx,
        cy - r,
        'Z',
    ].join(' ');
}
function ellipseToPathData(ellipse) {
    const cx = getNumbericAttribute(ellipse, 'cx', 0);
    const cy = getNumbericAttribute(ellipse, 'cy', 0);
    const rx = getNumbericAttribute(ellipse, 'rx');
    const ry = getNumbericAttribute(ellipse, 'ry') || rx;
    const cdx = rx * KAPPA; // Control distance x.
    const cdy = ry * KAPPA; // Control distance y.
    const d = [
        'M',
        cx,
        cy - ry,
        'C',
        cx + cdx,
        cy - ry,
        cx + rx,
        cy - cdy,
        cx + rx,
        cy,
        'C',
        cx + rx,
        cy + cdy,
        cx + cdx,
        cy + ry,
        cx,
        cy + ry,
        'C',
        cx - cdx,
        cy + ry,
        cx - rx,
        cy + cdy,
        cx - rx,
        cy,
        'C',
        cx - rx,
        cy - cdy,
        cx - cdx,
        cy - ry,
        cx,
        cy - ry,
        'Z',
    ].join(' ');
    return d;
}
function rectangleToPathData(rect) {
    return rectToPathData({
        x: getNumbericAttribute(rect, 'x', 0),
        y: getNumbericAttribute(rect, 'y', 0),
        width: getNumbericAttribute(rect, 'width', 0),
        height: getNumbericAttribute(rect, 'height', 0),
        rx: getNumbericAttribute(rect, 'rx', 0),
        ry: getNumbericAttribute(rect, 'ry', 0),
    });
}
function rectToPathData(r) {
    let d;
    const x = r.x;
    const y = r.y;
    const width = r.width;
    const height = r.height;
    const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
    const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
    const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
    const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);
    if (topRx || bottomRx || topRy || bottomRy) {
        d = [
            'M',
            x,
            y + topRy,
            'v',
            height - topRy - bottomRy,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            bottomRy,
            'h',
            width - 2 * bottomRx,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            -bottomRy,
            'v',
            -(height - bottomRy - topRy),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            -topRy,
            'h',
            -(width - 2 * topRx),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            topRy,
            'Z',
        ];
    }
    else {
        d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
    }
    return d.join(' ');
}
function toPath(elem) {
    const path = createSvgElement('path');
    attr(path, attr(elem));
    const d = toPathData(elem);
    if (d) {
        path.setAttribute('d', d);
    }
    return path;
}
function toPathData(elem) {
    const tagName = elem.tagName.toLowerCase();
    switch (tagName) {
        case 'path':
            return elem.getAttribute('d');
        case 'line':
            return lineToPathData(elem);
        case 'polygon':
            return polygonToPathData(elem);
        case 'polyline':
            return polylineToPathData(elem);
        case 'ellipse':
            return ellipseToPathData(elem);
        case 'circle':
            return circleToPathData(elem);
        case 'rect':
            return rectangleToPathData(elem);
    }
    throw new Error(`"${tagName}" cannot be converted to svg path element.`);
}

const transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
const transformSeparatorRegex = /[ ,]+/;
const transformationListRegex = /^(\w+)\((.*)\)/;
/**
 * Returns a SVG point object initialized with the `x` and `y` coordinates.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
 */
function createSVGPoint(x, y) {
    const svgDocument = createSvgElement('svg');
    const p = svgDocument.createSVGPoint();
    p.x = x;
    p.y = y;
    return p;
}
/**
 * Returns the SVG transformation matrix initialized with the given matrix.
 *
 * The given matrix is an object of the form:
 * {
 *   a: number
 *   b: number
 *   c: number
 *   d: number
 *   e: number
 *   f: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function createSVGMatrix(matrix) {
    const svgDocument = createSvgElement('svg');
    const mat = svgDocument.createSVGMatrix();
    if (matrix != null) {
        const source = matrix;
        const target = mat;
        // eslint-disable-next-line
        for (const key in source) {
            target[key] = source[key];
        }
    }
    return mat;
}
/**
 * Returns a SVG transform object.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
 */
function createSVGTransform(matrix) {
    const svgDocument = createSvgElement('svg');
    if (matrix != null) {
        if (!(matrix instanceof DOMMatrix)) {
            matrix = createSVGMatrix(matrix); // eslint-disable-line
        }
        return svgDocument.createSVGTransformFromMatrix(matrix);
    }
    return svgDocument.createSVGTransform();
}
/**
 * Returns the SVG transformation matrix built from the `transformString`.
 *
 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
 */
function transformStringToMatrix(transform) {
    let mat = createSVGMatrix();
    const matches = transform != null && transform.match(transformRegex);
    if (!matches) {
        return mat;
    }
    for (let i = 0, n = matches.length; i < n; i += 1) {
        const transformationString = matches[i];
        const transformationMatch = transformationString.match(transformationListRegex);
        if (transformationMatch) {
            let sx;
            let sy;
            let tx;
            let ty;
            let angle;
            let ctm = createSVGMatrix();
            const args = transformationMatch[2].split(transformSeparatorRegex);
            switch (transformationMatch[1].toLowerCase()) {
                case 'scale':
                    sx = parseFloat(args[0]);
                    sy = args[1] === undefined ? sx : parseFloat(args[1]);
                    ctm = ctm.scaleNonUniform(sx, sy);
                    break;
                case 'translate':
                    tx = parseFloat(args[0]);
                    ty = parseFloat(args[1]);
                    ctm = ctm.translate(tx, ty);
                    break;
                case 'rotate':
                    angle = parseFloat(args[0]);
                    tx = parseFloat(args[1]) || 0;
                    ty = parseFloat(args[2]) || 0;
                    if (tx !== 0 || ty !== 0) {
                        ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
                    }
                    else {
                        ctm = ctm.rotate(angle);
                    }
                    break;
                case 'skewx':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewX(angle);
                    break;
                case 'skewy':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewY(angle);
                    break;
                case 'matrix':
                    ctm.a = parseFloat(args[0]);
                    ctm.b = parseFloat(args[1]);
                    ctm.c = parseFloat(args[2]);
                    ctm.d = parseFloat(args[3]);
                    ctm.e = parseFloat(args[4]);
                    ctm.f = parseFloat(args[5]);
                    break;
                default:
                    continue;
            }
            mat = mat.multiply(ctm);
        }
    }
    return mat;
}
function matrixToTransformString(matrix) {
    const m = matrix || {};
    const a = m.a != null ? m.a : 1;
    const b = m.b != null ? m.b : 0;
    const c = m.c != null ? m.c : 0;
    const d = m.d != null ? m.d : 1;
    const e = m.e != null ? m.e : 0;
    const f = m.f != null ? m.f : 0;
    return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform) {
    let translation;
    let rotation;
    let scale;
    if (transform) {
        const separator = transformSeparatorRegex;
        // Allow reading transform string with a single matrix
        if (transform.trim().indexOf('matrix') >= 0) {
            const matrix = transformStringToMatrix(transform);
            const decomposedMatrix = decomposeMatrix(matrix);
            translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
            rotation = [decomposedMatrix.rotation];
            scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
            const transformations = [];
            if (translation[0] !== 0 || translation[1] !== 0) {
                transformations.push(`translate(${translation.join(',')})`);
            }
            if (scale[0] !== 1 || scale[1] !== 1) {
                transformations.push(`scale(${scale.join(',')})`);
            }
            if (rotation[0] !== 0) {
                transformations.push(`rotate(${rotation[0]})`);
            }
            transform = transformations.join(' '); // eslint-disable-line
        }
        else {
            const translateMatch = transform.match(/translate\((.*?)\)/);
            if (translateMatch) {
                translation = translateMatch[1].split(separator);
            }
            const rotateMatch = transform.match(/rotate\((.*?)\)/);
            if (rotateMatch) {
                rotation = rotateMatch[1].split(separator);
            }
            const scaleMatch = transform.match(/scale\((.*?)\)/);
            if (scaleMatch) {
                scale = scaleMatch[1].split(separator);
            }
        }
    }
    const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
    return {
        raw: transform || '',
        translation: {
            tx: translation && translation[0]
                ? parseInt(translation[0], 10)
                : 0,
            ty: translation && translation[1]
                ? parseInt(translation[1], 10)
                : 0,
        },
        rotation: {
            angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
            cx: rotation && rotation[1]
                ? parseInt(rotation[1], 10)
                : undefined,
            cy: rotation && rotation[2]
                ? parseInt(rotation[2], 10)
                : undefined,
        },
        scale: {
            sx,
            sy: scale && scale[1] ? parseFloat(scale[1]) : sx,
        },
    };
}
function deltaTransformPoint(matrix, point) {
    const dx = point.x * matrix.a + point.y * matrix.c + 0;
    const dy = point.x * matrix.b + point.y * matrix.d + 0;
    return { x: dx, y: dy };
}
/**
 * Decomposes the SVG transformation matrix into separate transformations.
 *
 * Returns an object of the form:
 * {
 *   translateX: number
 *   translateY: number
 *   scaleX: number
 *   scaleY: number
 *   skewX: number
 *   skewY: number
 *   rotation: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function decomposeMatrix(matrix) {
    // @see https://gist.github.com/2052247
    const px = deltaTransformPoint(matrix, { x: 0, y: 1 });
    const py = deltaTransformPoint(matrix, { x: 1, y: 0 });
    const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;
    const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);
    return {
        skewX,
        skewY,
        translateX: matrix.e,
        translateY: matrix.f,
        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
        rotation: skewX,
    };
}
function matrixToScale(matrix) {
    let a;
    let b;
    let c;
    let d;
    if (matrix) {
        a = matrix.a == null ? 1 : matrix.a;
        d = matrix.d == null ? 1 : matrix.d;
        b = matrix.b;
        c = matrix.c;
    }
    else {
        a = d = 1;
    }
    return {
        sx: b ? Math.sqrt(a * a + b * b) : a,
        sy: c ? Math.sqrt(c * c + d * d) : d,
    };
}
function matrixToRotation(matrix) {
    let p = { x: 0, y: 1 };
    if (matrix) {
        p = deltaTransformPoint(matrix, p);
    }
    const deg = (((180 * Math.atan2(p.y, p.x)) / Math.PI) % 360) - 90;
    const angle = (deg % 360) + (deg < 0 ? 360 : 0);
    return {
        angle,
    };
}
function matrixToTranslation(matrix) {
    return {
        tx: (matrix && matrix.e) || 0,
        ty: (matrix && matrix.f) || 0,
    };
}

function transform(elem, matrix, options = {}) {
    if (matrix == null) {
        return transformStringToMatrix(attr(elem, 'transform'));
    }
    if (options.absolute) {
        elem.setAttribute('transform', matrixToTransformString(matrix));
        return;
    }
    const transformList = elem.transform;
    const svgTransform = createSVGTransform(matrix);
    transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
    let transformAttr = attr(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (tx == null) {
        return transform.translation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
    const newTx = options.absolute ? tx : transform.translation.tx + tx;
    const newTy = options.absolute ? ty : transform.translation.ty + ty;
    const newTranslate = `translate(${newTx},${newTy})`;
    // Note that `translate()` is always the first transformation. This is
    // usually the desired case.
    elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());
}
function rotate$1(elem, angle, cx, cy, options = {}) {
    let transformAttr = attr(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (angle == null) {
        return transform.rotation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
    angle %= 360; // eslint-disable-line
    const newAngle = options.absolute ? angle : transform.rotation.angle + angle;
    const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';
    const newRotate = `rotate(${newAngle}${newOrigin})`;
    elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
    let transformAttr = attr(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (sx == null) {
        return transform.scale;
    }
    sy = sy == null ? sx : sy; // eslint-disable-line
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
    const newScale = `scale(${sx},${sy})`;
    elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 */
function getTransformToElement(elem, target) {
    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
        const targetCTM = target.getScreenCTM();
        const nodeCTM = elem.getScreenCTM();
        if (targetCTM && nodeCTM) {
            return targetCTM.inverse().multiply(nodeCTM);
        }
    }
    // Could not get actual transformation matrix
    return createSVGMatrix();
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 * Unlike getTransformToElement, elem is child of target,Because of the reduction in DOM API calls,
 * there is a significant performance improvement.
 */
function getTransformToParentElement(elem, target) {
    let matrix = createSVGMatrix();
    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
        let node = elem;
        const matrixList = [];
        while (node && node !== target) {
            const transform = node.getAttribute('transform') || null;
            const nodeMatrix = transformStringToMatrix(transform);
            matrixList.push(nodeMatrix);
            node = node.parentNode;
        }
        matrixList.reverse().forEach((m) => {
            matrix = matrix.multiply(m);
        });
    }
    return matrix;
}
/**
 * Converts a global point with coordinates `x` and `y` into the
 * coordinate space of the element.
 */
function toLocalPoint(elem, x, y) {
    const svg = elem instanceof SVGSVGElement
        ? elem
        : elem.ownerSVGElement;
    const p = svg.createSVGPoint();
    p.x = x;
    p.y = y;
    try {
        const ctm = svg.getScreenCTM();
        const globalPoint = p.matrixTransform(ctm.inverse());
        const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
        return globalPoint.matrixTransform(globalToLocalMatrix);
    }
    catch (e) {
        return p;
    }
}

var EventHook;
(function (EventHook) {
    const cache = {};
    function get(type) {
        return cache[type] || {};
    }
    EventHook.get = get;
    function register(type, hook) {
        cache[type] = hook;
    }
    EventHook.register = register;
    function unregister(type) {
        delete cache[type];
    }
    EventHook.unregister = unregister;
})(EventHook || (EventHook = {}));

var Store$1;
(function (Store) {
    const cache = new WeakMap();
    function ensure(target) {
        if (!cache.has(target)) {
            cache.set(target, { events: Object.create(null) });
        }
        return cache.get(target);
    }
    Store.ensure = ensure;
    function get(target) {
        return cache.get(target);
    }
    Store.get = get;
    function remove(target) {
        return cache.delete(target);
    }
    Store.remove = remove;
})(Store$1 || (Store$1 = {}));

var Util$1;
(function (Util) {
    Util.returnTrue = () => true;
    Util.returnFalse = () => false;
    function stopPropagationCallback(e) {
        e.stopPropagation();
    }
    Util.stopPropagationCallback = stopPropagationCallback;
    function addEventListener(elem, type, handler) {
        if (elem.addEventListener != null) {
            elem.addEventListener(type, handler);
        }
    }
    Util.addEventListener = addEventListener;
    function removeEventListener(elem, type, handler) {
        if (elem.removeEventListener != null) {
            elem.removeEventListener(type, handler);
        }
    }
    Util.removeEventListener = removeEventListener;
})(Util$1 || (Util$1 = {}));
(function (Util) {
    const rNotHTMLWhite = /[^\x20\t\r\n\f]+/g;
    const rNamespace = /^([^.]*)(?:\.(.+)|)/;
    function splitType(types) {
        return (types || '').match(rNotHTMLWhite) || [''];
    }
    Util.splitType = splitType;
    function normalizeType(type) {
        const parts = rNamespace.exec(type) || [];
        return {
            originType: parts[1] ? parts[1].trim() : parts[1],
            namespaces: parts[2]
                ? parts[2]
                    .split('.')
                    .map((ns) => ns.trim())
                    .sort()
                : [],
        };
    }
    Util.normalizeType = normalizeType;
    function isValidTarget(target) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
    }
    Util.isValidTarget = isValidTarget;
    function isValidSelector(elem, selector) {
        if (selector) {
            const node = elem;
            return node.querySelector != null && node.querySelector(selector) != null;
        }
        return true;
    }
    Util.isValidSelector = isValidSelector;
})(Util$1 || (Util$1 = {}));
(function (Util) {
    let seed = 0;
    const cache = new WeakMap();
    function ensureHandlerId(handler) {
        if (!cache.has(handler)) {
            cache.set(handler, seed);
            seed += 1;
        }
        return cache.get(handler);
    }
    Util.ensureHandlerId = ensureHandlerId;
    function getHandlerId(handler) {
        return cache.get(handler);
    }
    Util.getHandlerId = getHandlerId;
    function removeHandlerId(handler) {
        return cache.delete(handler);
    }
    Util.removeHandlerId = removeHandlerId;
    function setHandlerId(handler, id) {
        return cache.set(handler, id);
    }
    Util.setHandlerId = setHandlerId;
})(Util$1 || (Util$1 = {}));
(function (Util) {
    function getHandlerQueue(elem, event) {
        const queue = [];
        const store = Store$1.get(elem);
        const bag = store && store.events && store.events[event.type];
        const handlers = (bag && bag.handlers) || [];
        const delegateCount = bag ? bag.delegateCount : 0;
        if (delegateCount > 0 &&
            // Support: Firefox <=42 - 66+
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11+
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === 'click' &&
                typeof event.button === 'number' &&
                event.button >= 1)) {
            for (let curr = event.target; curr !== elem; curr = curr.parentNode || elem) {
                // Don't check non-elements
                // Don't process clicks on disabled elements
                if (curr.nodeType === 1 &&
                    !(event.type === 'click' && curr.disabled === true)) {
                    const matchedHandlers = [];
                    const matchedSelectors = {};
                    for (let i = 0; i < delegateCount; i += 1) {
                        const handleObj = handlers[i];
                        const selector = handleObj.selector;
                        if (selector != null && matchedSelectors[selector] == null) {
                            const node = elem;
                            const nodes = [];
                            node.querySelectorAll(selector).forEach((child) => {
                                nodes.push(child);
                            });
                            matchedSelectors[selector] = nodes.includes(curr);
                        }
                        if (matchedSelectors[selector]) {
                            matchedHandlers.push(handleObj);
                        }
                    }
                    if (matchedHandlers.length) {
                        queue.push({ elem: curr, handlers: matchedHandlers });
                    }
                }
            }
        }
        // Add the remaining (directly-bound) handlers
        if (delegateCount < handlers.length) {
            queue.push({ elem, handlers: handlers.slice(delegateCount) });
        }
        return queue;
    }
    Util.getHandlerQueue = getHandlerQueue;
})(Util$1 || (Util$1 = {}));
(function (Util) {
    function isWindow(obj) {
        return obj != null && obj === obj.window;
    }
    Util.isWindow = isWindow;
})(Util$1 || (Util$1 = {}));
(function (Util) {
    function contains(a, b) {
        const adown = a.nodeType === 9 ? a.documentElement : a;
        const bup = b && b.parentNode;
        return (a === bup ||
            !!(bup &&
                bup.nodeType === 1 &&
                // Support: IE 9 - 11+
                // IE doesn't have `contains` on SVG.
                (adown.contains
                    ? adown.contains(bup)
                    : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)));
    }
    Util.contains = contains;
})(Util$1 || (Util$1 = {}));

class EventObject {
    constructor(e, props) {
        this.isDefaultPrevented = Util$1.returnFalse;
        this.isPropagationStopped = Util$1.returnFalse;
        this.isImmediatePropagationStopped = Util$1.returnFalse;
        this.isSimulated = false;
        this.preventDefault = () => {
            const e = this.originalEvent;
            this.isDefaultPrevented = Util$1.returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        };
        this.stopPropagation = () => {
            const e = this.originalEvent;
            this.isPropagationStopped = Util$1.returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        };
        this.stopImmediatePropagation = () => {
            const e = this.originalEvent;
            this.isImmediatePropagationStopped = Util$1.returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        };
        if (typeof e === 'string') {
            this.type = e;
        }
        else if (e.type) {
            this.originalEvent = e;
            this.type = e.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = e.defaultPrevented
                ? Util$1.returnTrue
                : Util$1.returnFalse;
            // Create target properties
            this.target = e.target;
            this.currentTarget = e.currentTarget;
            this.relatedTarget = e.relatedTarget;
            this.timeStamp = e.timeStamp;
        }
        // Put explicitly provided properties onto the event object
        if (props) {
            Object.assign(this, props);
        }
        // Create a timestamp if incoming event doesn't have one
        if (!this.timeStamp) {
            this.timeStamp = Date.now();
        }
    }
}
(function (EventObject) {
    function create(originalEvent) {
        return originalEvent instanceof EventObject
            ? originalEvent
            : new EventObject(originalEvent);
    }
    EventObject.create = create;
})(EventObject || (EventObject = {}));
(function (EventObject) {
    function addProperty(name, hook) {
        Object.defineProperty(EventObject.prototype, name, {
            enumerable: true,
            configurable: true,
            get: typeof hook === 'function'
                ? // eslint-disable-next-line
                    function () {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    }
                : // eslint-disable-next-line
                    function () {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },
            set(value) {
                Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value,
                });
            },
        });
    }
    EventObject.addProperty = addProperty;
})(EventObject || (EventObject = {}));
(function (EventObject) {
    // Common event props including KeyEvent and MouseEvent specific props.
    const commonProps = {
        bubbles: true,
        cancelable: true,
        eventPhase: true,
        detail: true,
        view: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pageX: true,
        pageY: true,
        screenX: true,
        screenY: true,
        toElement: true,
        pointerId: true,
        pointerType: true,
        char: true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        touches: true,
        changedTouches: true,
        targetTouches: true,
        which: true,
        altKey: true,
        ctrlKey: true,
        metaKey: true,
        shiftKey: true,
    };
    Object.keys(commonProps).forEach((name) => EventObject.addProperty(name, commonProps[name]));
})(EventObject || (EventObject = {}));

(function (Special) {
    EventHook.register('load', {
        noBubble: true,
    });
})();
// Support: Chrome <=73+
// Chrome doesn't alert on `event.preventDefault()`
// as the standard mandates.
(function (Special) {
    EventHook.register('beforeunload', {
        postDispatch(elem, event) {
            if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
            }
        },
    });
})();
// For mouseenter/leave call the handler if related is outside the target.
// NB: No relatedTarget if the mouse left/entered the browser window
(function (Special) {
    EventHook.register('mouseenter', {
        delegateType: 'mouseover',
        bindType: 'mouseover',
        handle(target, event) {
            let ret;
            const related = event.relatedTarget;
            const handleObj = event.handleObj;
            if (!related || (related !== target && !Util$1.contains(target, related))) {
                event.type = handleObj.originType;
                ret = handleObj.handler.call(target, event);
                event.type = 'mouseover';
            }
            return ret;
        },
    });
    EventHook.register('mouseleave', {
        delegateType: 'mouseout',
        bindType: 'mouseout',
        handle(target, event) {
            let ret;
            const related = event.relatedTarget;
            const handleObj = event.handleObj;
            if (!related || (related !== target && !Util$1.contains(target, related))) {
                event.type = handleObj.originType;
                ret = handleObj.handler.call(target, event);
                event.type = 'mouseout';
            }
            return ret;
        },
    });
})();

var __rest$q = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Core;
(function (Core) {
    let triggered;
    function on(elem, types, handler, data, selector) {
        if (!Util$1.isValidTarget(elem)) {
            return;
        }
        // Caller can pass in an object of custom data in lieu of the handler
        let handlerData;
        if (typeof handler !== 'function') {
            const { handler: h, selector: s } = handler, others = __rest$q(handler, ["handler", "selector"]);
            handler = h; // eslint-disable-line
            selector = s; // eslint-disable-line
            handlerData = others;
        }
        // Ensure that invalid selectors throw exceptions at attach time
        // if (!Util.isValidSelector(elem, selector)) {
        //   throw new Error('Delegate event with invalid selector.')
        // }
        const store = Store$1.ensure(elem);
        // Ensure the main handle
        let mainHandler = store.handler;
        if (mainHandler == null) {
            mainHandler = store.handler = function (e, ...args) {
                return triggered !== e.type ? dispatch(elem, e, ...args) : undefined;
            };
        }
        // Make sure that the handler has a unique ID, used to find/remove it later
        const guid = Util$1.ensureHandlerId(handler);
        // Handle multiple events separated by a space
        Util$1.splitType(types).forEach((item) => {
            const { originType, namespaces } = Util$1.normalizeType(item);
            // There *must* be a type, no attaching namespace-only handlers
            if (!originType) {
                return;
            }
            let type = originType;
            let hook = EventHook.get(type);
            // If selector defined, determine special event type, otherwise given type
            type = (selector ? hook.delegateType : hook.bindType) || type;
            // Update hook based on newly reset type
            hook = EventHook.get(type);
            // handleObj is passed to all event handlers
            const handleObj = Object.assign({ type,
                originType,
                data,
                selector,
                guid, handler: handler, namespace: namespaces.join('.') }, handlerData);
            // Init the event handler queue if we're the first
            const events = store.events;
            let bag = events[type];
            if (!bag) {
                bag = events[type] = { handlers: [], delegateCount: 0 };
                // Only use addEventListener if the `hook.steup` returns false
                if (!hook.setup ||
                    hook.setup(elem, data, namespaces, mainHandler) === false) {
                    Util$1.addEventListener(elem, type, mainHandler);
                }
            }
            if (hook.add) {
                Util$1.removeHandlerId(handleObj.handler);
                hook.add(elem, handleObj);
                Util$1.setHandlerId(handleObj.handler, guid);
            }
            // Add to the element's handler list, delegates in front
            if (selector) {
                bag.handlers.splice(bag.delegateCount, 0, handleObj);
                bag.delegateCount += 1;
            }
            else {
                bag.handlers.push(handleObj);
            }
        });
    }
    Core.on = on;
    function off(elem, types, handler, selector, mappedTypes) {
        const store = Store$1.get(elem);
        if (!store) {
            return;
        }
        const events = store.events;
        if (!events) {
            return;
        }
        // Once for each type.namespace in types; type may be omitted
        Util$1.splitType(types).forEach((item) => {
            const { originType, namespaces } = Util$1.normalizeType(item);
            // Unbind all events (on this namespace, if provided) for the element
            if (!originType) {
                Object.keys(events).forEach((key) => {
                    off(elem, key + item, handler, selector, true);
                });
                return;
            }
            let type = originType;
            const hook = EventHook.get(type);
            type = (selector ? hook.delegateType : hook.bindType) || type;
            const bag = events[type];
            if (!bag) {
                return;
            }
            const rns = namespaces.length > 0
                ? new RegExp(`(^|\\.)${namespaces.join('\\.(?:.*\\.|)')}(\\.|$)`)
                : null;
            // Remove matching events
            const originHandlerCount = bag.handlers.length;
            for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {
                const handleObj = bag.handlers[i];
                if ((mappedTypes || originType === handleObj.originType) &&
                    (!handler || Util$1.getHandlerId(handler) === handleObj.guid) &&
                    (rns == null ||
                        (handleObj.namespace && rns.test(handleObj.namespace))) &&
                    (selector == null ||
                        selector === handleObj.selector ||
                        (selector === '**' && handleObj.selector))) {
                    bag.handlers.splice(i, 1);
                    if (handleObj.selector) {
                        bag.delegateCount -= 1;
                    }
                    if (hook.remove) {
                        hook.remove(elem, handleObj);
                    }
                }
            }
            if (originHandlerCount && bag.handlers.length === 0) {
                if (!hook.teardown ||
                    hook.teardown(elem, namespaces, store.handler) === false) {
                    Util$1.removeEventListener(elem, type, store.handler);
                }
                delete events[type];
            }
        });
        // Remove data and the expando if it's no longer used
        if (Object.keys(events).length === 0) {
            Store$1.remove(elem);
        }
    }
    Core.off = off;
    function dispatch(elem, evt, ...args) {
        const event = EventObject.create(evt);
        event.delegateTarget = elem;
        const hook = EventHook.get(event.type);
        if (hook.preDispatch && hook.preDispatch(elem, event) === false) {
            return;
        }
        const handlerQueue = Util$1.getHandlerQueue(elem, event);
        // Run delegates first; they may want to stop propagation beneath us
        for (let i = 0, l = handlerQueue.length; i < l && !event.isPropagationStopped(); i += 1) {
            const matched = handlerQueue[i];
            event.currentTarget = matched.elem;
            for (let j = 0, k = matched.handlers.length; j < k && !event.isImmediatePropagationStopped(); j += 1) {
                const handleObj = matched.handlers[j];
                // If event is namespaced, then each handler is only invoked if it is
                // specially universal or its namespaces are a superset of the event's.
                if (event.rnamespace == null ||
                    (handleObj.namespace && event.rnamespace.test(handleObj.namespace))) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    const hookHandle = EventHook.get(handleObj.originType).handle;
                    const result = hookHandle
                        ? hookHandle(matched.elem, event, ...args)
                        : handleObj.handler.call(matched.elem, event, ...args);
                    if (result !== undefined) {
                        event.result = result;
                        if (result === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }
        // Call the postDispatch hook for the mapped type
        if (hook.postDispatch) {
            hook.postDispatch(elem, event);
        }
        return event.result;
    }
    Core.dispatch = dispatch;
    function trigger(event, eventArgs, elem, onlyHandlers) {
        let eventObj = event;
        let type = typeof event === 'string' ? event : event.type;
        let namespaces = typeof event === 'string' || eventObj.namespace == null
            ? []
            : eventObj.namespace.split('.');
        const node = elem;
        // Don't do events on text and comment nodes
        if (node.nodeType === 3 || node.nodeType === 8) {
            return;
        }
        if (type.indexOf('.') > -1) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split('.');
            type = namespaces.shift();
            namespaces.sort();
        }
        const ontype = type.indexOf(':') < 0 && `on${type}`;
        // Caller can pass in a EventObject, Object, or just an event type string
        eventObj =
            event instanceof EventObject
                ? event
                : new EventObject(type, typeof event === 'object' ? event : null);
        eventObj.namespace = namespaces.join('.');
        eventObj.rnamespace = eventObj.namespace
            ? new RegExp(`(^|\\.)${namespaces.join('\\.(?:.*\\.|)')}(\\.|$)`)
            : null;
        // Clean up the event in case it is being reused
        eventObj.result = undefined;
        if (!eventObj.target) {
            eventObj.target = node;
        }
        const args = [eventObj];
        if (Array.isArray(eventArgs)) {
            args.push(...eventArgs);
        }
        else {
            args.push(eventArgs);
        }
        const hook = EventHook.get(type);
        if (!onlyHandlers &&
            hook.trigger &&
            hook.trigger(node, eventObj, eventArgs) === false) {
            return;
        }
        let bubbleType;
        // Determine event propagation path in advance, per W3C events spec.
        // Bubble up to document, then to window; watch for a global ownerDocument
        const eventPath = [node];
        if (!onlyHandlers && !hook.noBubble && !Util$1.isWindow(node)) {
            bubbleType = hook.delegateType || type;
            let last = node;
            let curr = node.parentNode;
            while (curr != null) {
                eventPath.push(curr);
                last = curr;
                curr = curr.parentNode;
            }
            // Only add window if we got to document
            const doc = node.ownerDocument || document;
            if (last === doc) {
                const win = last.defaultView || last.parentWindow || window;
                eventPath.push(win);
            }
        }
        let lastElement = node;
        // Fire handlers on the event path
        for (let i = 0, l = eventPath.length; i < l && !eventObj.isPropagationStopped(); i += 1) {
            const currElement = eventPath[i];
            lastElement = currElement;
            eventObj.type = i > 1 ? bubbleType : hook.bindType || type;
            // Custom handler
            const store = Store$1.get(currElement);
            if (store) {
                if (store.events[eventObj.type] && store.handler) {
                    store.handler.call(currElement, ...args);
                }
            }
            // Native handler
            const handle = (ontype && currElement[ontype]) || null;
            if (handle && Util$1.isValidTarget(currElement)) {
                eventObj.result = handle.call(currElement, ...args);
                if (eventObj.result === false) {
                    eventObj.preventDefault();
                }
            }
        }
        eventObj.type = type;
        // If nobody prevented the default action, do it now
        if (!onlyHandlers && !eventObj.isDefaultPrevented()) {
            const preventDefault = hook.preventDefault;
            if ((preventDefault == null ||
                preventDefault(eventPath.pop(), eventObj, eventArgs) === false) &&
                Util$1.isValidTarget(node)) {
                // Call a native DOM method on the target with the same name as the
                // event. Don't do default actions on window.
                if (ontype &&
                    typeof node[type] === 'function' &&
                    !Util$1.isWindow(node)) {
                    // Don't re-trigger an onFOO event when we call its FOO() method
                    const tmp = node[ontype];
                    if (tmp) {
                        node[ontype] = null;
                    }
                    // Prevent re-triggering of the same event, since we already bubbled it above
                    triggered = type;
                    if (eventObj.isPropagationStopped()) {
                        lastElement.addEventListener(type, Util$1.stopPropagationCallback);
                    }
                    node[type]();
                    if (eventObj.isPropagationStopped()) {
                        lastElement.removeEventListener(type, Util$1.stopPropagationCallback);
                    }
                    triggered = undefined;
                    if (tmp) {
                        node[ontype] = tmp;
                    }
                }
            }
        }
        return eventObj.result;
    }
    Core.trigger = trigger;
})(Core || (Core = {}));

/* eslint-disable no-param-reassign */
var Event;
(function (Event) {
    function on(elem, events, selector, data, handler) {
        Private$3.on(elem, events, selector, data, handler);
        return elem;
    }
    Event.on = on;
    function once(elem, events, selector, data, handler) {
        Private$3.on(elem, events, selector, data, handler, true);
        return elem;
    }
    Event.once = once;
    function off(elem, events, selector, handler) {
        Private$3.off(elem, events, selector, handler);
        return elem;
    }
    Event.off = off;
    function trigger(elem, event, args, 
    /**
     * When onlyHandlers is `true`
     * - Will not call `.event()` on the element it is triggered on. This means
     *   `.trigger('submit', [], true)` on a form will not call `.submit()` on
     *   the form.
     * - Events will not bubble up the DOM hierarchy; if they are not handled
     *   by the target element directly, they do nothing.
     */
    onlyHandlers) {
        Core.trigger(event, args, elem, onlyHandlers);
        return elem;
    }
    Event.trigger = trigger;
})(Event || (Event = {}));
var Private$3;
(function (Private) {
    function on(elem, types, selector, data, fn, once) {
        // Types can be a map of types/handlers
        if (typeof types === 'object') {
            // ( types-Object, selector, data )
            if (typeof selector !== 'string') {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            Object.keys(types).forEach((type) => on(elem, type, selector, data, types[type], once));
            return;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        }
        else if (fn == null) {
            if (typeof selector === 'string') {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            }
            else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = Util$1.returnFalse;
        }
        else if (!fn) {
            return;
        }
        if (once) {
            const originHandler = fn;
            fn = function (event, ...args) {
                // Can use an empty set, since event contains the info
                Private.off(elem, event);
                return originHandler.call(this, event, ...args);
            };
            // Use same guid so caller can remove using origFn
            Util$1.setHandlerId(fn, Util$1.ensureHandlerId(originHandler));
        }
        Core.on(elem, types, fn, data, selector);
    }
    Private.on = on;
    function off(elem, events, selector, fn) {
        const evt = events;
        if (evt && evt.preventDefault != null && evt.handleObj != null) {
            const obj = evt.handleObj;
            off(evt.delegateTarget, obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType, obj.selector, obj.handler);
            return;
        }
        if (typeof events === 'object') {
            // ( types-object [, selector] )
            const types = events;
            Object.keys(types).forEach((type) => off(elem, type, selector, types[type]));
            return;
        }
        if (selector === false || typeof selector === 'function') {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if (fn === false) {
            fn = Util$1.returnFalse;
        }
        Core.off(elem, events, fn, selector);
    }
    Private.off = off;
})(Private$3 || (Private$3 = {}));

class MouseWheelHandle {
    constructor(target, onWheelCallback, onWheelGuard) {
        this.animationFrameId = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.eventName = Platform.isEventSupported('wheel')
            ? 'wheel'
            : 'mousewheel';
        this.target = target;
        this.onWheelCallback = onWheelCallback;
        this.onWheelGuard = onWheelGuard;
        this.onWheel = this.onWheel.bind(this);
        this.didWheel = this.didWheel.bind(this);
    }
    enable() {
        this.target.addEventListener(this.eventName, this.onWheel, {
            passive: false,
        });
    }
    disable() {
        this.target.removeEventListener(this.eventName, this.onWheel);
    }
    onWheel(e) {
        if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
            return;
        }
        this.deltaX += e.deltaX;
        this.deltaY += e.deltaY;
        e.preventDefault();
        let changed;
        if (this.deltaX !== 0 || this.deltaY !== 0) {
            e.stopPropagation();
            changed = true;
        }
        if (changed === true && this.animationFrameId === 0) {
            this.animationFrameId = requestAnimationFrame(() => {
                this.didWheel(e);
            });
        }
    }
    didWheel(e) {
        this.animationFrameId = 0;
        this.onWheelCallback(e, this.deltaX, this.deltaY);
        this.deltaX = 0;
        this.deltaY = 0;
    }
}

function debounce(fn, delay = 60) {
    let timer = null;
    return (...args) => {
        if (timer) {
            clearTimeout(timer);
        }
        timer = window.setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}

function createSensor$2(element) {
    let sensor = null;
    let listeners = [];
    const create = () => {
        if (getComputedStyle(element).position === 'static') {
            const style = element.style;
            style.position = 'relative';
        }
        const obj = document.createElement('object');
        obj.onload = () => {
            obj.contentDocument.defaultView.addEventListener('resize', trigger);
            trigger();
        };
        obj.style.display = 'block';
        obj.style.position = 'absolute';
        obj.style.top = '0';
        obj.style.left = '0';
        obj.style.height = '100%';
        obj.style.width = '100%';
        obj.style.overflow = 'hidden';
        obj.style.pointerEvents = 'none';
        obj.style.zIndex = '-1';
        obj.style.opacity = '0';
        obj.setAttribute('tabindex', '-1');
        obj.type = 'text/html';
        element.appendChild(obj);
        // for ie, should set data attribute delay, or will be white screen
        obj.data = 'about:blank';
        return obj;
    };
    const trigger = debounce(() => {
        listeners.forEach((listener) => listener(element));
    });
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor && sensor.parentNode) {
            if (sensor.contentDocument) {
                sensor.contentDocument.defaultView.removeEventListener('resize', trigger);
            }
            sensor.parentNode.removeChild(sensor);
            sensor = null;
            listeners = [];
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}

function createSensor$1(element) {
    let sensor = null;
    let listeners = [];
    const trigger = debounce(() => {
        listeners.forEach((listener) => {
            listener(element);
        });
    });
    const create = () => {
        const s = new ResizeObserver(trigger);
        s.observe(element);
        trigger();
        return s;
    };
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor) {
            sensor.disconnect();
            listeners = [];
            sensor = null;
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}

const createSensor = typeof ResizeObserver !== 'undefined'
    ? createSensor$1
    : createSensor$2;

var SizeSensor;
(function (SizeSensor) {
    const cache = new WeakMap();
    function get(element) {
        let sensor = cache.get(element);
        if (sensor) {
            return sensor;
        }
        sensor = createSensor(element);
        cache.set(element, sensor);
        return sensor;
    }
    function remove(sensor) {
        sensor.destroy();
        cache.delete(sensor.element);
    }
    SizeSensor.bind = (element, cb) => {
        const sensor = get(element);
        sensor.bind(cb);
        return () => sensor.unbind(cb);
    };
    SizeSensor.clear = (element) => {
        const sensor = get(element);
        remove(sensor);
    };
})(SizeSensor || (SizeSensor = {}));

/**
 * An implementation of the Priority Queue abstract data type.
 *
 * @see: http://en.wikipedia.org/wiki/Priority_queue
 *
 * It is like a normal stack or queue, but where each item has assigned a
 * priority (a number). Items with higher priority are served before items
 * with lower priority. This implementation uses binary heap as an internal
 * representation of the queue. The time complexity of all the methods is as
 * follows:
 *
 * - create: `O(n)`
 * - insert: `O(log n)`
 * - remove: `O(log n)`
 * - peek: `O(1)`
 * - isEmpty: `O(1)`
 * - peekPriority: `O(1)`
 */
class PriorityQueue {
    constructor(options = {}) {
        this.comparator = options.comparator || PriorityQueue.defaultComparator;
        this.index = {};
        this.data = options.data || [];
        this.heapify();
    }
    /**
     * Returns `true` if the priority queue is empty, `false` otherwise.
     */
    isEmpty() {
        return this.data.length === 0;
    }
    /**
     * Inserts a value with priority to the queue. Optionally pass a unique
     * id of this item. Passing unique IDs for each item you insert allows
     * you to use the `updatePriority()` operation.
     * @param priority
     * @param value
     * @param id
     */
    insert(priority, value, id) {
        const item = { priority, value };
        const index = this.data.length;
        if (id) {
            item.id = id;
            this.index[id] = index;
        }
        this.data.push(item);
        this.bubbleUp(index);
        return this;
    }
    /**
     * Returns the value of an item with the highest priority.
     */
    peek() {
        return this.data[0] ? this.data[0].value : null;
    }
    /**
     * Returns the highest priority in the queue.
     */
    peekPriority() {
        return this.data[0] ? this.data[0].priority : null;
    }
    updatePriority(id, priority) {
        const index = this.index[id];
        if (typeof index === 'undefined') {
            throw new Error(`Node with id '${id}' was not found in the heap.`);
        }
        const data = this.data;
        const oldPriority = data[index].priority;
        const comp = this.comparator(priority, oldPriority);
        if (comp < 0) {
            data[index].priority = priority;
            this.bubbleUp(index);
        }
        else if (comp > 0) {
            data[index].priority = priority;
            this.bubbleDown(index);
        }
    }
    /**
     * Removes the item with the highest priority from the queue
     *
     * @returns The value of the removed item.
     */
    remove() {
        const data = this.data;
        const peek = data[0];
        const last = data.pop();
        if (peek.id) {
            delete this.index[peek.id];
        }
        if (data.length > 0) {
            data[0] = last;
            if (last.id) {
                this.index[last.id] = 0;
            }
            this.bubbleDown(0);
        }
        return peek ? peek.value : null;
    }
    heapify() {
        for (let i = 0; i < this.data.length; i += 1) {
            this.bubbleUp(i);
        }
    }
    bubbleUp(index) {
        const data = this.data;
        let tmp;
        let parent;
        let current = index;
        while (current > 0) {
            parent = (current - 1) >>> 1;
            if (this.comparator(data[current].priority, data[parent].priority) < 0) {
                tmp = data[parent];
                data[parent] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = parent;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = parent;
            }
            else {
                break;
            }
        }
    }
    bubbleDown(index) {
        const data = this.data;
        const last = data.length - 1;
        let current = index;
        // eslint-disable-next-line
        while (true) {
            const left = (current << 1) + 1;
            const right = left + 1;
            let minIndex = current;
            if (left <= last &&
                this.comparator(data[left].priority, data[minIndex].priority) < 0) {
                minIndex = left;
            }
            if (right <= last &&
                this.comparator(data[right].priority, data[minIndex].priority) < 0) {
                minIndex = right;
            }
            if (minIndex !== current) {
                const tmp = data[minIndex];
                data[minIndex] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = minIndex;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = minIndex;
            }
            else {
                break;
            }
        }
    }
}
(function (PriorityQueue) {
    PriorityQueue.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));

var Dijkstra;
(function (Dijkstra) {
    function run(adjacencyList, source, weight = (u, v) => 1) {
        const dist = {};
        const previous = {};
        const scanned = {};
        const queue = new PriorityQueue();
        dist[source] = 0;
        Object.keys(adjacencyList).forEach((v) => {
            if (v !== source) {
                dist[v] = Infinity;
            }
            queue.insert(dist[v], v, v);
        });
        while (!queue.isEmpty()) {
            const u = queue.remove();
            scanned[u] = true;
            const neighbours = adjacencyList[u] || [];
            for (let i = 0; i < neighbours.length; i += 1) {
                const v = neighbours[i];
                if (!scanned[v]) {
                    const alt = dist[u] + weight(u, v);
                    if (alt < dist[v]) {
                        dist[v] = alt;
                        previous[v] = u;
                        queue.updatePriority(v, alt);
                    }
                }
            }
        }
        return previous;
    }
    Dijkstra.run = run;
})(Dijkstra || (Dijkstra = {}));

/* eslint-disable no-constructor-return */
class Color {
    constructor(color, g, b, a) {
        if (color == null) {
            return this.set(255, 255, 255, 1);
        }
        if (typeof color === 'number') {
            return this.set(color, g, b, a);
        }
        if (typeof color === 'string') {
            return Color.fromString(color) || this;
        }
        if (Array.isArray(color)) {
            return this.set(color);
        }
        this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
    }
    blend(start, end, weight) {
        this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
    }
    lighten(amount) {
        const rgba = Color.lighten(this.toArray(), amount);
        this.r = rgba[0];
        this.g = rgba[1];
        this.b = rgba[2];
        this.a = rgba[3];
    }
    darken(amount) {
        this.lighten(-amount);
    }
    set(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        this.r = Math.round(clamp(r, 0, 255));
        this.g = Math.round(clamp(g, 0, 255));
        this.b = Math.round(clamp(b, 0, 255));
        this.a = a == null ? 1 : clamp(a, 0, 1);
        return this;
    }
    toHex() {
        const hex = ['r', 'g', 'b'].map((key) => {
            const str = this[key].toString(16);
            return str.length < 2 ? `0${str}` : str;
        });
        return `#${hex.join('')}`;
    }
    toRGBA() {
        return this.toArray();
    }
    toHSLA() {
        return Color.rgba2hsla(this.r, this.g, this.b, this.a);
    }
    toCSS(ignoreAlpha) {
        const rgb = `${this.r},${this.g},${this.b},`;
        return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
    }
    toGrey() {
        return Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
    }
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    toString() {
        return this.toCSS();
    }
}
(function (Color) {
    function fromArray(arr) {
        return new Color(arr);
    }
    Color.fromArray = fromArray;
    function fromHex(color) {
        return new Color([...hex2rgb(color), 1]);
    }
    Color.fromHex = fromHex;
    function fromRGBA(color) {
        const matches = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[1].split(/\s*,\s*/).map((v) => parseInt(v, 10));
            return new Color(arr);
        }
        return null;
    }
    Color.fromRGBA = fromRGBA;
    function hue2rgb(m1, m2, h) {
        if (h < 0) {
            ++h; // eslint-disable-line
        }
        if (h > 1) {
            --h; // eslint-disable-line
        }
        const h6 = 6 * h;
        if (h6 < 1) {
            return m1 + (m2 - m1) * h6;
        }
        if (2 * h < 1) {
            return m2;
        }
        if (3 * h < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }
    function fromHSLA(color) {
        const matches = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[2].split(/\s*,\s*/);
            const h = (((parseFloat(arr[0]) % 360) + 360) % 360) / 360;
            const s = parseFloat(arr[1]) / 100;
            const l = parseFloat(arr[2]) / 100;
            const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
            return new Color(hsla2rgba(h, s, l, a));
        }
        return null;
    }
    Color.fromHSLA = fromHSLA;
    function fromString(color) {
        if (color.startsWith('#')) {
            return fromHex(color);
        }
        if (color.startsWith('rgb')) {
            return fromRGBA(color);
        }
        const preset = Color.named[color];
        if (preset) {
            return fromHex(preset);
        }
        return fromHSLA(color);
    }
    Color.fromString = fromString;
    function makeGrey(g, a) {
        return Color.fromArray([g, g, g, a]);
    }
    Color.makeGrey = makeGrey;
    function rgba2hsla(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h = 0;
        let s = 0;
        if (min !== max) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, l, a == null ? 1 : a];
    }
    Color.rgba2hsla = rgba2hsla;
    function hsla2rgba(arg0, arg1, arg2, arg3) {
        const h = Array.isArray(arg0) ? arg0[0] : arg0;
        const s = Array.isArray(arg0) ? arg0[1] : arg1;
        const l = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        const m1 = 2 * l - m2;
        return [
            hue2rgb(m1, m2, h + 1 / 3) * 256,
            hue2rgb(m1, m2, h) * 256,
            hue2rgb(m1, m2, h - 1 / 3) * 256,
            a == null ? 1 : a,
        ];
    }
    Color.hsla2rgba = hsla2rgba;
    function random(ignoreAlpha) {
        return new Color(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? undefined : parseFloat(Math.random().toFixed(2)));
    }
    Color.random = random;
    function randomHex() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i += 1) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    Color.randomHex = randomHex;
    function randomRGBA(ignoreAlpha) {
        return random(ignoreAlpha).toString();
    }
    Color.randomRGBA = randomRGBA;
    function invert(color, bw) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const [r, g, b] = hex2rgb(color);
            if (bw) {
                // http://stackoverflow.com/a/3943023/112731
                return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#ffffff';
            }
            return `${pound ? '#' : ''}${rgb2hex(255 - r, 255 - g, 255 - b)}`;
        }
        const r = color[0];
        const g = color[1];
        const b = color[2];
        const a = color[3];
        if (bw) {
            return r * 0.299 + g * 0.587 + b * 0.114 > 186
                ? [0, 0, 0, a]
                : [255, 255, 255, a];
        }
        return [255 - r, 255 - g, 255 - b, a];
    }
    Color.invert = invert;
    function hex2rgb(hex) {
        const color = hex.indexOf('#') === 0 ? hex : `#${hex}`;
        let val = Number(`0x${color.substr(1)}`);
        if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
            throw new Error('Invalid hex color.');
        }
        const bits = color.length === 4 ? 4 : 8;
        const mask = (1 << bits) - 1;
        const bgr = ['b', 'g', 'r'].map(() => {
            const c = val & mask;
            val >>= bits;
            return bits === 4 ? 17 * c : c;
        });
        return [bgr[2], bgr[1], bgr[0]];
    }
    function rgb2hex(r, g, b) {
        const pad = (hex) => (hex.length < 2 ? `0${hex}` : hex);
        return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`;
    }
    function lighten(color, amt) {
        return lum(color, amt);
    }
    Color.lighten = lighten;
    function darken(color, amt) {
        return lum(color, -amt);
    }
    Color.darken = darken;
    function lum(color, amt) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const num = parseInt(pound ? color.substr(1) : color, 16);
            const r = clamp((num >> 16) + amt, 0, 255);
            const g = clamp(((num >> 8) & 0x00ff) + amt, 0, 255);
            const b = clamp((num & 0x0000ff) + amt, 0, 255);
            return `${pound ? '#' : ''}${(b | (g << 8) | (r << 16)).toString(16)}`;
        }
        const hex = rgb2hex(color[0], color[1], color[2]);
        const arr = hex2rgb(lum(hex, amt));
        return [arr[0], arr[1], arr[2], color[3]];
    }
})(Color || (Color = {}));
(function (Color) {
    Color.named = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        burntsienna: '#ea7e5d',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
    };
})(Color || (Color = {}));

class Dictionary {
    constructor() {
        this.clear();
    }
    clear() {
        this.map = new WeakMap();
        this.arr = [];
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        return this.map.get(key);
    }
    set(key, value) {
        this.map.set(key, value);
        this.arr.push(key);
    }
    delete(key) {
        const index = this.arr.indexOf(key);
        if (index >= 0) {
            this.arr.splice(index, 1);
        }
        const ret = this.map.get(key);
        this.map.delete(key);
        return ret;
    }
    each(iterator) {
        this.arr.forEach((key) => {
            const value = this.map.get(key);
            iterator(value, key);
        });
    }
    dispose() {
        this.clear();
    }
}

// eslint-disable-next-line
var ModifierKey;
(function (ModifierKey) {
    function parse(modifiers) {
        const or = [];
        const and = [];
        if (Array.isArray(modifiers)) {
            or.push(...modifiers);
        }
        else {
            modifiers.split('|').forEach((item) => {
                if (item.indexOf('&') === -1) {
                    or.push(item);
                }
                else {
                    and.push(...item.split('&'));
                }
            });
        }
        return { or, and };
    }
    ModifierKey.parse = parse;
    function equals(modifiers1, modifiers2) {
        if (modifiers1 != null && modifiers2 != null) {
            const m1 = parse(modifiers1);
            const m2 = parse(modifiers2);
            const or1 = m1.or.sort();
            const or2 = m2.or.sort();
            const and1 = m1.and.sort();
            const and2 = m2.and.sort();
            const equal = (a1, a2) => {
                return (a1.length === a2.length &&
                    (a1.length === 0 || a1.every((a, i) => a === a2[i])));
            };
            return equal(or1, or2) && equal(and1, and2);
        }
        if (modifiers1 == null && modifiers2 == null) {
            return true;
        }
        return false;
    }
    ModifierKey.equals = equals;
    function isMatch(e, modifiers, strict) {
        if (modifiers == null ||
            (Array.isArray(modifiers) && modifiers.length === 0)) {
            return strict
                ? e.altKey !== true &&
                    e.ctrlKey !== true &&
                    e.metaKey !== true &&
                    e.shiftKey !== true
                : true;
        }
        const { or, and } = parse(modifiers);
        const match = (key) => {
            const name = `${key.toLowerCase()}Key`;
            return e[name] === true;
        };
        return or.some((key) => match(key)) && and.every((key) => match(key));
    }
    ModifierKey.isMatch = isMatch;
})(ModifierKey || (ModifierKey = {}));

var Timing;
(function (Timing) {
    Timing.linear = (t) => t;
    Timing.quad = (t) => t * t;
    Timing.cubic = (t) => t * t * t;
    Timing.inout = (t) => {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        const t2 = t * t;
        const t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    };
    Timing.exponential = (t) => {
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    };
    Timing.bounce = ((t) => {
        // eslint-disable-next-line
        for (let a = 0, b = 1; 1; a += b, b /= 2) {
            if (t >= (7 - 4 * a) / 11) {
                const q = (11 - 6 * a - 11 * t) / 4;
                return -q * q + b * b;
            }
        }
    });
})(Timing || (Timing = {}));
(function (Timing) {
    Timing.decorators = {
        reverse(f) {
            return (t) => 1 - f(1 - t);
        },
        reflect(f) {
            return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        },
        clamp(f, n = 0, x = 1) {
            return (t) => {
                const r = f(t);
                return r < n ? n : r > x ? x : r;
            };
        },
        back(s = 1.70158) {
            return (t) => t * t * ((s + 1) * t - s);
        },
        elastic(x = 1.5) {
            return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(((20 * Math.PI * x) / 3) * t); // eslint-disable-line
        },
    };
})(Timing || (Timing = {}));
(function (Timing) {
    // Slight acceleration from zero to full speed
    function easeInSine(t) {
        return -1 * Math.cos(t * (Math.PI / 2)) + 1;
    }
    Timing.easeInSine = easeInSine;
    // Slight deceleration at the end
    function easeOutSine(t) {
        return Math.sin(t * (Math.PI / 2));
    }
    Timing.easeOutSine = easeOutSine;
    // Slight acceleration at beginning and slight deceleration at end
    function easeInOutSine(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }
    Timing.easeInOutSine = easeInOutSine;
    // Accelerating from zero velocity
    function easeInQuad(t) {
        return t * t;
    }
    Timing.easeInQuad = easeInQuad;
    // Decelerating to zero velocity
    function easeOutQuad(t) {
        return t * (2 - t);
    }
    Timing.easeOutQuad = easeOutQuad;
    // Acceleration until halfway, then deceleration
    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    Timing.easeInOutQuad = easeInOutQuad;
    // Accelerating from zero velocity
    function easeInCubic(t) {
        return t * t * t;
    }
    Timing.easeInCubic = easeInCubic;
    // Decelerating to zero velocity
    function easeOutCubic(t) {
        const t1 = t - 1;
        return t1 * t1 * t1 + 1;
    }
    Timing.easeOutCubic = easeOutCubic;
    // Acceleration until halfway, then deceleration
    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    Timing.easeInOutCubic = easeInOutCubic;
    // Accelerating from zero velocity
    function easeInQuart(t) {
        return t * t * t * t;
    }
    Timing.easeInQuart = easeInQuart;
    // Decelerating to zero velocity
    function easeOutQuart(t) {
        const t1 = t - 1;
        return 1 - t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuart = easeOutQuart;
    // Acceleration until halfway, then deceleration
    function easeInOutQuart(t) {
        const t1 = t - 1;
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuart = easeInOutQuart;
    // Accelerating from zero velocity
    function easeInQuint(t) {
        return t * t * t * t * t;
    }
    Timing.easeInQuint = easeInQuint;
    // Decelerating to zero velocity
    function easeOutQuint(t) {
        const t1 = t - 1;
        return 1 + t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuint = easeOutQuint;
    // Acceleration until halfway, then deceleration
    function easeInOutQuint(t) {
        const t1 = t - 1;
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuint = easeInOutQuint;
    // Accelerate exponentially until finish
    function easeInExpo(t) {
        if (t === 0) {
            return 0;
        }
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    }
    Timing.easeInExpo = easeInExpo;
    // Initial exponential acceleration slowing to stop
    function easeOutExpo(t) {
        if (t === 1) {
            return 1;
        }
        return -Math.pow(2, -10 * t) + 1; // eslint-disable-line
    }
    Timing.easeOutExpo = easeOutExpo;
    // Exponential acceleration and deceleration
    function easeInOutExpo(t) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        if (scaledTime < 1) {
            return 0.5 * Math.pow(2, 10 * scaledTime1); // eslint-disable-line
        }
        return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2); // eslint-disable-line
    }
    Timing.easeInOutExpo = easeInOutExpo;
    // Increasing velocity until stop
    function easeInCirc(t) {
        const scaledTime = t / 1;
        return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
    }
    Timing.easeInCirc = easeInCirc;
    // Start fast, decreasing velocity until stop
    function easeOutCirc(t) {
        const t1 = t - 1;
        return Math.sqrt(1 - t1 * t1);
    }
    Timing.easeOutCirc = easeOutCirc;
    // Fast increase in velocity, fast decrease in velocity
    function easeInOutCirc(t) {
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 2;
        if (scaledTime < 1) {
            return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
        }
        return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
    }
    Timing.easeInOutCirc = easeInOutCirc;
    // Slow movement backwards then fast snap to finish
    function easeInBack(t, magnitude = 1.70158) {
        return t * t * ((magnitude + 1) * t - magnitude);
    }
    Timing.easeInBack = easeInBack;
    // Fast snap to backwards point then slow resolve to finish
    function easeOutBack(t, magnitude = 1.70158) {
        const scaledTime = t / 1 - 1;
        return (scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1);
    }
    Timing.easeOutBack = easeOutBack;
    // Slow movement backwards, fast snap to past finish, slow resolve to finish
    function easeInOutBack(t, magnitude = 1.70158) {
        const scaledTime = t * 2;
        const scaledTime2 = scaledTime - 2;
        const s = magnitude * 1.525;
        if (scaledTime < 1) {
            return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
        }
        return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
    }
    Timing.easeInOutBack = easeInOutBack;
    // Bounces slowly then quickly to finish
    function easeInElastic(t, magnitude = 0.7) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t / 1;
        const scaledTime1 = scaledTime - 1;
        const p = 1 - magnitude;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p));
    }
    Timing.easeInElastic = easeInElastic;
    // Fast acceleration, bounces to zero
    function easeOutElastic(t, magnitude = 0.7) {
        const p = 1 - magnitude;
        const scaledTime = t * 2;
        if (t === 0 || t === 1) {
            return t;
        }
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return (Math.pow(2, -10 * scaledTime) * // eslint-disable-line
            Math.sin(((scaledTime - s) * (2 * Math.PI)) / p) +
            1);
    }
    Timing.easeOutElastic = easeOutElastic;
    // Slow start and end, two bounces sandwich a fast motion
    function easeInOutElastic(t, magnitude = 0.65) {
        const p = 1 - magnitude;
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        if (scaledTime < 1) {
            return (-0.5 *
                (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
                    Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p)));
        }
        return (Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p) *
            0.5 +
            1);
    }
    Timing.easeInOutElastic = easeInOutElastic;
    // Bounce to completion
    function easeOutBounce(t) {
        const scaledTime = t / 1;
        if (scaledTime < 1 / 2.75) {
            return 7.5625 * scaledTime * scaledTime;
        }
        if (scaledTime < 2 / 2.75) {
            const scaledTime2 = scaledTime - 1.5 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
        }
        if (scaledTime < 2.5 / 2.75) {
            const scaledTime2 = scaledTime - 2.25 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
        }
        {
            const scaledTime2 = scaledTime - 2.625 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
        }
    }
    Timing.easeOutBounce = easeOutBounce;
    // Bounce increasing in velocity until completion
    function easeInBounce(t) {
        return 1 - easeOutBounce(1 - t);
    }
    Timing.easeInBounce = easeInBounce;
    // Bounce in and bounce out
    function easeInOutBounce(t) {
        if (t < 0.5) {
            return easeInBounce(t * 2) * 0.5;
        }
        return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
    Timing.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));

var Interp;
(function (Interp) {
    Interp.number = (a, b) => {
        const d = b - a;
        return (t) => {
            return a + d * t;
        };
    };
    Interp.object = (a, b) => {
        const keys = Object.keys(a);
        return (t) => {
            const ret = {};
            for (let i = keys.length - 1; i !== -1; i -= 1) {
                const key = keys[i];
                ret[key] = a[key] + (b[key] - a[key]) * t;
            }
            return ret;
        };
    };
    Interp.unit = (a, b) => {
        const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
        const ma = reg.exec(a);
        const mb = reg.exec(b);
        const pb = mb ? mb[1] : '';
        const aa = ma ? +ma[1] : 0;
        const bb = mb ? +mb[1] : 0;
        const index = pb.indexOf('.');
        const precision = index > 0 ? pb[1].length - index - 1 : 0;
        const d = bb - aa;
        const u = ma ? ma[2] : '';
        return (t) => {
            return (aa + d * t).toFixed(precision) + u;
        };
    };
    Interp.color = (a, b) => {
        const ca = parseInt(a.slice(1), 16);
        const cb = parseInt(b.slice(1), 16);
        const ra = ca & 0x0000ff;
        const rd = (cb & 0x0000ff) - ra;
        const ga = ca & 0x00ff00;
        const gd = (cb & 0x00ff00) - ga;
        const ba = ca & 0xff0000;
        const bd = (cb & 0xff0000) - ba;
        return (t) => {
            const r = (ra + rd * t) & 0x000000ff;
            const g = (ga + gd * t) & 0x0000ff00;
            const b = (ba + bd * t) & 0x00ff0000;
            return `#${((1 << 24) | r | g | b).toString(16).slice(1)}`;
        };
    };
})(Interp || (Interp = {}));

const cssModules = [];
function ensure(name, content) {
    const cssModule = cssModules.find((m) => m.name === name);
    if (cssModule) {
        cssModule.loadTimes += 1;
        if (cssModule.loadTimes > 1) {
            return;
        }
    }
    if (!Platform.isApplyingHMR()) {
        const styleElement = document.createElement('style');
        styleElement.setAttribute('type', 'text/css');
        styleElement.textContent = content;
        const head = document.querySelector('head');
        if (head) {
            head.insertBefore(styleElement, head.firstChild);
        }
        cssModules.push({
            name,
            loadTimes: 1,
            styleElement,
        });
    }
}
function clean(name) {
    const index = cssModules.findIndex((m) => m.name === name);
    if (index > -1) {
        const cssModule = cssModules[index];
        cssModule.loadTimes -= 1;
        if (cssModule.loadTimes > 0) {
            return;
        }
        let styleElement = cssModule.styleElement;
        if (styleElement && styleElement.parentNode) {
            styleElement.parentNode.removeChild(styleElement);
        }
        styleElement = null;
        cssModules.splice(index, 1);
    }
}

var Angle;
(function (Angle) {
    /**
     * Converts radian angle to degree angle.
     * @param rad The radians to convert.
     */
    function toDeg(rad) {
        return ((180 * rad) / Math.PI) % 360;
    }
    Angle.toDeg = toDeg;
    /**
     * Converts degree angle to radian angle.
     * @param deg The degree angle to convert.
     * @param over360
     */
    Angle.toRad = function (deg, over360 = false) {
        const d = over360 ? deg : deg % 360;
        return (d * Math.PI) / 180;
    };
    /**
     * Returns the angle in degrees and clamps its value between `0` and `360`.
     */
    function normalize(angle) {
        return (angle % 360) + (angle < 0 ? 360 : 0);
    }
    Angle.normalize = normalize;
})(Angle || (Angle = {}));

var GeometryUtil;
(function (GeometryUtil) {
    function round(num, precision = 0) {
        return Number.isInteger(num) ? num : +num.toFixed(precision);
    }
    GeometryUtil.round = round;
    function random(min, max) {
        let mmin;
        let mmax;
        if (max == null) {
            mmax = min == null ? 1 : min;
            mmin = 0;
        }
        else {
            mmax = max;
            mmin = min == null ? 0 : min;
        }
        if (mmax < mmin) {
            const temp = mmin;
            mmin = mmax;
            mmax = temp;
        }
        return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
    }
    GeometryUtil.random = random;
    function clamp(value, min, max) {
        if (Number.isNaN(value)) {
            return NaN;
        }
        if (Number.isNaN(min) || Number.isNaN(max)) {
            return 0;
        }
        return min < max
            ? value < min
                ? min
                : value > max
                    ? max
                    : value
            : value < max
                ? max
                : value > min
                    ? min
                    : value;
    }
    GeometryUtil.clamp = clamp;
    function snapToGrid(value, gridSize) {
        return gridSize * Math.round(value / gridSize);
    }
    GeometryUtil.snapToGrid = snapToGrid;
    function containsPoint(rect, point) {
        return (point != null &&
            rect != null &&
            point.x >= rect.x &&
            point.x <= rect.x + rect.width &&
            point.y >= rect.y &&
            point.y <= rect.y + rect.height);
    }
    GeometryUtil.containsPoint = containsPoint;
    function squaredLength(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        return dx * dx + dy * dy;
    }
    GeometryUtil.squaredLength = squaredLength;
})(GeometryUtil || (GeometryUtil = {}));

class Geometry {
    valueOf() {
        return this.toJSON();
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}

class Point extends Geometry {
    constructor(x, y) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
    }
    /**
     * Rounds the point to the given precision.
     */
    round(precision = 0) {
        this.x = GeometryUtil.round(this.x, precision);
        this.y = GeometryUtil.round(this.y, precision);
        return this;
    }
    add(x, y) {
        const p = Point.create(x, y);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    update(x, y) {
        const p = Point.create(x, y);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    translate(dx, dy) {
        const t = Point.create(dx, dy);
        this.x += t.x;
        this.y += t.y;
        return this;
    }
    /**
     * Rotate the point by `degree` around `center`.
     */
    rotate(degree, center) {
        const p = Point.rotate(this, degree, center);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    /**
     * Scale point by `sx` and `sy` around the given `origin`. If origin is
     * not specified, the point is scaled around `0, 0`.
     */
    scale(sx, sy, origin = new Point()) {
        const ref = Point.create(origin);
        this.x = ref.x + sx * (this.x - ref.x);
        this.y = ref.y + sy * (this.y - ref.y);
        return this;
    }
    /**
     * Chooses the point closest to this point from among `points`. If `points`
     * is an empty array, `null` is returned.
     */
    closest(points) {
        if (points.length === 1) {
            return Point.create(points[0]);
        }
        let ret = null;
        let min = Infinity;
        points.forEach((p) => {
            const dist = this.squaredDistance(p);
            if (dist < min) {
                ret = p;
                min = dist;
            }
        });
        return ret ? Point.create(ret) : null;
    }
    /**
     * Returns the distance between the point and another point `p`.
     */
    distance(p) {
        return Math.sqrt(this.squaredDistance(p));
    }
    /**
     * Returns the squared distance between the point and another point `p`.
     *
     * Useful for distance comparisons in which real distance is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredDistance(p) {
        const ref = Point.create(p);
        const dx = this.x - ref.x;
        const dy = this.y - ref.y;
        return dx * dx + dy * dy;
    }
    manhattanDistance(p) {
        const ref = Point.create(p);
        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
    }
    /**
     * Returns the magnitude of the point vector.
     *
     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
     */
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p` and
     * the x-axis.
     */
    theta(p = new Point()) {
        const ref = Point.create(p);
        const y = -(ref.y - this.y); // invert the y-axis.
        const x = ref.x - this.x;
        let rad = Math.atan2(y, x);
        // Correction for III. and IV. quadrant.
        if (rad < 0) {
            rad = 2 * Math.PI + rad;
        }
        return (180 * rad) / Math.PI;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p1` and
     * the vector from this point to `p2`.
     *
     * The ordering of points `p1` and `p2` is important.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from `p1` to `p2`) is clockwise, and a value between `180` and
     * `360` when the angle is counterclockwise.
     *
     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
     */
    angleBetween(p1, p2) {
        if (this.equals(p1) || this.equals(p2)) {
            return NaN;
        }
        let angle = this.theta(p2) - this.theta(p1);
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    /**
     * Returns the angle(in degrees) between the line from `(0,0)` and this point
     * and the line from `(0,0)` to `p`.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from this point to `p`) is clockwise, and a value between `180`
     * and `360` when the angle is counterclockwise. Returns `NaN` if called from
     * point `(0,0)` or if `p` is `(0,0)`.
     */
    vectorAngle(p) {
        const zero = new Point(0, 0);
        return zero.angleBetween(this, p);
    }
    /**
     * Converts rectangular to polar coordinates.
     */
    toPolar(origin) {
        this.update(Point.toPolar(this, origin));
        return this;
    }
    /**
     * Returns the change in angle(in degrees) that is the result of moving the
     * point from its previous position to its current position.
     *
     * More specifically, this function computes the angle between the line from
     * the ref point to the previous position of this point(i.e. current position
     * `-dx`, `-dy`) and the line from the `ref` point to the current position of
     * this point.
     *
     * The function returns a positive value between `0` and `180` when the angle
     * (in the direction from previous position of this point to its current
     * position) is clockwise, and a negative value between `0` and `-180` when
     * the angle is counterclockwise.
     *
     * The function returns `0` if the previous and current positions of this
     * point are the same (i.e. both `dx` and `dy` are `0`).
     */
    changeInAngle(dx, dy, ref = new Point()) {
        // Revert the translation and measure the change in angle around x-axis.
        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
    }
    /**
     * If the point lies outside the rectangle `rect`, adjust the point so that
     * it becomes the nearest point on the boundary of `rect`.
     */
    adhereToRect(rect) {
        if (!GeometryUtil.containsPoint(rect, this)) {
            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
        }
        return this;
    }
    /**
     * Returns the bearing(cardinal direction) between me and the given point.
     *
     * @see https://en.wikipedia.org/wiki/Cardinal_direction
     */
    bearing(p) {
        const ref = Point.create(p);
        const lat1 = Angle.toRad(this.y);
        const lat2 = Angle.toRad(ref.y);
        const lon1 = this.x;
        const lon2 = ref.x;
        const dLon = Angle.toRad(lon2 - lon1);
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const brng = Angle.toDeg(Math.atan2(y, x));
        const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
        let index = brng - 22.5;
        if (index < 0) {
            index += 360;
        }
        index = parseInt((index / 45), 10);
        return bearings[index];
    }
    /**
     * Returns the cross product of the vector from me to `p1` and the vector
     * from me to `p2`.
     *
     * The left-hand rule is used because the coordinate system is left-handed.
     */
    cross(p1, p2) {
        if (p1 != null && p2 != null) {
            const a = Point.create(p1);
            const b = Point.create(p2);
            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
        }
        return NaN;
    }
    /**
     * Returns the dot product of this point with given other point.
     */
    dot(p) {
        const ref = Point.create(p);
        return this.x * ref.x + this.y * ref.y;
    }
    diff(dx, dy) {
        if (typeof dx === 'number') {
            return new Point(this.x - dx, this.y - dy);
        }
        const p = Point.create(dx);
        return new Point(this.x - p.x, this.y - p.y);
    }
    /**
     * Returns an interpolation between me and point `p` for a parametert in
     * the closed interval `[0, 1]`.
     */
    lerp(p, t) {
        const ref = Point.create(p);
        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);
    }
    /**
     * Normalize the point vector, scale the line segment between `(0, 0)`
     * and the point in order for it to have the given length. If length is
     * not specified, it is considered to be `1`; in that case, a unit vector
     * is computed.
     */
    normalize(length = 1) {
        const scale = length / this.magnitude();
        return this.scale(scale, scale);
    }
    /**
     * Moves this point along the line starting from `ref` to this point by a
     * certain `distance`.
     */
    move(ref, distance) {
        const p = Point.create(ref);
        const rad = Angle.toRad(p.theta(this));
        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
    }
    /**
     * Returns a point that is the reflection of me with the center of inversion
     * in `ref` point.
     */
    reflection(ref) {
        return Point.create(ref).move(this, this.distance(ref));
    }
    snapToGrid(gx, gy) {
        this.x = GeometryUtil.snapToGrid(this.x, gx);
        this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy);
        return this;
    }
    equals(p) {
        const ref = Point.create(p);
        return ref != null && ref.x === this.x && ref.y === this.y;
    }
    clone() {
        return Point.clone(this);
    }
    /**
     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
     */
    toJSON() {
        return Point.toJSON(this);
    }
    serialize() {
        return `${this.x} ${this.y}`;
    }
}
(function (Point) {
    function isPoint(instance) {
        return instance != null && instance instanceof Point;
    }
    Point.isPoint = isPoint;
})(Point || (Point = {}));
(function (Point) {
    function isPointLike(p) {
        return (p != null &&
            typeof p === 'object' &&
            typeof p.x === 'number' &&
            typeof p.y === 'number');
    }
    Point.isPointLike = isPointLike;
    function isPointData(p) {
        return (p != null &&
            Array.isArray(p) &&
            p.length === 2 &&
            typeof p[0] === 'number' &&
            typeof p[1] === 'number');
    }
    Point.isPointData = isPointData;
})(Point || (Point = {}));
(function (Point) {
    function create(x, y) {
        if (x == null || typeof x === 'number') {
            return new Point(x, y);
        }
        return clone(x);
    }
    Point.create = create;
    function clone(p) {
        if (Point.isPoint(p)) {
            return new Point(p.x, p.y);
        }
        if (Array.isArray(p)) {
            return new Point(p[0], p[1]);
        }
        return new Point(p.x, p.y);
    }
    Point.clone = clone;
    function toJSON(p) {
        if (Point.isPoint(p)) {
            return { x: p.x, y: p.y };
        }
        if (Array.isArray(p)) {
            return { x: p[0], y: p[1] };
        }
        return { x: p.x, y: p.y };
    }
    Point.toJSON = toJSON;
    /**
     * Returns a new Point object from the given polar coordinates.
     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
     */
    function fromPolar(r, rad, origin = new Point()) {
        let x = Math.abs(r * Math.cos(rad));
        let y = Math.abs(r * Math.sin(rad));
        const org = clone(origin);
        const deg = Angle.normalize(Angle.toDeg(rad));
        if (deg < 90) {
            y = -y;
        }
        else if (deg < 180) {
            x = -x;
            y = -y;
        }
        else if (deg < 270) {
            x = -x;
        }
        return new Point(org.x + x, org.y + y);
    }
    Point.fromPolar = fromPolar;
    /**
     * Converts rectangular to polar coordinates.
     */
    function toPolar(point, origin = new Point()) {
        const p = clone(point);
        const o = clone(origin);
        const dx = p.x - o.x;
        const dy = p.y - o.y;
        return new Point(Math.sqrt(dx * dx + dy * dy), // r
        Angle.toRad(o.theta(p)));
    }
    Point.toPolar = toPolar;
    function equals(p1, p2) {
        if (p1 === p2) {
            return true;
        }
        if (p1 != null && p2 != null) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        return false;
    }
    Point.equals = equals;
    function equalPoints(p1, p2) {
        if ((p1 == null && p2 != null) ||
            (p1 != null && p2 == null) ||
            (p1 != null && p2 != null && p1.length !== p2.length)) {
            return false;
        }
        if (p1 != null && p2 != null) {
            for (let i = 0, ii = p1.length; i < ii; i += 1) {
                if (!equals(p1[i], p2[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    Point.equalPoints = equalPoints;
    /**
     * Returns a point with random coordinates that fall within the range
     * `[x1, x2]` and `[y1, y2]`.
     */
    function random(x1, x2, y1, y2) {
        return new Point(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2));
    }
    Point.random = random;
    function rotate(point, angle, center) {
        const rad = Angle.toRad(Angle.normalize(-angle));
        const sin = Math.sin(rad);
        const cos = Math.cos(rad);
        return rotateEx(point, cos, sin, center);
    }
    Point.rotate = rotate;
    function rotateEx(point, cos, sin, center = new Point()) {
        const source = clone(point);
        const origin = clone(center);
        const dx = source.x - origin.x;
        const dy = source.y - origin.y;
        const x1 = dx * cos - dy * sin;
        const y1 = dy * cos + dx * sin;
        return new Point(x1 + origin.x, y1 + origin.y);
    }
    Point.rotateEx = rotateEx;
})(Point || (Point = {}));

class Rectangle extends Geometry {
    get left() {
        return this.x;
    }
    get top() {
        return this.y;
    }
    get right() {
        return this.x + this.width;
    }
    get bottom() {
        return this.y + this.height;
    }
    get origin() {
        return new Point(this.x, this.y);
    }
    get topLeft() {
        return new Point(this.x, this.y);
    }
    get topCenter() {
        return new Point(this.x + this.width / 2, this.y);
    }
    get topRight() {
        return new Point(this.x + this.width, this.y);
    }
    get center() {
        return new Point(this.x + this.width / 2, this.y + this.height / 2);
    }
    get bottomLeft() {
        return new Point(this.x, this.y + this.height);
    }
    get bottomCenter() {
        return new Point(this.x + this.width / 2, this.y + this.height);
    }
    get bottomRight() {
        return new Point(this.x + this.width, this.y + this.height);
    }
    get corner() {
        return new Point(this.x + this.width, this.y + this.height);
    }
    get rightMiddle() {
        return new Point(this.x + this.width, this.y + this.height / 2);
    }
    get leftMiddle() {
        return new Point(this.x, this.y + this.height / 2);
    }
    get topLine() {
        return new Line(this.topLeft, this.topRight);
    }
    get rightLine() {
        return new Line(this.topRight, this.bottomRight);
    }
    get bottomLine() {
        return new Line(this.bottomLeft, this.bottomRight);
    }
    get leftLine() {
        return new Line(this.topLeft, this.bottomLeft);
    }
    constructor(x, y, width, height) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.width = width == null ? 0 : width;
        this.height = height == null ? 0 : height;
    }
    getOrigin() {
        return this.origin;
    }
    getTopLeft() {
        return this.topLeft;
    }
    getTopCenter() {
        return this.topCenter;
    }
    getTopRight() {
        return this.topRight;
    }
    getCenter() {
        return this.center;
    }
    getCenterX() {
        return this.x + this.width / 2;
    }
    getCenterY() {
        return this.y + this.height / 2;
    }
    getBottomLeft() {
        return this.bottomLeft;
    }
    getBottomCenter() {
        return this.bottomCenter;
    }
    getBottomRight() {
        return this.bottomRight;
    }
    getCorner() {
        return this.corner;
    }
    getRightMiddle() {
        return this.rightMiddle;
    }
    getLeftMiddle() {
        return this.leftMiddle;
    }
    getTopLine() {
        return this.topLine;
    }
    getRightLine() {
        return this.rightLine;
    }
    getBottomLine() {
        return this.bottomLine;
    }
    getLeftLine() {
        return this.leftLine;
    }
    /**
     * Returns a rectangle that is the bounding box of the rectangle.
     *
     * If `angle` is specified, the bounding box calculation will take into
     * account the rotation of the rectangle by angle degrees around its center.
     */
    bbox(angle) {
        if (!angle) {
            return this.clone();
        }
        const rad = Angle.toRad(angle);
        const st = Math.abs(Math.sin(rad));
        const ct = Math.abs(Math.cos(rad));
        const w = this.width * ct + this.height * st;
        const h = this.width * st + this.height * ct;
        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
    }
    round(precision = 0) {
        this.x = GeometryUtil.round(this.x, precision);
        this.y = GeometryUtil.round(this.y, precision);
        this.width = GeometryUtil.round(this.width, precision);
        this.height = GeometryUtil.round(this.height, precision);
        return this;
    }
    add(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        const minX = Math.min(this.x, rect.x);
        const minY = Math.min(this.y, rect.y);
        const maxX = Math.max(this.x + this.width, rect.x + rect.width);
        const maxY = Math.max(this.y + this.height, rect.y + rect.height);
        this.x = minX;
        this.y = minY;
        this.width = maxX - minX;
        this.height = maxY - minY;
        return this;
    }
    update(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        this.x = rect.x;
        this.y = rect.y;
        this.width = rect.width;
        this.height = rect.height;
        return this;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.x -= w;
        this.y -= h;
        this.width += 2 * w;
        this.height += 2 * h;
        return this;
    }
    snapToGrid(gx, gy) {
        const origin = this.origin.snapToGrid(gx, gy);
        const corner = this.corner.snapToGrid(gx, gy);
        this.x = origin.x;
        this.y = origin.y;
        this.width = corner.x - origin.x;
        this.height = corner.y - origin.y;
        return this;
    }
    translate(tx, ty) {
        const p = Point.create(tx, ty);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    scale(sx, sy, origin = new Point()) {
        const pos = this.origin.scale(sx, sy, origin);
        this.x = pos.x;
        this.y = pos.y;
        this.width *= sx;
        this.height *= sy;
        return this;
    }
    rotate(degree, center = this.getCenter()) {
        if (degree !== 0) {
            const rad = Angle.toRad(degree);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            let p1 = this.getOrigin();
            let p2 = this.getTopRight();
            let p3 = this.getBottomRight();
            let p4 = this.getBottomLeft();
            p1 = Point.rotateEx(p1, cos, sin, center);
            p2 = Point.rotateEx(p2, cos, sin, center);
            p3 = Point.rotateEx(p3, cos, sin, center);
            p4 = Point.rotateEx(p4, cos, sin, center);
            const rect = new Rectangle(p1.x, p1.y, 0, 0);
            rect.add(p2.x, p2.y, 0, 0);
            rect.add(p3.x, p3.y, 0, 0);
            rect.add(p4.x, p4.y, 0, 0);
            this.update(rect);
        }
        return this;
    }
    rotate90() {
        const t = (this.width - this.height) / 2;
        this.x += t;
        this.y -= t;
        const tmp = this.width;
        this.width = this.height;
        this.height = tmp;
        return this;
    }
    /**
     * Translates the rectangle by `rect.x` and `rect.y` and expand it by
     * `rect.width` and `rect.height`.
     */
    moveAndExpand(rect) {
        const ref = Rectangle.clone(rect);
        this.x += ref.x || 0;
        this.y += ref.y || 0;
        this.width += ref.width || 0;
        this.height += ref.height || 0;
        return this;
    }
    /**
     * Returns an object where `sx` and `sy` give the maximum scaling that can be
     * applied to the rectangle so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxScaleToFit(limit, origin = this.center) {
        const rect = Rectangle.clone(limit);
        const ox = origin.x;
        const oy = origin.y;
        // Find the maximal possible scale for all corners, so when the scale
        // is applied the point is still inside the rectangle.
        let sx1 = Infinity;
        let sx2 = Infinity;
        let sx3 = Infinity;
        let sx4 = Infinity;
        let sy1 = Infinity;
        let sy2 = Infinity;
        let sy3 = Infinity;
        let sy4 = Infinity;
        // Top Left
        const p1 = rect.topLeft;
        if (p1.x < ox) {
            sx1 = (this.x - ox) / (p1.x - ox);
        }
        if (p1.y < oy) {
            sy1 = (this.y - oy) / (p1.y - oy);
        }
        // Bottom Right
        const p2 = rect.bottomRight;
        if (p2.x > ox) {
            sx2 = (this.x + this.width - ox) / (p2.x - ox);
        }
        if (p2.y > oy) {
            sy2 = (this.y + this.height - oy) / (p2.y - oy);
        }
        // Top Right
        const p3 = rect.topRight;
        if (p3.x > ox) {
            sx3 = (this.x + this.width - ox) / (p3.x - ox);
        }
        if (p3.y < oy) {
            sy3 = (this.y - oy) / (p3.y - oy);
        }
        // Bottom Left
        const p4 = rect.bottomLeft;
        if (p4.x < ox) {
            sx4 = (this.x - ox) / (p4.x - ox);
        }
        if (p4.y > oy) {
            sy4 = (this.y + this.height - oy) / (p4.y - oy);
        }
        return {
            sx: Math.min(sx1, sx2, sx3, sx4),
            sy: Math.min(sy1, sy2, sy3, sy4),
        };
    }
    /**
     * Returns a number that specifies the maximum scaling that can be applied to
     * the rectangle along both axes so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxUniformScaleToFit(limit, origin = this.center) {
        const scale = this.getMaxScaleToFit(limit, origin);
        return Math.min(scale.sx, scale.sy);
    }
    containsPoint(x, y) {
        return GeometryUtil.containsPoint(this, Point.create(x, y));
    }
    containsRect(x, y, width, height) {
        const b = Rectangle.create(x, y, width, height);
        const x1 = this.x;
        const y1 = this.y;
        const w1 = this.width;
        const h1 = this.height;
        const x2 = b.x;
        const y2 = b.y;
        const w2 = b.width;
        const h2 = b.height;
        // one of the dimensions is 0
        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
            return false;
        }
        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
    }
    /**
     * Returns an array of the intersection points of the rectangle and the line.
     * Return `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const rectLines = [
            this.topLine,
            this.rightLine,
            this.bottomLine,
            this.leftLine,
        ];
        const points = [];
        const dedupeArr = [];
        rectLines.forEach((l) => {
            const p = line.intersectsWithLine(l);
            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
                points.push(p);
                dedupeArr.push(p.toString());
            }
        });
        return points.length > 0 ? points : null;
    }
    /**
     * Returns the point on the boundary of the rectangle that is the intersection
     * of the rectangle with a line starting in the center the rectangle ending in
     * the point `p`.
     *
     * If `angle` is specified, the intersection will take into account the
     * rotation of the rectangle by `angle` degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle) {
        const ref = Point.clone(p);
        const center = this.center;
        let result = null;
        if (angle != null && angle !== 0) {
            ref.rotate(angle, center);
        }
        const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
        const connector = new Line(center, ref);
        for (let i = sides.length - 1; i >= 0; i -= 1) {
            const intersection = sides[i].intersectsWithLine(connector);
            if (intersection !== null) {
                result = intersection;
                break;
            }
        }
        if (result && angle != null && angle !== 0) {
            result.rotate(-angle, center);
        }
        return result;
    }
    intersectsWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        // no intersection
        if (!this.isIntersectWithRect(ref)) {
            return null;
        }
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const xx = Math.max(myOrigin.x, rOrigin.x);
        const yy = Math.max(myOrigin.y, rOrigin.y);
        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
    }
    isIntersectWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        if (rCorner.x <= myOrigin.x ||
            rCorner.y <= myOrigin.y ||
            rOrigin.x >= myCorner.x ||
            rOrigin.y >= myCorner.y) {
            return false;
        }
        return true;
    }
    /**
     * Normalize the rectangle, i.e. make it so that it has non-negative
     * width and height. If width is less than `0`, the function swaps left and
     * right corners and if height is less than `0`, the top and bottom corners
     * are swapped.
     */
    normalize() {
        let newx = this.x;
        let newy = this.y;
        let newwidth = this.width;
        let newheight = this.height;
        if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width;
        }
        if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height;
        }
        this.x = newx;
        this.y = newy;
        this.width = newwidth;
        this.height = newheight;
        return this;
    }
    /**
     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
     */
    union(rect) {
        const ref = Rectangle.clone(rect);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const originX = Math.min(myOrigin.x, rOrigin.x);
        const originY = Math.min(myOrigin.y, rOrigin.y);
        const cornerX = Math.max(myCorner.x, rCorner.x);
        const cornerY = Math.max(myCorner.y, rCorner.y);
        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
    }
    /**
     * Returns a string ("top", "left", "right" or "bottom") denoting the side of
     * the rectangle which is nearest to the point `p`.
     */
    getNearestSideToPoint(p) {
        const ref = Point.clone(p);
        const distLeft = ref.x - this.x;
        const distRight = this.x + this.width - ref.x;
        const distTop = ref.y - this.y;
        const distBottom = this.y + this.height - ref.y;
        let closest = distLeft;
        let side = 'left';
        if (distRight < closest) {
            closest = distRight;
            side = 'right';
        }
        if (distTop < closest) {
            closest = distTop;
            side = 'top';
        }
        if (distBottom < closest) {
            side = 'bottom';
        }
        return side;
    }
    /**
     * Returns a point on the boundary of the rectangle nearest to the point `p`.
     */
    getNearestPointToPoint(p) {
        const ref = Point.clone(p);
        if (this.containsPoint(ref)) {
            const side = this.getNearestSideToPoint(ref);
            if (side === 'left') {
                return new Point(this.x, ref.y);
            }
            if (side === 'top') {
                return new Point(ref.x, this.y);
            }
            if (side === 'right') {
                return new Point(this.x + this.width, ref.y);
            }
            if (side === 'bottom') {
                return new Point(ref.x, this.y + this.height);
            }
        }
        return ref.adhereToRect(this);
    }
    equals(rect) {
        return (rect != null &&
            rect.x === this.x &&
            rect.y === this.y &&
            rect.width === this.width &&
            rect.height === this.height);
    }
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    toJSON() {
        return { x: this.x, y: this.y, width: this.width, height: this.height };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.width} ${this.height}`;
    }
}
(function (Rectangle) {
    function isRectangle(instance) {
        return instance != null && instance instanceof Rectangle;
    }
    Rectangle.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function isRectangleLike(o) {
        return (o != null &&
            typeof o === 'object' &&
            typeof o.x === 'number' &&
            typeof o.y === 'number' &&
            typeof o.width === 'number' &&
            typeof o.height === 'number');
    }
    Rectangle.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function create(x, y, width, height) {
        if (x == null || typeof x === 'number') {
            return new Rectangle(x, y, width, height);
        }
        return clone(x);
    }
    Rectangle.create = create;
    function clone(rect) {
        if (Rectangle.isRectangle(rect)) {
            return rect.clone();
        }
        if (Array.isArray(rect)) {
            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
        }
        return new Rectangle(rect.x, rect.y, rect.width, rect.height);
    }
    Rectangle.clone = clone;
    /**
     * Returns a new rectangle from the given ellipse.
     */
    function fromEllipse(ellipse) {
        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
    }
    Rectangle.fromEllipse = fromEllipse;
    function fromSize(size) {
        return new Rectangle(0, 0, size.width, size.height);
    }
    Rectangle.fromSize = fromSize;
    function fromPositionAndSize(pos, size) {
        return new Rectangle(pos.x, pos.y, size.width, size.height);
    }
    Rectangle.fromPositionAndSize = fromPositionAndSize;
})(Rectangle || (Rectangle = {}));

class Line extends Geometry {
    get center() {
        return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
    }
    constructor(x1, y1, x2, y2) {
        super();
        if (typeof x1 === 'number' && typeof y1 === 'number') {
            this.start = new Point(x1, y1);
            this.end = new Point(x2, y2);
        }
        else {
            this.start = Point.create(x1);
            this.end = Point.create(y1);
        }
    }
    getCenter() {
        return this.center;
    }
    /**
     * Rounds the line to the given `precision`.
     */
    round(precision = 0) {
        this.start.round(precision);
        this.end.round(precision);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    /**
     * Rotate the line by `angle` around `origin`.
     */
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    /**
     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
     * specified, the line is scaled around `0,0`.
     */
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    /**
     * Returns the length of the line.
     */
    length() {
        return Math.sqrt(this.squaredLength());
    }
    /**
     * Useful for distance comparisons in which real length is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredLength() {
        const dx = this.start.x - this.end.x;
        const dy = this.start.y - this.end.y;
        return dx * dx + dy * dy;
    }
    /**
     * Scale the line so that it has the requested length. The start point of
     * the line is preserved.
     */
    setLength(length) {
        const total = this.length();
        if (!total) {
            return this;
        }
        const scale = length / total;
        return this.scale(scale, scale, this.start);
    }
    parallel(distance) {
        const line = this.clone();
        if (!line.isDifferentiable()) {
            return line;
        }
        const { start, end } = line;
        const eRef = start.clone().rotate(270, end);
        const sRef = end.clone().rotate(90, start);
        start.move(sRef, distance);
        end.move(eRef, distance);
        return line;
    }
    /**
     * Returns the vector of the line with length equal to length of the line.
     */
    vector() {
        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
    }
    /**
     * Returns the angle of incline of the line.
     *
     * The function returns `NaN` if the start and end endpoints of the line
     * both lie at the same coordinates(it is impossible to determine the angle
     * of incline of a line that appears to be a point). The
     * `line.isDifferentiable()` function may be used in advance to determine
     * whether the angle of incline can be computed for a given line.
     */
    angle() {
        const ref = new Point(this.start.x + 1, this.start.y);
        return this.start.angleBetween(this.end, ref);
    }
    /**
     * Returns a rectangle that is the bounding box of the line.
     */
    bbox() {
        const left = Math.min(this.start.x, this.end.x);
        const top = Math.min(this.start.y, this.end.y);
        const right = Math.max(this.start.x, this.end.x);
        const bottom = Math.max(this.start.y, this.end.y);
        return new Rectangle(left, top, right - left, bottom - top);
    }
    /**
     * Returns the bearing (cardinal direction) of the line.
     *
     * The return value is one of the following strings:
     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
     *
     * The function returns 'N' if the two endpoints of the line are coincident.
     */
    bearing() {
        return this.start.bearing(this.end);
    }
    /**
     * Returns the point on the line that lies closest to point `p`.
     */
    closestPoint(p) {
        return this.pointAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the length of the line up to the point that lies closest to point `p`.
     */
    closestPointLength(p) {
        return this.closestPointNormalizedLength(p) * this.length();
    }
    /**
     * Returns a line that is tangent to the line at the point that lies closest
     * to point `p`.
     */
    closestPointTangent(p) {
        return this.tangentAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the normalized length (distance from the start of the line / total
     * line length) of the line up to the point that lies closest to point.
     */
    closestPointNormalizedLength(p) {
        const product = this.vector().dot(new Line(this.start, p).vector());
        const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
        // normalized returns `NaN` if this line has zero length
        if (Number.isNaN(normalized)) {
            return 0;
        }
        return normalized;
    }
    /**
     * Returns a point on the line that lies `rate` (normalized length) away from
     * the beginning of the line.
     */
    pointAt(ratio) {
        const start = this.start;
        const end = this.end;
        if (ratio <= 0) {
            return start.clone();
        }
        if (ratio >= 1) {
            return end.clone();
        }
        return start.lerp(end, ratio);
    }
    /**
     * Returns a point on the line that lies length away from the beginning of
     * the line.
     */
    pointAtLength(length) {
        const start = this.start;
        const end = this.end;
        let fromStart = true;
        if (length < 0) {
            fromStart = false; // start calculation from end point
            length = -length; // eslint-disable-line
        }
        const total = this.length();
        if (length >= total) {
            return fromStart ? end.clone() : start.clone();
        }
        const rate = (fromStart ? length : total - length) / total;
        return this.pointAt(rate);
    }
    /**
     * Divides the line into two lines at the point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    divideAt(ratio) {
        const dividerPoint = this.pointAt(ratio);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Divides the line into two lines at the point that lies length away from
     * the beginning of the line.
     */
    divideAtLength(length) {
        const dividerPoint = this.pointAtLength(length);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
     */
    containsPoint(p) {
        const start = this.start;
        const end = this.end;
        // cross product of 0 indicates that this line and
        // the vector to `p` are collinear.
        if (start.cross(p, end) !== 0) {
            return false;
        }
        const length = this.length();
        if (new Line(start, p).length() > length) {
            return false;
        }
        if (new Line(p, end).length() > length) {
            return false;
        }
        return true;
    }
    intersect(shape, options) {
        const ret = shape.intersectsWithLine(this, options);
        if (ret) {
            return Array.isArray(ret) ? ret : [ret];
        }
        return null;
    }
    /**
     * Returns the intersection point of the line with another line. Returns
     * `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
        const pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);
        const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
        const deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);
        const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
        const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
        if (det === 0 || alpha * det < 0 || beta * det < 0) {
            return null;
        }
        if (det > 0) {
            if (alpha > det || beta > det) {
                return null;
            }
        }
        else if (alpha < det || beta < det) {
            return null;
        }
        return new Point(this.start.x + (alpha * pt1Dir.x) / det, this.start.y + (alpha * pt1Dir.y) / det);
    }
    /**
     * Returns `true` if a tangent line can be found for the line.
     *
     * Tangents cannot be found if both of the line endpoints are coincident
     * (the line appears to be a point).
     */
    isDifferentiable() {
        return !this.start.equals(this.end);
    }
    /**
     * Returns the perpendicular distance between the line and point. The
     * distance is positive if the point lies to the right of the line, negative
     * if the point lies to the left of the line, and `0` if the point lies on
     * the line.
     */
    pointOffset(p) {
        const ref = Point.clone(p);
        const start = this.start;
        const end = this.end;
        const determinant = (end.x - start.x) * (ref.y - start.y) -
            (end.y - start.y) * (ref.x - start.x);
        return determinant / this.length();
    }
    pointSquaredDistance(x, y) {
        const p = Point.create(x, y);
        return this.closestPoint(p).squaredDistance(p);
    }
    pointDistance(x, y) {
        const p = Point.create(x, y);
        return this.closestPoint(p).distance(p);
    }
    /**
     * Returns a line tangent to the line at point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    tangentAt(ratio) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAt(ratio);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    /**
     * Returns a line tangent to the line at point that lies `length` away from
     * the beginning of the line.
     */
    tangentAtLength(length) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAtLength(length);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    relativeCcw(x, y) {
        const ref = Point.create(x, y);
        let dx1 = ref.x - this.start.x;
        let dy1 = ref.y - this.start.y;
        const dx2 = this.end.x - this.start.x;
        const dy2 = this.end.y - this.start.y;
        let ccw = dx1 * dy2 - dy1 * dx2;
        if (ccw === 0) {
            ccw = dx1 * dx2 + dy1 * dy2;
            if (ccw > 0.0) {
                dx1 -= dx2;
                dy1 -= dy2;
                ccw = dx1 * dx2 + dy1 * dy2;
                if (ccw < 0.0) {
                    ccw = 0.0;
                }
            }
        }
        return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
    }
    /**
     * Return `true` if the line equals the other line.
     */
    equals(l) {
        return (l != null &&
            this.start.x === l.start.x &&
            this.start.y === l.start.y &&
            this.end.x === l.end.x &&
            this.end.y === l.end.y);
    }
    /**
     * Returns another line which is a clone of the line.
     */
    clone() {
        return new Line(this.start, this.end);
    }
    toJSON() {
        return { start: this.start.toJSON(), end: this.end.toJSON() };
    }
    serialize() {
        return [this.start.serialize(), this.end.serialize()].join(' ');
    }
}
(function (Line) {
    function isLine(instance) {
        return instance != null && instance instanceof Line;
    }
    Line.isLine = isLine;
})(Line || (Line = {}));

class Ellipse extends Geometry {
    get center() {
        return new Point(this.x, this.y);
    }
    constructor(x, y, a, b) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.a = a == null ? 0 : a;
        this.b = b == null ? 0 : b;
    }
    /**
     * Returns a rectangle that is the bounding box of the ellipse.
     */
    bbox() {
        return Rectangle.fromEllipse(this);
    }
    /**
     * Returns a point that is the center of the ellipse.
     */
    getCenter() {
        return this.center;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.a += 2 * w;
        this.b += 2 * h;
        return this;
    }
    normalizedDistance(x, y) {
        const ref = Point.create(x, y);
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        const a = this.a;
        const b = this.b;
        return (dx * dx) / (a * a) + (dy * dy) / (b * b);
    }
    containsPoint(x, y) {
        return this.normalizedDistance(x, y) <= 1;
    }
    /**
     * Returns an array of the intersection points of the ellipse and the line.
     * Returns `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const intersections = [];
        const rx = this.a;
        const ry = this.b;
        const a1 = line.start;
        const a2 = line.end;
        const dir = line.vector();
        const diff = a1.diff(new Point(this.x, this.y));
        const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
        const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));
        const a = dir.dot(mDir);
        const b = dir.dot(mDiff);
        const c = diff.dot(mDiff) - 1.0;
        const d = b * b - a * c;
        if (d < 0) {
            return null;
        }
        if (d > 0) {
            const root = Math.sqrt(d);
            const ta = (-b - root) / a;
            const tb = (-b + root) / a;
            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
                // outside
                return null;
            }
            if (ta >= 0 && ta <= 1) {
                intersections.push(a1.lerp(a2, ta));
            }
            if (tb >= 0 && tb <= 1) {
                intersections.push(a1.lerp(a2, tb));
            }
        }
        else {
            const t = -b / a;
            if (t >= 0 && t <= 1) {
                intersections.push(a1.lerp(a2, t));
            }
            else {
                // outside
                return null;
            }
        }
        return intersections;
    }
    /**
     * Returns the point on the boundary of the ellipse that is the
     * intersection of the ellipse with a line starting in the center
     * of the ellipse ending in the point `p`.
     *
     * If angle is specified, the intersection will take into account
     * the rotation of the ellipse by angle degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle = 0) {
        const ref = Point.clone(p);
        if (angle) {
            ref.rotate(angle, this.getCenter());
        }
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        let result;
        if (dx === 0) {
            result = this.bbox().getNearestPointToPoint(ref);
            if (angle) {
                return result.rotate(-angle, this.getCenter());
            }
            return result;
        }
        const m = dy / dx;
        const mSquared = m * m;
        const aSquared = this.a * this.a;
        const bSquared = this.b * this.b;
        let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
        x = dx < 0 ? -x : x;
        const y = m * x;
        result = new Point(this.x + x, this.y + y);
        if (angle) {
            return result.rotate(-angle, this.getCenter());
        }
        return result;
    }
    /**
     * Returns the angle between the x-axis and the tangent from a point. It is
     * valid for points lying on the ellipse boundary only.
     */
    tangentTheta(p) {
        const ref = Point.clone(p);
        const x0 = ref.x;
        const y0 = ref.y;
        const a = this.a;
        const b = this.b;
        const center = this.bbox().center;
        const cx = center.x;
        const cy = center.y;
        const refPointDelta = 30;
        const q1 = x0 > center.x + a / 2;
        const q3 = x0 < center.x - a / 2;
        let x;
        let y;
        if (q1 || q3) {
            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
            x =
                (a * a) / (x0 - cx) -
                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +
                    cx;
        }
        else {
            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
            y =
                (b * b) / (y0 - cy) -
                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +
                    cy;
        }
        return new Point(x, y).theta(ref);
    }
    scale(sx, sy) {
        this.a *= sx;
        this.b *= sy;
        return this;
    }
    rotate(angle, origin) {
        const rect = Rectangle.fromEllipse(this);
        rect.rotate(angle, origin);
        const ellipse = Ellipse.fromRect(rect);
        this.a = ellipse.a;
        this.b = ellipse.b;
        this.x = ellipse.x;
        this.y = ellipse.y;
        return this;
    }
    translate(dx, dy) {
        const p = Point.create(dx, dy);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    equals(ellipse) {
        return (ellipse != null &&
            ellipse.x === this.x &&
            ellipse.y === this.y &&
            ellipse.a === this.a &&
            ellipse.b === this.b);
    }
    clone() {
        return new Ellipse(this.x, this.y, this.a, this.b);
    }
    toJSON() {
        return { x: this.x, y: this.y, a: this.a, b: this.b };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.a} ${this.b}`;
    }
}
(function (Ellipse) {
    function isEllipse(instance) {
        return instance != null && instance instanceof Ellipse;
    }
    Ellipse.isEllipse = isEllipse;
})(Ellipse || (Ellipse = {}));
(function (Ellipse) {
    function create(x, y, a, b) {
        if (x == null || typeof x === 'number') {
            return new Ellipse(x, y, a, b);
        }
        return parse(x);
    }
    Ellipse.create = create;
    function parse(e) {
        if (Ellipse.isEllipse(e)) {
            return e.clone();
        }
        if (Array.isArray(e)) {
            return new Ellipse(e[0], e[1], e[2], e[3]);
        }
        return new Ellipse(e.x, e.y, e.a, e.b);
    }
    Ellipse.parse = parse;
    function fromRect(rect) {
        const center = rect.center;
        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
    }
    Ellipse.fromRect = fromRect;
})(Ellipse || (Ellipse = {}));

/* eslint-disable default-param-last */
const regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`); // eslint-disable-line prefer-regex-literals
function isValid(data) {
    if (typeof data !== 'string') {
        return false;
    }
    return regexSupportedData.test(data);
}
/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function draw(points, round, initialMove, close, exclude) {
    const data = [];
    const end = points[points.length - 1];
    const rounded = round != null && round > 0;
    const arcSize = round || 0;
    // Adds virtual waypoint in the center between start and end point
    if (close && rounded) {
        points = points.slice(); // eslint-disable-line
        const p0 = points[0];
        const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
        points.splice(0, 0, wp);
    }
    let pt = points[0];
    let i = 1;
    // Draws the line segments
    if (initialMove) {
        data.push('M', pt.x, pt.y);
    }
    else {
        data.push('L', pt.x, pt.y);
    }
    while (i < (close ? points.length : points.length - 1)) {
        let tmp = points[mod(i, points.length)];
        let dx = pt.x - tmp.x;
        let dy = pt.y - tmp.y;
        if (rounded &&
            (dx !== 0 || dy !== 0) &&
            (exclude == null || exclude.indexOf(i - 1) < 0)) {
            // Draws a line from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the last point
            let dist = Math.sqrt(dx * dx + dy * dy);
            const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x1 = tmp.x + nx1;
            const y1 = tmp.y + ny1;
            data.push('L', x1, y1);
            // Draws a curve from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the next point
            let next = points[mod(i + 1, points.length)];
            // Uses next non-overlapping point
            while (i < points.length - 2 &&
                Math.round(next.x - tmp.x) === 0 &&
                Math.round(next.y - tmp.y) === 0) {
                next = points[mod(i + 2, points.length)];
                i += 1;
            }
            dx = next.x - tmp.x;
            dy = next.y - tmp.y;
            dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x2 = tmp.x + nx2;
            const y2 = tmp.y + ny2;
            data.push('Q', tmp.x, tmp.y, x2, y2);
            tmp = new Point(x2, y2);
        }
        else {
            data.push('L', tmp.x, tmp.y);
        }
        pt = tmp;
        i += 1;
    }
    if (close) {
        data.push('Z');
    }
    else {
        data.push('L', end.x, end.y);
    }
    return data.map((v) => (typeof v === 'string' ? v : +v.toFixed(3))).join(' ');
}
function drawPoints(points, options = {}) {
    const pts = [];
    if (points && points.length) {
        points.forEach((p) => {
            if (Array.isArray(p)) {
                pts.push({ x: p[0], y: p[1] });
            }
            else {
                pts.push({ x: p.x, y: p.y });
            }
        });
    }
    return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
/**
 * Converts the given arc to a series of curves.
 */
function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
    if (r1 === 0 || r2 === 0) {
        return [];
    }
    x -= x0; // eslint-disable-line
    y -= y0; // eslint-disable-line
    r1 = Math.abs(r1); // eslint-disable-line
    r2 = Math.abs(r2); // eslint-disable-line
    const ctx = -x / 2;
    const cty = -y / 2;
    const cpsi = Math.cos((angle * Math.PI) / 180);
    const spsi = Math.sin((angle * Math.PI) / 180);
    const rxd = cpsi * ctx + spsi * cty;
    const ryd = -1 * spsi * ctx + cpsi * cty;
    const rxdd = rxd * rxd;
    const rydd = ryd * ryd;
    const r1x = r1 * r1;
    const r2y = r2 * r2;
    const lamda = rxdd / r1x + rydd / r2y;
    let sds;
    if (lamda > 1) {
        r1 = Math.sqrt(lamda) * r1; // eslint-disable-line
        r2 = Math.sqrt(lamda) * r2; // eslint-disable-line
        sds = 0;
    }
    else {
        let seif = 1;
        if (largeArcFlag === sweepFlag) {
            seif = -1;
        }
        sds =
            seif *
                Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
    }
    const txd = (sds * r1 * ryd) / r2;
    const tyd = (-1 * sds * r2 * rxd) / r1;
    const tx = cpsi * txd - spsi * tyd + x / 2;
    const ty = spsi * txd + cpsi * tyd + y / 2;
    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
    rad =
        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -
            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
    if (sweepFlag === 0 && dr > 0) {
        dr -= 2 * Math.PI;
    }
    else if (sweepFlag !== 0 && dr < 0) {
        dr += 2 * Math.PI;
    }
    const sse = (dr * 2) / Math.PI;
    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
    const segr = dr / seg;
    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);
    const cpsir1 = cpsi * r1;
    const cpsir2 = cpsi * r2;
    const spsir1 = spsi * r1;
    const spsir2 = spsi * r2;
    let mc = Math.cos(s1);
    let ms = Math.sin(s1);
    let x2 = -t * (cpsir1 * ms + spsir2 * mc);
    let y2 = -t * (spsir1 * ms - cpsir2 * mc);
    let x3 = 0;
    let y3 = 0;
    const result = [];
    for (let n = 0; n < seg; n += 1) {
        s1 += segr;
        mc = Math.cos(s1);
        ms = Math.sin(s1);
        x3 = cpsir1 * mc - spsir2 * ms + tx;
        y3 = spsir1 * mc + cpsir2 * ms + ty;
        const dx = -t * (cpsir1 * ms + spsir2 * mc);
        const dy = -t * (spsir1 * ms - cpsir2 * mc);
        // CurveTo updates x0, y0 so need to restore it
        const index = n * 6;
        result[index] = Number(x2 + x0);
        result[index + 1] = Number(y2 + y0);
        result[index + 2] = Number(x3 - dx + x0);
        result[index + 3] = Number(y3 - dy + y0);
        result[index + 4] = Number(x3 + x0);
        result[index + 5] = Number(y3 + y0);
        x2 = x3 + dx;
        y2 = y3 + dy;
    }
    return result.map((num) => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
    const data = [];
    const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
    if (points != null) {
        for (let i = 0, ii = points.length; i < ii; i += 6) {
            data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
        }
    }
    return data.join(' ');
}

/* eslint-disable no-constructor-return */
class Polyline extends Geometry {
    get start() {
        return this.points[0] || null;
    }
    get end() {
        return this.points[this.points.length - 1] || null;
    }
    constructor(points) {
        super();
        if (points != null) {
            if (typeof points === 'string') {
                return Polyline.parse(points);
            }
            this.points = points.map((p) => Point.create(p));
        }
        else {
            this.points = [];
        }
    }
    scale(sx, sy, origin = new Point()) {
        this.points.forEach((p) => p.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.points.forEach((p) => p.rotate(angle, origin));
        return this;
    }
    translate(dx, dy) {
        const t = Point.create(dx, dy);
        this.points.forEach((p) => p.translate(t.x, t.y));
        return this;
    }
    round(precision = 0) {
        this.points.forEach((p) => p.round(precision));
        return this;
    }
    bbox() {
        if (this.points.length === 0) {
            return new Rectangle();
        }
        let x1 = Infinity;
        let x2 = -Infinity;
        let y1 = Infinity;
        let y2 = -Infinity;
        const points = this.points;
        for (let i = 0, ii = points.length; i < ii; i += 1) {
            const point = points[i];
            const x = point.x;
            const y = point.y;
            if (x < x1)
                x1 = x;
            if (x > x2)
                x2 = x;
            if (y < y1)
                y1 = y;
            if (y > y2)
                y2 = y;
        }
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    }
    closestPoint(p) {
        const cpLength = this.closestPointLength(p);
        return this.pointAtLength(cpLength);
    }
    closestPointLength(p) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return 0;
        }
        let length = 0;
        let cpLength = 0;
        let minSqrDistance = Infinity;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const line = new Line(points[i], points[i + 1]);
            const lineLength = line.length();
            const cpNormalizedLength = line.closestPointNormalizedLength(p);
            const cp = line.pointAt(cpNormalizedLength);
            const sqrDistance = cp.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
                minSqrDistance = sqrDistance;
                cpLength = length + cpNormalizedLength * lineLength;
            }
            length += lineLength;
        }
        return cpLength;
    }
    closestPointNormalizedLength(p) {
        const length = this.length();
        if (length === 0) {
            return 0;
        }
        const cpLength = this.closestPointLength(p);
        return cpLength / length;
    }
    closestPointTangent(p) {
        const cpLength = this.closestPointLength(p);
        return this.tangentAtLength(cpLength);
    }
    containsPoint(p) {
        if (this.points.length === 0) {
            return false;
        }
        const ref = Point.clone(p);
        const x = ref.x;
        const y = ref.y;
        const points = this.points;
        const count = points.length;
        let startIndex = count - 1;
        let intersectionCount = 0;
        for (let endIndex = 0; endIndex < count; endIndex += 1) {
            const start = points[startIndex];
            const end = points[endIndex];
            if (ref.equals(start)) {
                return true;
            }
            const segment = new Line(start, end);
            if (segment.containsPoint(p)) {
                return true;
            }
            // do we have an intersection?
            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {
                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
                // (when `y === start.y === end.y`)
                // this conditional branch IS entered when `segment` touches `ray` at only one point
                // (e.g. when `y === start.y !== end.y`)
                // since this branch is entered again for the following segment, the two touches cancel out
                const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
                if (xDifference >= 0) {
                    // segment lies at least partially to the right of `p`
                    const rayEnd = new Point(x + xDifference, y); // right
                    const ray = new Line(p, rayEnd);
                    if (segment.intersectsWithLine(ray)) {
                        // an intersection was detected to the right of `p`
                        intersectionCount += 1;
                    }
                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
            }
            // move to check the next polyline segment
            startIndex = endIndex;
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return intersectionCount % 2 === 1;
    }
    intersectsWithLine(line) {
        const intersections = [];
        for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const int = line.intersectsWithLine(new Line(a, b));
            if (int) {
                intersections.push(int);
            }
        }
        return intersections.length > 0 ? intersections : null;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const line = new Line(a, b);
            if (line.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    length() {
        let len = 0;
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            len += a.distance(b);
        }
        return len;
    }
    pointAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        if (ratio <= 0) {
            return points[0].clone();
        }
        if (ratio >= 1) {
            return points[count - 1].clone();
        }
        const total = this.length();
        const length = total * ratio;
        return this.pointAtLength(length);
    }
    pointAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new Line(a, b);
            const d = a.distance(b);
            if (length <= tmp + d) {
                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
            }
            tmp += d;
        }
        const lastPoint = fromStart ? points[count - 1] : points[0];
        return lastPoint.clone();
    }
    tangentAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const total = this.length();
        const length = total * ratio;
        return this.tangentAtLength(length);
    }
    tangentAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let lastValidLine;
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new Line(a, b);
            const d = a.distance(b);
            if (l.isDifferentiable()) {
                // has a tangent line (line length is not 0)
                if (length <= tmp + d) {
                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
                }
                lastValidLine = l;
            }
            tmp += d;
        }
        if (lastValidLine) {
            const ratio = fromStart ? 1 : 0;
            return lastValidLine.tangentAt(ratio);
        }
        return null;
    }
    simplify(
    // TODO: Accept startIndex and endIndex to specify where to start and end simplification
    options = {}) {
        const points = this.points;
        // we need at least 3 points
        if (points.length < 3) {
            return this;
        }
        const threshold = options.threshold || 0;
        // start at the beginning of the polyline and go forward
        let currentIndex = 0;
        // we need at least one intermediate point (3 points) in every iteration
        // as soon as that stops being true, we know we reached the end of the polyline
        while (points[currentIndex + 2]) {
            const firstIndex = currentIndex;
            const middleIndex = currentIndex + 1;
            const lastIndex = currentIndex + 2;
            const firstPoint = points[firstIndex];
            const middlePoint = points[middleIndex];
            const lastPoint = points[lastIndex];
            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point
            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
            const closestPointDistance = closestPoint.distance(middlePoint);
            if (closestPointDistance <= threshold) {
                // middle point is close enough to the chord = simplify
                // 1) remove middle point:
                points.splice(middleIndex, 1);
                // 2) in next iteration, investigate the newly-created triplet of points
                //    - do not change `currentIndex`
                //    = (first point stays, point after removed point becomes middle point)
            }
            else {
                // middle point is far from the chord
                // 1) preserve middle point
                // 2) in next iteration, move `currentIndex` by one step:
                currentIndex += 1;
                //    = (point after first point becomes first point)
            }
        }
        // `points` array was modified in-place
        return this;
    }
    toHull() {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return new Polyline();
        }
        // Step 1: find the starting point -- point with
        // the lowest y (if equality, highest x).
        let startPoint = points[0];
        for (let i = 1; i < count; i += 1) {
            if (points[i].y < startPoint.y) {
                startPoint = points[i];
            }
            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
                startPoint = points[i];
            }
        }
        // Step 2: sort the list of points by angle between line
        // from start point to current point and the x-axis (theta).
        // Step 2a: create the point records = [point, originalIndex, angle]
        const sortedRecords = [];
        for (let i = 0; i < count; i += 1) {
            let angle = startPoint.theta(points[i]);
            if (angle === 0) {
                // Give highest angle to start point.
                // The start point will end up at end of sorted list.
                // The start point will end up at beginning of hull points list.
                angle = 360;
            }
            sortedRecords.push([points[i], i, angle]);
        }
        // Step 2b: sort the list in place
        sortedRecords.sort((record1, record2) => {
            let ret = record1[2] - record2[2];
            if (ret === 0) {
                ret = record2[1] - record1[1];
            }
            return ret;
        });
        // Step 2c: duplicate start record from the top of
        // the stack to the bottom of the stack.
        if (sortedRecords.length > 2) {
            const startPoint = sortedRecords[sortedRecords.length - 1];
            sortedRecords.unshift(startPoint);
        }
        // Step 3
        // ------
        // Step 3a: go through sorted points in order and find those with
        // right turns, and we want to get our results in clockwise order.
        // Dictionary of points with left turns - cannot be on the hull.
        const insidePoints = {};
        // Stack of records with right turns - hull point candidates.
        const hullRecords = [];
        const getKey = (record) => `${record[0].toString()}@${record[1]}`;
        while (sortedRecords.length !== 0) {
            const currentRecord = sortedRecords.pop();
            const currentPoint = currentRecord[0];
            // Check if point has already been discarded.
            if (insidePoints[getKey(currentRecord)]) {
                continue;
            }
            let correctTurnFound = false;
            while (!correctTurnFound) {
                if (hullRecords.length < 2) {
                    // Not enough points for comparison, just add current point.
                    hullRecords.push(currentRecord);
                    correctTurnFound = true;
                }
                else {
                    const lastHullRecord = hullRecords.pop();
                    const lastHullPoint = lastHullRecord[0];
                    const secondLastHullRecord = hullRecords.pop();
                    const secondLastHullPoint = secondLastHullRecord[0];
                    const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
                    if (crossProduct < 0) {
                        // Found a right turn.
                        hullRecords.push(secondLastHullRecord);
                        hullRecords.push(lastHullRecord);
                        hullRecords.push(currentRecord);
                        correctTurnFound = true;
                    }
                    else if (crossProduct === 0) {
                        // the three points are collinear
                        // three options:
                        // there may be a 180 or 0 degree angle at lastHullPoint
                        // or two of the three points are coincident
                        // we have to take rounding errors into account
                        const THRESHOLD = 1e-10;
                        const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
                        if (Math.abs(angleBetween - 180) < THRESHOLD) {
                            // rouding around 180 to 180
                            // if the cross product is 0 because the angle is 180 degrees
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (lastHullPoint.equals(currentPoint) ||
                            secondLastHullPoint.equals(lastHullPoint)) {
                            // if the cross product is 0 because two points are the same
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {
                            // rounding around 0 and 360 to 0
                            // if the cross product is 0 because the angle is 0 degrees
                            // remove last hull point from hull BUT do not discard it
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // put last hull point back into the sorted point records list
                            sortedRecords.push(lastHullRecord);
                            // we are switching the order of the 0deg and 180deg points
                            // correct turn not found
                        }
                    }
                    else {
                        // found a left turn
                        // discard last hull point (add to insidePoints)
                        // insidePoints.unshift(lastHullPoint);
                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                        // reenter second-to-last hull point (will be last at next iter of loop)
                        hullRecords.push(secondLastHullRecord);
                        // do not do anything with current point
                        // correct turn not found
                    }
                }
            }
        }
        // At this point, hullPointRecords contains the output points in clockwise order
        // the points start with lowest-y,highest-x startPoint, and end at the same point
        // Step 3b: remove duplicated startPointRecord from the end of the array
        if (hullRecords.length > 2) {
            hullRecords.pop();
        }
        // Step 4: find the lowest originalIndex record and put it at the beginning of hull
        let lowestHullIndex; // the lowest originalIndex on the hull
        let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
        for (let i = 0, n = hullRecords.length; i < n; i += 1) {
            const currentHullIndex = hullRecords[i][1];
            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
                lowestHullIndex = currentHullIndex;
                indexOfLowestHullIndexRecord = i;
            }
        }
        let hullPointRecordsReordered = [];
        if (indexOfLowestHullIndexRecord > 0) {
            const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
            const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
        }
        else {
            hullPointRecordsReordered = hullRecords;
        }
        const hullPoints = [];
        for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
            hullPoints.push(hullPointRecordsReordered[i][0]);
        }
        return new Polyline(hullPoints);
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        if (p.points.length !== this.points.length) {
            return false;
        }
        return p.points.every((a, i) => a.equals(this.points[i]));
    }
    clone() {
        return new Polyline(this.points.map((p) => p.clone()));
    }
    toJSON() {
        return this.points.map((p) => p.toJSON());
    }
    serialize() {
        return this.points.map((p) => `${p.serialize()}`).join(' ');
    }
}
(function (Polyline) {
    function isPolyline(instance) {
        return instance != null && instance instanceof Polyline;
    }
    Polyline.isPolyline = isPolyline;
})(Polyline || (Polyline = {}));
(function (Polyline) {
    function parse(svgString) {
        const str = svgString.trim();
        if (str === '') {
            return new Polyline();
        }
        const points = [];
        const coords = str.split(/\s*,\s*|\s+/);
        for (let i = 0, ii = coords.length; i < ii; i += 2) {
            points.push({ x: +coords[i], y: +coords[i + 1] });
        }
        return new Polyline(points);
    }
    Polyline.parse = parse;
})(Polyline || (Polyline = {}));

class Curve extends Geometry {
    constructor(start, controlPoint1, controlPoint2, end) {
        super();
        this.PRECISION = 3;
        this.start = Point.create(start);
        this.controlPoint1 = Point.create(controlPoint1);
        this.controlPoint2 = Point.create(controlPoint2);
        this.end = Point.create(end);
    }
    bbox() {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        const x0 = start.x;
        const y0 = start.y;
        const x1 = controlPoint1.x;
        const y1 = controlPoint1.y;
        const x2 = controlPoint2.x;
        const y2 = controlPoint2.y;
        const x3 = end.x;
        const y3 = end.y;
        const tvalues = []; // t values of local extremes
        const bounds = [[], []];
        let a;
        let b;
        let c;
        let t;
        let t1;
        let t2;
        let b2ac;
        let sqrtb2ac;
        for (let i = 0; i < 2; i += 1) {
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            }
            else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (t > 0 && t < 1)
                    tvalues.push(t);
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0)
                continue;
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (t1 > 0 && t1 < 1)
                tvalues.push(t1);
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (t2 > 0 && t2 < 1)
                tvalues.push(t2);
        }
        let x;
        let y;
        let mt;
        let j = tvalues.length;
        const jlen = j;
        while (j) {
            j -= 1;
            t = tvalues[j];
            mt = 1 - t;
            x =
                mt * mt * mt * x0 +
                    3 * mt * mt * t * x1 +
                    3 * mt * t * t * x2 +
                    t * t * t * x3;
            bounds[0][j] = x;
            y =
                mt * mt * mt * y0 +
                    3 * mt * mt * t * y1 +
                    3 * mt * t * t * y2 +
                    t * t * t * y3;
            bounds[1][j] = y;
        }
        tvalues[jlen] = 0;
        tvalues[jlen + 1] = 1;
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        tvalues.length = jlen + 2;
        bounds[0].length = jlen + 2;
        bounds[1].length = jlen + 2;
        const left = Math.min.apply(null, bounds[0]);
        const top = Math.min.apply(null, bounds[1]);
        const right = Math.max.apply(null, bounds[0]);
        const bottom = Math.max.apply(null, bounds[1]);
        return new Rectangle(left, top, right - left, bottom - top);
    }
    closestPoint(p, options = {}) {
        return this.pointAtT(this.closestPointT(p, options));
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        return this.lengthAtT(this.closestPointT(p, opts), opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (!cpLength) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT = 0;
        let investigatedSubdivisionEndT = 0;
        let distFromStart = 0;
        let distFromEnd = 0;
        let chordLength = 0;
        let minSumDist = null;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        subdivisions.forEach((division, i) => {
            const startDist = division.start.distance(p);
            const endDist = division.end.distance(p);
            const sumDist = startDist + endDist;
            if (minSumDist == null || sumDist < minSumDist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = i * piece;
                investigatedSubdivisionEndT = (i + 1) * piece;
                distFromStart = startDist;
                distFromEnd = endDist;
                minSumDist = sumDist;
                chordLength = division.endpointDistance();
            }
        });
        // Recursively divide investigated subdivision, until distance between
        // baselinePoint and closest path endpoint is within `10^(-precision)`,
        // then return the closest endpoint of that final subdivision.
        // eslint-disable-next-line
        while (true) {
            // check if we have reached at least one required observed precision
            // - calculated as: the difference in distances from point to start and end divided by the distance
            // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
            // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
            // - this criterion works well for points lying far away from the curve
            const startPrecisionRatio = distFromStart
                ? Math.abs(distFromStart - distFromEnd) / distFromStart
                : 0;
            const endPrecisionRatio = distFromEnd != null
                ? Math.abs(distFromStart - distFromEnd) / distFromEnd
                : 0;
            const hasRequiredPrecision = startPrecisionRatio < precisionRatio ||
                endPrecisionRatio < precisionRatio;
            // check if we have reached at least one required minimal distance
            // - calculated as: the subdivision chord length multiplied by precisionRatio
            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
            // - this is a backup criterion that works well for points lying "almost at" the curve
            const hasMiniStartDistance = distFromStart
                ? distFromStart < chordLength * precisionRatio
                : true;
            const hasMiniEndDistance = distFromEnd
                ? distFromEnd < chordLength * precisionRatio
                : true;
            const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
            if (hasRequiredPrecision || hasMiniDistance) {
                return distFromStart <= distFromEnd
                    ? investigatedSubdivisionStartT
                    : investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const startDist1 = divided[0].start.distance(p);
            const endDist1 = divided[0].end.distance(p);
            const sumDist1 = startDist1 + endDist1;
            const startDist2 = divided[1].start.distance(p);
            const endDist2 = divided[1].end.distance(p);
            const sumDist2 = startDist2 + endDist2;
            if (sumDist1 <= sumDist2) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                distFromStart = startDist1;
                distFromEnd = endDist1;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                distFromStart = startDist2;
                distFromEnd = endDist2;
            }
        }
    }
    closestPointTangent(p, options = {}) {
        return this.tangentAtT(this.closestPointT(p, options));
    }
    containsPoint(p, options = {}) {
        const polyline = this.toPolyline(options);
        return polyline.containsPoint(p);
    }
    divideAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.divideAtT(0);
        }
        if (ratio >= 1) {
            return this.divideAtT(1);
        }
        const t = this.tAt(ratio, options);
        return this.divideAtT(t);
    }
    divideAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.divideAtT(t);
    }
    divide(t) {
        return this.divideAtT(t);
    }
    divideAtT(t) {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        if (t <= 0) {
            return [
                new Curve(start, start, start, start),
                new Curve(start, controlPoint1, controlPoint2, end),
            ];
        }
        if (t >= 1) {
            return [
                new Curve(start, controlPoint1, controlPoint2, end),
                new Curve(end, end, end, end),
            ];
        }
        const dividerPoints = this.getSkeletonPoints(t);
        const startControl1 = dividerPoints.startControlPoint1;
        const startControl2 = dividerPoints.startControlPoint2;
        const divider = dividerPoints.divider;
        const dividerControl1 = dividerPoints.dividerControlPoint1;
        const dividerControl2 = dividerPoints.dividerControlPoint2;
        return [
            new Curve(start, startControl1, startControl2, divider),
            new Curve(divider, dividerControl1, dividerControl2, end),
        ];
    }
    endpointDistance() {
        return this.start.distance(this.end);
    }
    getSkeletonPoints(t) {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        // shortcuts for `t` values that are out of range
        if (t <= 0) {
            return {
                startControlPoint1: start.clone(),
                startControlPoint2: start.clone(),
                divider: start.clone(),
                dividerControlPoint1: control1.clone(),
                dividerControlPoint2: control2.clone(),
            };
        }
        if (t >= 1) {
            return {
                startControlPoint1: control1.clone(),
                startControlPoint2: control2.clone(),
                divider: end.clone(),
                dividerControlPoint1: end.clone(),
                dividerControlPoint2: end.clone(),
            };
        }
        const midpoint1 = new Line(start, control1).pointAt(t);
        const midpoint2 = new Line(control1, control2).pointAt(t);
        const midpoint3 = new Line(control2, end).pointAt(t);
        const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
        const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
        const divideLine = new Line(subControl1, subControl2).pointAt(t);
        return {
            startControlPoint1: midpoint1,
            startControlPoint2: subControl1,
            divider: divideLine,
            dividerControlPoint1: subControl2,
            dividerControlPoint2: midpoint3,
        };
    }
    getSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        let subdivisions = [
            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),
        ];
        if (precision === 0) {
            return subdivisions;
        }
        let previousLength = this.endpointDistance();
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // Recursively divide curve at `t = 0.5`, until the difference between
        // observed length at subsequent iterations is lower than precision.
        let iteration = 0;
        // eslint-disable-next-line
        while (true) {
            iteration += 1;
            const divisions = [];
            subdivisions.forEach((c) => {
                // dividing at t = 0.5 (not at middle length!)
                const divided = c.divide(0.5);
                divisions.push(divided[0], divided[1]);
            });
            // measure new length
            const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);
            // check if we have reached required observed precision
            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
            // not a problem for further iterations because cubic curves cannot have more than two local extrema
            // (i.e. cubic curves cannot intersect the baseline more than once)
            // therefore two subsequent iterations cannot produce sampling with equal length
            const ratio = length !== 0 ? (length - previousLength) / length : 0;
            if (iteration > 1 && ratio < precisionRatio) {
                return divisions;
            }
            subdivisions = divisions;
            previousLength = length;
        }
    }
    length(options = {}) {
        const divisions = this.getDivisions(options);
        return divisions.reduce((memo, c) => {
            return memo + c.endpointDistance();
        }, 0);
    }
    lengthAtT(t, options = {}) {
        if (t <= 0) {
            return 0;
        }
        const precision = options.precision === undefined ? this.PRECISION : options.precision;
        const subCurve = this.divide(t)[0];
        return subCurve.length({ precision });
    }
    pointAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const t = this.tAt(ratio, options);
        return this.pointAtT(t);
    }
    pointAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.pointAtT(t);
    }
    pointAtT(t) {
        if (t <= 0) {
            return this.start.clone();
        }
        if (t >= 1) {
            return this.end.clone();
        }
        return this.getSkeletonPoints(t).divider;
    }
    isDifferentiable() {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    tangentAt(ratio, options = {}) {
        if (!this.isDifferentiable())
            return null;
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        else if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const t = this.tAt(ratio, options);
        return this.tangentAtT(t);
    }
    tangentAtLength(length, options = {}) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const t = this.tAtLength(length, options);
        return this.tangentAtT(t);
    }
    tangentAtT(t) {
        if (!this.isDifferentiable()) {
            return null;
        }
        if (t < 0) {
            t = 0; // eslint-disable-line
        }
        if (t > 1) {
            t = 1; // eslint-disable-line
        }
        const skeletonPoints = this.getSkeletonPoints(t);
        const p1 = skeletonPoints.startControlPoint2;
        const p2 = skeletonPoints.dividerControlPoint1;
        const tangentStart = skeletonPoints.divider;
        const tangentLine = new Line(p1, p2);
        // move so that tangent line starts at the point requested
        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
        return tangentLine;
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getDivisions(options = {}) {
        if (options.subdivisions != null) {
            return options.subdivisions;
        }
        const precision = this.getPrecision(options);
        return this.getSubdivisions({ precision });
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        return { precision, subdivisions };
    }
    tAt(ratio, options = {}) {
        if (ratio <= 0) {
            return 0;
        }
        if (ratio >= 1) {
            return 1;
        }
        const opts = this.getOptions(options);
        const total = this.length(opts);
        const length = total * ratio;
        return this.tAtLength(length, opts);
    }
    tAtLength(length, options = {}) {
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const opts = { precision, subdivisions };
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT;
        let investigatedSubdivisionEndT;
        let baselinePointDistFromStart = 0;
        let baselinePointDistFromEnd = 0;
        let memo = 0;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const division = subdivisions[i];
            const dist = division.endpointDistance();
            if (length <= memo + dist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = index * piece;
                investigatedSubdivisionEndT = (index + 1) * piece;
                baselinePointDistFromStart = fromStart
                    ? length - memo
                    : dist + memo - length;
                baselinePointDistFromEnd = fromStart
                    ? dist + memo - length
                    : length - memo;
                break;
            }
            memo += dist;
        }
        if (investigatedSubdivision == null) {
            return fromStart ? 1 : 0;
        }
        // note that precision affects what length is recorded
        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1
        const total = this.length(opts);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // recursively divide investigated subdivision:
        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
        // then return the closest endpoint of that final subdivision
        // eslint-disable-next-line
        while (true) {
            let ratio;
            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionStartT;
            }
            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            let newBaselinePointDistFromStart;
            let newBaselinePointDistFromEnd;
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const baseline1Length = divided[0].endpointDistance();
            const baseline2Length = divided[1].endpointDistance();
            if (baselinePointDistFromStart <= baseline1Length) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                newBaselinePointDistFromStart = baselinePointDistFromStart;
                newBaselinePointDistFromEnd =
                    baseline1Length - newBaselinePointDistFromStart;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                newBaselinePointDistFromStart =
                    baselinePointDistFromStart - baseline1Length;
                newBaselinePointDistFromEnd =
                    baseline2Length - newBaselinePointDistFromStart;
            }
            baselinePointDistFromStart = newBaselinePointDistFromStart;
            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
        }
    }
    toPoints(options = {}) {
        const subdivisions = this.getDivisions(options);
        const points = [subdivisions[0].start.clone()];
        subdivisions.forEach((c) => points.push(c.end.clone()));
        return points;
    }
    toPolyline(options = {}) {
        return new Polyline(this.toPoints(options));
    }
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(c) {
        return (c != null &&
            this.start.equals(c.start) &&
            this.controlPoint1.equals(c.controlPoint1) &&
            this.controlPoint2.equals(c.controlPoint2) &&
            this.end.equals(c.end));
    }
    clone() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return [
            this.start.serialize(),
            this.controlPoint1.serialize(),
            this.controlPoint2.serialize(),
            this.end.serialize(),
        ].join(' ');
    }
}
(function (Curve) {
    function isCurve(instance) {
        return instance != null && instance instanceof Curve;
    }
    Curve.isCurve = isCurve;
})(Curve || (Curve = {}));
(function (Curve) {
    function getFirstControlPoints(rhs) {
        const n = rhs.length;
        const x = []; // `x` is a solution vector.
        const tmp = [];
        let b = 2.0;
        x[0] = rhs[0] / b;
        // Decomposition and forward substitution.
        for (let i = 1; i < n; i += 1) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for (let i = 1; i < n; i += 1) {
            // Backsubstitution.
            x[n - i - 1] -= tmp[n - i] * x[n - i];
        }
        return x;
    }
    function getCurveControlPoints(points) {
        const knots = points.map((p) => Point.clone(p));
        const firstControlPoints = [];
        const secondControlPoints = [];
        const n = knots.length - 1;
        // Special case: Bezier curve should be a straight line.
        if (n === 1) {
            // 3P1 = 2P0 + P3
            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            // P2 = 2P1  P0
            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints];
        }
        // Calculate first Bezier control points.
        // Right hand side vector.
        const rhs = [];
        // Set right hand side X values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
        }
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
        // Get first control points X-values.
        const x = getFirstControlPoints(rhs);
        // Set right hand side Y values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
        }
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
        // Get first control points Y-values.
        const y = getFirstControlPoints(rhs);
        // Fill output arrays.
        for (let i = 0; i < n; i += 1) {
            // First control point.
            firstControlPoints.push(new Point(x[i], y[i]));
            // Second control point.
            if (i < n - 1) {
                secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            }
            else {
                secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
            }
        }
        return [firstControlPoints, secondControlPoints];
    }
    function throughPoints(points) {
        if (points == null || (Array.isArray(points) && points.length < 2)) {
            throw new Error('At least 2 points are required');
        }
        const controlPoints = getCurveControlPoints(points);
        const curves = [];
        for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
            const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
            const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
        }
        return curves;
    }
    Curve.throughPoints = throughPoints;
})(Curve || (Curve = {}));

class Segment extends Geometry {
    constructor() {
        super(...arguments);
        this.isVisible = true;
        this.isSegment = true;
        this.isSubpathStart = false;
    }
    get end() {
        return this.endPoint;
    }
    get start() {
        if (this.previousSegment == null) {
            throw new Error('Missing previous segment. (This segment cannot be the ' +
                'first segment of a path, or segment has not yet been ' +
                'added to a path.)');
        }
        return this.previousSegment.end;
    }
    closestPointT(p, options) {
        if (this.closestPointNormalizedLength) {
            return this.closestPointNormalizedLength(p);
        }
        throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
    }
    // eslint-disable-next-line
    lengthAtT(t, options) {
        if (t <= 0) {
            return 0;
        }
        const length = this.length();
        if (t >= 1) {
            return length;
        }
        return length * t;
    }
    divideAtT(t) {
        if (this.divideAt) {
            return this.divideAt(t);
        }
        throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
    }
    pointAtT(t) {
        if (this.pointAt) {
            return this.pointAt(t);
        }
        throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
    }
    tangentAtT(t) {
        if (this.tangentAt) {
            return this.tangentAt(t);
        }
        throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
    }
}

class LineTo extends Segment {
    constructor(x, y) {
        super();
        if (Line.isLine(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = Point.create(x, y).round(2);
        }
    }
    get type() {
        return 'L';
    }
    get line() {
        return new Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (this.previousSegment == null) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    clone() {
        return new LineTo(this.end);
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (LineTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (Line.isLine(arg0)) {
            return new LineTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 1) {
                return new LineTo(arg0);
            }
            // poly-line segment
            return args.map((arg) => new LineTo(arg));
        }
        // coordinates provided
        if (len === 2) {
            return new LineTo(+args[0], +args[1]);
        }
        // poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            segments.push(new LineTo(x, y));
        }
        return segments;
    }
    LineTo.create = create;
})(LineTo || (LineTo = {}));

class Close extends Segment {
    get end() {
        if (!this.subpathStartSegment) {
            throw new Error('Missing subpath start segment. (This segment needs a subpath ' +
                'start segment (e.g. MoveTo), or segment has not yet been added' +
                ' to a path.)');
        }
        return this.subpathStartSegment.end;
    }
    get type() {
        return 'Z';
    }
    get line() {
        return new Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [
            // do not actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
            new LineTo(divided[1]),
        ];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [
            divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
            new LineTo(divided[1]),
        ];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment || !this.subpathStartSegment) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    scale() {
        return this;
    }
    rotate() {
        return this;
    }
    translate() {
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    clone() {
        return new Close();
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return this.type;
    }
}
(function (Close) {
    function create() {
        return new Close();
    }
    Close.create = create;
})(Close || (Close = {}));

class MoveTo extends Segment {
    constructor(x, y) {
        super();
        this.isVisible = false;
        this.isSubpathStart = true;
        if (Line.isLine(x) || Curve.isCurve(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = Point.create(x, y).round(2);
        }
    }
    get start() {
        throw new Error('Illegal access. Moveto segments should not need a start property.');
    }
    get type() {
        return 'M';
    }
    bbox() {
        return null;
    }
    closestPoint() {
        return this.end.clone();
    }
    closestPointLength() {
        return 0;
    }
    closestPointNormalizedLength() {
        return 0;
    }
    closestPointT() {
        return 1;
    }
    closestPointTangent() {
        return null;
    }
    length() {
        return 0;
    }
    lengthAtT() {
        return 0;
    }
    divideAt() {
        return [this.clone(), this.clone()];
    }
    divideAtLength() {
        return [this.clone(), this.clone()];
    }
    getSubdivisions() {
        return [];
    }
    pointAt() {
        return this.end.clone();
    }
    pointAtLength() {
        return this.end.clone();
    }
    pointAtT() {
        return this.end.clone();
    }
    tangentAt() {
        return null;
    }
    tangentAtLength() {
        return null;
    }
    tangentAtT() {
        return null;
    }
    isDifferentiable() {
        return false;
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    clone() {
        return new MoveTo(this.end);
    }
    equals(s) {
        return this.type === s.type && this.end.equals(s.end);
    }
    toJSON() {
        return {
            type: this.type,
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (MoveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (Line.isLine(arg0)) {
            return new MoveTo(arg0);
        }
        // curve provided
        if (Curve.isCurve(arg0)) {
            return new MoveTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 1) {
                return new MoveTo(arg0);
            }
            // this is a moveto-with-subsequent-poly-line segment
            const segments = [];
            // points come one by one
            for (let i = 0; i < len; i += 1) {
                if (i === 0) {
                    segments.push(new MoveTo(args[i]));
                }
                else {
                    segments.push(new LineTo(args[i]));
                }
            }
            return segments;
        }
        // coordinates provided
        if (len === 2) {
            return new MoveTo(+args[0], +args[1]);
        }
        // this is a moveto-with-subsequent-poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            if (i === 0) {
                segments.push(new MoveTo(x, y));
            }
            else {
                segments.push(new LineTo(x, y));
            }
        }
        return segments;
    }
    MoveTo.create = create;
})(MoveTo || (MoveTo = {}));

class CurveTo extends Segment {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
        super();
        if (Curve.isCurve(arg0)) {
            this.controlPoint1 = arg0.controlPoint1.clone().round(2);
            this.controlPoint2 = arg0.controlPoint2.clone().round(2);
            this.endPoint = arg0.end.clone().round(2);
        }
        else if (typeof arg0 === 'number') {
            this.controlPoint1 = new Point(arg0, arg1).round(2);
            this.controlPoint2 = new Point(arg2, arg3).round(2);
            this.endPoint = new Point(arg4, arg5).round(2);
        }
        else {
            this.controlPoint1 = Point.create(arg0).round(2);
            this.controlPoint2 = Point.create(arg1).round(2);
            this.endPoint = Point.create(arg2).round(2);
        }
    }
    get type() {
        return 'C';
    }
    get curve() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    bbox() {
        return this.curve.bbox();
    }
    closestPoint(p) {
        return this.curve.closestPoint(p);
    }
    closestPointLength(p) {
        return this.curve.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.curve.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.curve.closestPointTangent(p);
    }
    length() {
        return this.curve.length();
    }
    divideAt(ratio, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAt(ratio, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtLength(length, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAtLength(length, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtT(t) {
        const divided = this.curve.divideAtT(t);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.curve.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.curve.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.curve.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.curve.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment) {
            return false;
        }
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    scale(sx, sy, origin) {
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.start.equals(s.start) &&
            this.end.equals(s.end) &&
            this.controlPoint1.equals(s.controlPoint1) &&
            this.controlPoint2.equals(s.controlPoint2));
    }
    clone() {
        return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const c1 = this.controlPoint1;
        const c2 = this.controlPoint2;
        const end = this.end;
        return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
    }
}
(function (CurveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // curve provided
        if (Curve.isCurve(arg0)) {
            return new CurveTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 3) {
                return new CurveTo(args[0], args[1], args[2]);
            }
            // this is a poly-bezier segment
            const segments = [];
            for (let i = 0; i < len; i += 3) {
                segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));
            }
            return segments;
        }
        // coordinates provided
        if (len === 6) {
            return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
        }
        // this is a poly-bezier segment
        const segments = [];
        for (let i = 0; i < len; i += 6) {
            segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
        }
        return segments;
    }
    CurveTo.create = create;
})(CurveTo || (CurveTo = {}));

function rotate(x, y, rad) {
    return {
        x: x * Math.cos(rad) - y * Math.sin(rad),
        y: x * Math.sin(rad) + y * Math.cos(rad),
    };
}
function q2c(x1, y1, ax, ay, x2, y2) {
    const v13 = 1 / 3;
    const v23 = 2 / 3;
    return [
        v13 * x1 + v23 * ax,
        v13 * y1 + v23 * ay,
        v13 * x2 + v23 * ax,
        v13 * y2 + v23 * ay,
        x2,
        y2,
    ];
}
function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    const v120 = (Math.PI * 120) / 180;
    const rad = (Math.PI / 180) * (+angle || 0);
    let res = [];
    let xy;
    let f1;
    let f2;
    let cx;
    let cy;
    if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x; // eslint-disable-line
        y1 = xy.y; // eslint-disable-line
        xy = rotate(x2, y2, -rad);
        x2 = xy.x; // eslint-disable-line
        y2 = xy.y; // eslint-disable-line
        const x = (x1 - x2) / 2;
        const y = (y1 - y2) / 2;
        let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
        if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx; // eslint-disable-line
            ry = h * ry; // eslint-disable-line
        }
        const rx2 = rx * rx;
        const ry2 = ry * ry;
        const k = (largeArcFlag === sweepFlag ? -1 : 1) *
            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
        cx = (k * rx * y) / ry + (x1 + x2) / 2;
        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
        f1 = Math.asin((y1 - cy) / ry);
        f2 = Math.asin((y2 - cy) / ry);
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        if (f1 < 0) {
            f1 = Math.PI * 2 + f1;
        }
        if (f2 < 0) {
            f2 = Math.PI * 2 + f2;
        }
        if (sweepFlag && f1 > f2) {
            f1 -= Math.PI * 2;
        }
        if (!sweepFlag && f2 > f1) {
            f2 -= Math.PI * 2;
        }
    }
    else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    let df = f2 - f1;
    if (Math.abs(df) > v120) {
        const f2old = f2;
        const x2old = x2;
        const y2old = y2;
        f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2); // eslint-disable-line
        y2 = cy + ry * Math.sin(f2); // eslint-disable-line
        res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy,
        ]);
    }
    df = f2 - f1;
    const c1 = Math.cos(f1);
    const s1 = Math.sin(f1);
    const c2 = Math.cos(f2);
    const s2 = Math.sin(f2);
    const t = Math.tan(df / 4);
    const hx = (4 / 3) * (rx * t);
    const hy = (4 / 3) * (ry * t);
    const m1 = [x1, y1];
    const m2 = [x1 + hx * s1, y1 - hy * c1];
    const m3 = [x2 + hx * s2, y2 - hy * c2];
    const m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    {
        res = [m2, m3, m4].concat(res).join().split(',');
        const newres = [];
        const ii = res.length;
        for (let i = 0; i < ii; i += 1) {
            newres[i] =
                i % 2
                    ? rotate(+res[i - 1], +res[i], rad).y
                    : rotate(+res[i], +res[i + 1], rad).x;
        }
        return newres;
    }
}
function parse(pathData) {
    if (!pathData) {
        return null;
    }
    const spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
    // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29
    const segmentReg = new RegExp(`([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`, // eslint-disable-line
    'ig');
    // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*
    const commandParamReg = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`, 'ig');
    const paramsCount = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0,
    };
    const segmetns = [];
    pathData.replace(segmentReg, (input, cmd, args) => {
        const params = [];
        let command = cmd.toLowerCase();
        args.replace(commandParamReg, (a, b) => {
            if (b) {
                params.push(+b);
            }
            return a;
        });
        if (command === 'm' && params.length > 2) {
            segmetns.push([cmd, ...params.splice(0, 2)]);
            command = 'l';
            cmd = cmd === 'm' ? 'l' : 'L'; // eslint-disable-line
        }
        const count = paramsCount[command];
        while (params.length >= count) {
            segmetns.push([cmd, ...params.splice(0, count)]);
            if (!count) {
                break;
            }
        }
        return input;
    });
    return segmetns;
}
function abs(pathString) {
    const pathArray = parse(pathString);
    // if invalid string, return 'M 0 0'
    if (!pathArray || !pathArray.length) {
        return [['M', 0, 0]];
    }
    let x = 0;
    let y = 0;
    let mx = 0;
    let my = 0;
    const segments = [];
    for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
        const r = [];
        segments.push(r);
        const segment = pathArray[i];
        const command = segment[0];
        if (command !== command.toUpperCase()) {
            r[0] = command.toUpperCase();
            switch (r[0]) {
                case 'A':
                    r[1] = segment[1];
                    r[2] = segment[2];
                    r[3] = segment[3];
                    r[4] = segment[4];
                    r[5] = segment[5];
                    r[6] = +segment[6] + x;
                    r[7] = +segment[7] + y;
                    break;
                case 'V':
                    r[1] = +segment[1] + y;
                    break;
                case 'H':
                    r[1] = +segment[1] + x;
                    break;
                case 'M':
                    mx = +segment[1] + x;
                    my = +segment[2] + y;
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
                default:
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
            }
        }
        else {
            for (let j = 0, jj = segment.length; j < jj; j += 1) {
                r[j] = segment[j];
            }
        }
        switch (r[0]) {
            case 'Z':
                x = +mx;
                y = +my;
                break;
            case 'H':
                x = r[1];
                break;
            case 'V':
                y = r[1];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
        }
    }
    return segments;
}
function normalize$1(path) {
    const pathArray = abs(path);
    const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
    function processPath(path, d, pcom) {
        let nx;
        let ny;
        if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        if (!(path[0] in { T: 1, Q: 1 })) {
            d.qx = null;
            d.qy = null;
        }
        switch (path[0]) {
            case 'M':
                d.X = path[1];
                d.Y = path[2];
                break;
            case 'A':
                if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
                    // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
                    // "If either rx or ry is 0, then this arc is treated as a
                    // straight line segment (a "lineto") joining the endpoints."
                    return ['L', path[6], path[7]];
                }
                return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
            case 'S':
                if (pcom === 'C' || pcom === 'S') {
                    // In 'S' case we have to take into account, if the previous command is C/S.
                    nx = d.x * 2 - d.bx; // And reflect the previous
                    ny = d.y * 2 - d.by; // command's control point relative to the current point.
                }
                else {
                    // or some else or nothing
                    nx = d.x;
                    ny = d.y;
                }
                return ['C', nx, ny].concat(path.slice(1));
            case 'T':
                if (pcom === 'Q' || pcom === 'T') {
                    // In 'T' case we have to take into account, if the previous command is Q/T.
                    d.qx = d.x * 2 - d.qx; // And make a reflection similar
                    d.qy = d.y * 2 - d.qy; // to case 'S'.
                }
                else {
                    // or something else or nothing
                    d.qx = d.x;
                    d.qy = d.y;
                }
                return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
            case 'Q':
                d.qx = path[1];
                d.qy = path[2];
                return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
            case 'H':
                return ['L'].concat(path[1], d.y);
            case 'V':
                return ['L'].concat(d.x, path[1]);
        }
        return path;
    }
    function fixArc(pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            const pi = pp[i];
            while (pi.length) {
                // if created multiple 'C's, their original seg is saved
                commands[i] = 'A';
                i += 1; // eslint-disable-line
                pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = pathArray.length;
        }
    }
    const commands = []; // path commands of original path p
    let prevCommand = ''; // holder for previous path command of original path
    let ii = pathArray.length;
    for (let i = 0; i < ii; i += 1) {
        let command = ''; // temporary holder for original path command
        if (pathArray[i]) {
            command = pathArray[i][0]; // save current path command
        }
        if (command !== 'C') {
            // C is not saved yet, because it may be result of conversion
            commands[i] = command; // Save current path command
            if (i > 0) {
                prevCommand = commands[i - 1]; // Get previous path command pcom
            }
        }
        // Previous path command is inputted to processPath
        pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
        if (commands[i] !== 'A' && command === 'C') {
            commands[i] = 'C'; // 'A' is the only command
        }
        // which may produce multiple 'C's
        // so we have to make sure that 'C' is also 'C' in original path
        fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms
        const seg = pathArray[i];
        const seglen = seg.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    }
    // make sure normalized path data string starts with an M segment
    if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
        pathArray.unshift(['M', 0, 0]);
    }
    return pathArray;
}
/**
 * Converts provided SVG path data string into a normalized path data string.
 *
 * The normalization uses a restricted subset of path commands; all segments
 * are translated into lineto, curveto, moveto, and closepath segments.
 *
 * Relative path commands are changed into their absolute counterparts,
 * and chaining of coordinates is disallowed.
 *
 * The function will always return a valid path data string; if an input
 * string cannot be normalized, 'M 0 0' is returned.
 */
function normalizePathData(pathData) {
    return normalize$1(pathData)
        .map((segment) => segment.map((item) => typeof item === 'string' ? item : GeometryUtil.round(item, 2)))
        .join(',')
        .split(',')
        .join(' ');
}

let Path$1 = class Path extends Geometry {
    constructor(args) {
        super();
        this.PRECISION = 3;
        this.segments = [];
        if (Array.isArray(args)) {
            if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {
                let previousObj = null;
                const arr = args;
                arr.forEach((o, i) => {
                    if (i === 0) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (previousObj != null && !previousObj.end.equals(o.start)) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (Line.isLine(o)) {
                        this.appendSegment(Path.createSegment('L', o.end));
                    }
                    else if (Curve.isCurve(o)) {
                        this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
                    }
                    previousObj = o;
                });
            }
            else {
                const arr = args;
                arr.forEach((s) => {
                    if (s.isSegment) {
                        this.appendSegment(s);
                    }
                });
            }
        }
        else if (args != null) {
            if (Line.isLine(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('L', args.end));
            }
            else if (Curve.isCurve(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
            }
            else if (Polyline.isPolyline(args)) {
                if (args.points && args.points.length) {
                    args.points.forEach((point, index) => {
                        const segment = index === 0
                            ? Path.createSegment('M', point)
                            : Path.createSegment('L', point);
                        this.appendSegment(segment);
                    });
                }
            }
            else if (args.isSegment) {
                this.appendSegment(args);
            }
        }
    }
    get start() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.start;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    get end() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = count - 1; i >= 0; i -= 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.end;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    moveTo(...args) {
        return this.appendSegment(MoveTo.create.call(null, ...args));
    }
    lineTo(...args) {
        return this.appendSegment(LineTo.create.call(null, ...args));
    }
    curveTo(...args) {
        return this.appendSegment(CurveTo.create.call(null, ...args));
    }
    arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
        const start = this.end || new Point();
        const points = typeof endX === 'number'
            ? arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)
            : arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
        if (points != null) {
            for (let i = 0, ii = points.length; i < ii; i += 6) {
                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
            }
        }
        return this;
    }
    quadTo(x1, y1, x, y) {
        const start = this.end || new Point();
        const data = ['M', start.x, start.y];
        if (typeof x1 === 'number') {
            data.push('Q', x1, y1, x, y);
        }
        else {
            const p = y1;
            data.push(`Q`, x1.x, x1.y, p.x, p.y);
        }
        const path = Path.parse(data.join(' '));
        this.appendSegment(path.segments.slice(1));
        return this;
    }
    close() {
        return this.appendSegment(Close.create());
    }
    drawPoints(points, options = {}) {
        const raw = drawPoints(points, options);
        const sub = Path.parse(raw);
        if (sub && sub.segments) {
            this.appendSegment(sub.segments);
        }
    }
    bbox() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        let bbox;
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const segmentBBox = segment.bbox();
                if (segmentBBox != null) {
                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
                }
            }
        }
        if (bbox != null) {
            return bbox;
        }
        // if the path has only invisible elements, return end point of last segment
        const lastSegment = segments[count - 1];
        return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
    }
    appendSegment(seg) {
        const count = this.segments.length;
        let previousSegment = count !== 0 ? this.segments[count - 1] : null;
        let currentSegment;
        const nextSegment = null;
        if (Array.isArray(seg)) {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.push(currentSegment);
                previousSegment = currentSegment;
            }
        }
        else if (seg != null && seg.isSegment) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.push(currentSegment);
        }
        return this;
    }
    insertSegment(index, seg) {
        const count = this.segments.length;
        if (index < 0) {
            index = count + index + 1; // eslint-disable-line
        }
        if (index > count || index < 0) {
            throw new Error('Index out of range.');
        }
        let currentSegment;
        let previousSegment = null;
        let nextSegment = null;
        if (count !== 0) {
            if (index >= 1) {
                previousSegment = this.segments[index - 1];
                nextSegment = previousSegment.nextSegment;
            }
            else {
                previousSegment = null;
                nextSegment = this.segments[0];
            }
        }
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(index, 0, currentSegment);
        }
        else {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
            }
        }
        return this;
    }
    removeSegment(index) {
        const idx = this.fixIndex(index);
        const removedSegment = this.segments.splice(idx, 1)[0];
        const previousSegment = removedSegment.previousSegment;
        const nextSegment = removedSegment.nextSegment;
        // link the previous and next segments together (if present)
        if (previousSegment) {
            previousSegment.nextSegment = nextSegment;
        }
        if (nextSegment) {
            nextSegment.previousSegment = previousSegment;
        }
        if (removedSegment.isSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
        return removedSegment;
    }
    replaceSegment(index, seg) {
        const idx = this.fixIndex(index);
        let currentSegment;
        const replacedSegment = this.segments[idx];
        let previousSegment = replacedSegment.previousSegment;
        const nextSegment = replacedSegment.nextSegment;
        let updateSubpathStart = replacedSegment.isSubpathStart;
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(idx, 1, currentSegment);
            if (updateSubpathStart && currentSegment.isSubpathStart) {
                // already updated by `prepareSegment`
                updateSubpathStart = false;
            }
        }
        else {
            this.segments.splice(index, 1);
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
                if (updateSubpathStart && currentSegment.isSubpathStart) {
                    updateSubpathStart = false;
                }
            }
        }
        if (updateSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
    }
    getSegment(index) {
        const idx = this.fixIndex(index);
        return this.segments[idx];
    }
    fixIndex(index) {
        const length = this.segments.length;
        if (length === 0) {
            throw new Error('Path has no segments.');
        }
        let i = index;
        while (i < 0) {
            i = length + i;
        }
        if (i >= length || i < 0) {
            throw new Error('Index out of range.');
        }
        return i;
    }
    segmentAt(ratio, options = {}) {
        const index = this.segmentIndexAt(ratio, options);
        if (!index) {
            return null;
        }
        return this.getSegment(index);
    }
    segmentAtLength(length, options = {}) {
        const index = this.segmentIndexAtLength(length, options);
        if (!index)
            return null;
        return this.getSegment(index);
    }
    segmentIndexAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = GeometryUtil.clamp(ratio, 0, 1);
        const opt = this.getOptions(options);
        const len = this.length(opt);
        const length = len * rate;
        return this.segmentIndexAtLength(length, opt);
    }
    segmentIndexAtLength(length, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let lastVisibleIndex = null;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isVisible) {
                if (length <= memo + len) {
                    return index;
                }
                lastVisibleIndex = index;
            }
            memo += len;
        }
        // If length requested is higher than the length of the path, return
        // last visible segment index. If no visible segment, return null.
        return lastVisibleIndex;
    }
    getSegmentSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = [];
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segment.getSubdivisions({ precision });
            segmentSubdivisions.push(subdivisions);
        }
        return segmentSubdivisions;
    }
    updateSubpathStartSegment(segment) {
        let previous = segment.previousSegment;
        let current = segment;
        while (current && !current.isSubpathStart) {
            // assign previous segment's subpath start segment to this segment
            if (previous != null) {
                current.subpathStartSegment = previous.subpathStartSegment;
            }
            else {
                current.subpathStartSegment = null;
            }
            previous = current;
            current = current.nextSegment;
        }
    }
    prepareSegment(segment, previousSegment, nextSegment) {
        segment.previousSegment = previousSegment;
        segment.nextSegment = nextSegment;
        if (previousSegment != null) {
            previousSegment.nextSegment = segment;
        }
        if (nextSegment != null) {
            nextSegment.previousSegment = segment;
        }
        let updateSubpathStart = segment;
        if (segment.isSubpathStart) {
            // move to
            segment.subpathStartSegment = segment;
            updateSubpathStart = nextSegment;
        }
        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
        if (updateSubpathStart != null) {
            this.updateSubpathStartSegment(updateSubpathStart);
        }
        return segment;
    }
    closestPoint(p, options = {}) {
        const t = this.closestPointT(p, options);
        if (!t) {
            return null;
        }
        return this.pointAtT(t);
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        const t = this.closestPointT(p, opts);
        if (!t) {
            return 0;
        }
        return this.lengthAtT(t, opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (cpLength === 0) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointT;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isVisible) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointT) {
            return closestPointT;
        }
        return { segmentIndex: this.segments.length - 1, value: 1 };
    }
    closestPointTangent(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointTangent;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isDifferentiable()) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointTangent) {
            return closestPointTangent;
        }
        return null;
    }
    containsPoint(p, options = {}) {
        const polylines = this.toPolylines(options);
        if (!polylines) {
            return false;
        }
        let numIntersections = 0;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            if (polyline.containsPoint(p)) {
                numIntersections += 1;
            }
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return numIntersections % 2 === 1;
    }
    pointAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const opts = this.getOptions(options);
        const pathLength = this.length(opts);
        const length = pathLength * ratio;
        return this.pointAtLength(length, opts);
    }
    pointAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (length === 0) {
            return this.start.clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastVisibleSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const d = segment.length({
                precision,
                subdivisions,
            });
            if (segment.isVisible) {
                if (length <= memo + d) {
                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastVisibleSegment = segment;
            }
            memo += d;
        }
        // if length requested is higher than the length of the path,
        // return last visible segment endpoint
        if (lastVisibleSegment) {
            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
        }
        // if no visible segment, return last segment end point
        const lastSegment = this.segments[this.segments.length - 1];
        return lastSegment.end.clone();
    }
    pointAtT(t) {
        const segments = this.segments;
        const numSegments = segments.length;
        if (numSegments === 0)
            return null; // if segments is an empty array
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0)
            return segments[0].pointAtT(0);
        if (segmentIndex >= numSegments) {
            return segments[numSegments - 1].pointAtT(1);
        }
        const tValue = GeometryUtil.clamp(t.value, 0, 1);
        return segments[segmentIndex].pointAtT(tValue);
    }
    divideAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = GeometryUtil.clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.divideAtLength(length, opts);
    }
    divideAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let divided;
        let dividedSegmentIndex;
        let lastValidSegment;
        let lastValidSegmentIndex;
        let t;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.getSegment(index);
            const subdivisions = segmentSubdivisions[index];
            const opts = { precision, subdivisions };
            const len = segment.length(opts);
            if (segment.isDifferentiable()) {
                lastValidSegment = segment;
                lastValidSegmentIndex = index;
                if (length <= memo + len) {
                    dividedSegmentIndex = index;
                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
                    break;
                }
            }
            memo += len;
        }
        if (!lastValidSegment) {
            return null;
        }
        if (!divided) {
            dividedSegmentIndex = lastValidSegmentIndex;
            t = fromStart ? 1 : 0;
            divided = lastValidSegment.divideAtT(t);
        }
        // create a copy of this path and replace the identified segment with its two divided parts:
        const pathCopy = this.clone();
        const index = dividedSegmentIndex;
        pathCopy.replaceSegment(index, divided);
        const divisionStartIndex = index;
        let divisionMidIndex = index + 1;
        let divisionEndIndex = index + 2;
        // do not insert the part if it looks like a point
        if (!divided[0].isDifferentiable()) {
            pathCopy.removeSegment(divisionStartIndex);
            divisionMidIndex -= 1;
            divisionEndIndex -= 1;
        }
        // insert a Moveto segment to ensure secondPath will be valid:
        const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
        divisionEndIndex += 1;
        // do not insert the part if it looks like a point
        if (!divided[1].isDifferentiable()) {
            pathCopy.removeSegment(divisionEndIndex - 1);
            divisionEndIndex -= 1;
        }
        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:
        const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
        for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
            const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
            const segment = pathCopy.getSegment(i);
            if (segment.type === 'Z' &&
                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
                // pathCopy segment's subpathStartSegment is different from original segment's one
                // convert this Closepath segment to a Lineto and replace it in pathCopy
                const convertedSegment = Path.createSegment('L', originalSegment.end);
                pathCopy.replaceSegment(i, convertedSegment);
            }
        }
        // distribute pathCopy segments into two paths and return those:
        const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
        const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
        return [firstPath, secondPath];
    }
    intersectsWithLine(line, options = {}) {
        const polylines = this.toPolylines(options);
        if (polylines == null) {
            return null;
        }
        let intersections = null;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            const intersection = line.intersect(polyline);
            if (intersection) {
                if (intersections == null) {
                    intersections = [];
                }
                if (Array.isArray(intersection)) {
                    intersections.push(...intersection);
                }
                else {
                    intersections.push(intersection);
                }
            }
        }
        return intersections;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            if (segment.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    isValid() {
        const segments = this.segments;
        const isValid = segments.length === 0 || segments[0].type === 'M';
        return isValid;
    }
    length(options = {}) {
        if (this.segments.length === 0) {
            return 0;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ subdivisions });
        }
        return length;
    }
    lengthAtT(t, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return 0;
        }
        let segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return 0;
        }
        let tValue = GeometryUtil.clamp(t.value, 0, 1);
        if (segmentIndex >= count) {
            segmentIndex = count - 1;
            tValue = 1;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0; i < segmentIndex; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ precision, subdivisions });
        }
        const segment = this.segments[segmentIndex];
        const subdivisions = segmentSubdivisions[segmentIndex];
        length += segment.lengthAtT(tValue, { precision, subdivisions });
        return length;
    }
    tangentAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = GeometryUtil.clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.tangentAtLength(length, opts);
    }
    tangentAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastValidSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isDifferentiable()) {
                if (length <= memo + len) {
                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastValidSegment = segment;
            }
            memo += len;
        }
        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
        if (lastValidSegment) {
            const t = fromStart ? 1 : 0;
            return lastValidSegment.tangentAtT(t);
        }
        // if no valid segment, return null
        return null;
    }
    tangentAtT(t) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return this.segments[0].tangentAtT(0);
        }
        if (segmentIndex >= count) {
            return this.segments[count - 1].tangentAtT(1);
        }
        const tValue = GeometryUtil.clamp(t.value, 0, 1);
        return this.segments[segmentIndex].tangentAtT(tValue);
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getSubdivisions(options = {}) {
        if (options.segmentSubdivisions == null) {
            const precision = this.getPrecision(options);
            return this.getSegmentSubdivisions({ precision });
        }
        return options.segmentSubdivisions;
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        return { precision, segmentSubdivisions };
    }
    toPoints(options = {}) {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        const points = [];
        let partialPoints = [];
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const divisions = segmentSubdivisions[i];
                if (divisions.length > 0) {
                    // eslint-disable-next-line no-loop-func
                    divisions.forEach((c) => partialPoints.push(c.start));
                }
                else {
                    partialPoints.push(segment.start);
                }
            }
            else if (partialPoints.length > 0) {
                partialPoints.push(segments[i - 1].end);
                points.push(partialPoints);
                partialPoints = [];
            }
        }
        if (partialPoints.length > 0) {
            partialPoints.push(this.end);
            points.push(partialPoints);
        }
        return points;
    }
    toPolylines(options = {}) {
        const points = this.toPoints(options);
        if (!points) {
            return null;
        }
        return points.map((arr) => new Polyline(arr));
    }
    scale(sx, sy, origin) {
        this.segments.forEach((s) => s.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.segments.forEach((segment) => segment.rotate(angle, origin));
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.segments.forEach((s) => s.translate(tx, ty));
        }
        else {
            this.segments.forEach((s) => s.translate(tx));
        }
        return this;
    }
    clone() {
        const path = new Path();
        this.segments.forEach((s) => path.appendSegment(s.clone()));
        return path;
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        const segments = this.segments;
        const otherSegments = p.segments;
        const count = segments.length;
        if (otherSegments.length !== count) {
            return false;
        }
        for (let i = 0; i < count; i += 1) {
            const a = segments[i];
            const b = otherSegments[i];
            if (a.type !== b.type || !a.equals(b)) {
                return false;
            }
        }
        return true;
    }
    toJSON() {
        return this.segments.map((s) => s.toJSON());
    }
    serialize() {
        if (!this.isValid()) {
            throw new Error('Invalid path segments.');
        }
        return this.segments.map((s) => s.serialize()).join(' ');
    }
    toString() {
        return this.serialize();
    }
};
(function (Path) {
    function isPath(instance) {
        return instance != null && instance instanceof Path;
    }
    Path.isPath = isPath;
})(Path$1 || (Path$1 = {}));
(function (Path) {
    function parse(pathData) {
        if (!pathData) {
            return new Path();
        }
        const path = new Path();
        const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
        const commands = Path.normalize(pathData).match(commandRe);
        if (commands != null) {
            for (let i = 0, ii = commands.length; i < ii; i += 1) {
                const command = commands[i];
                const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
                const args = command.match(argRe); // [type, coordinate1, coordinate2...]
                if (args != null) {
                    const type = args[0];
                    const coords = args.slice(1).map((a) => +a);
                    const segment = createSegment.call(null, type, ...coords);
                    path.appendSegment(segment);
                }
            }
        }
        return path;
    }
    Path.parse = parse;
    function createSegment(type, ...args) {
        if (type === 'M') {
            return MoveTo.create.call(null, ...args);
        }
        if (type === 'L') {
            return LineTo.create.call(null, ...args);
        }
        if (type === 'C') {
            return CurveTo.create.call(null, ...args);
        }
        if (type === 'z' || type === 'Z') {
            return Close.create();
        }
        throw new Error(`Invalid path segment type "${type}"`);
    }
    Path.createSegment = createSegment;
})(Path$1 || (Path$1 = {}));
(function (Path) {
    Path.normalize = normalizePathData;
    Path.isValid = isValid;
    Path.drawArc = drawArc;
    Path.drawPoints = drawPoints;
    Path.arcToCurves = arcToCurves;
})(Path$1 || (Path$1 = {}));

class Registry {
    constructor(options) {
        this.options = Object.assign({}, options);
        this.data = this.options.data || {};
        this.register = this.register.bind(this);
        this.unregister = this.unregister.bind(this);
    }
    get names() {
        return Object.keys(this.data);
    }
    register(name, options, force = false) {
        if (typeof name === 'object') {
            Object.entries(name).forEach(([key, val]) => {
                this.register(key, val, options);
            });
            return;
        }
        if (this.exist(name) && !force && !Platform.isApplyingHMR()) {
            this.onDuplicated(name);
        }
        const process = this.options.process;
        const entity = process
            ? call$1(process, this, name, options)
            : options;
        this.data[name] = entity;
        return entity;
    }
    unregister(name) {
        const entity = name ? this.data[name] : null;
        delete this.data[name];
        return entity;
    }
    get(name) {
        return name ? this.data[name] : null;
    }
    exist(name) {
        return name ? this.data[name] != null : false;
    }
    onDuplicated(name) {
        // eslint-disable-next-line no-useless-catch
        try {
            // race
            if (this.options.onConflict) {
                call$1(this.options.onConflict, this, name);
            }
            throw new Error(`${upperFirst$1(this.options.type)} with name '${name}' already registered.`);
        }
        catch (err) {
            throw err;
        }
    }
    onNotFound(name, prefix) {
        throw new Error(this.getSpellingSuggestion(name, prefix));
    }
    getSpellingSuggestion(name, prefix) {
        const suggestion = this.getSpellingSuggestionForName(name);
        const prefixed = prefix
            ? `${prefix} ${lowerFirst$1(this.options.type)}`
            : this.options.type;
        return (
        // eslint-disable-next-line
        `${upperFirst$1(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`);
    }
    getSpellingSuggestionForName(name) {
        return getSpellingSuggestion(name, Object.keys(this.data), (candidate) => candidate);
    }
}
(function (Registry) {
    function create(options) {
        return new Registry(options);
    }
    Registry.create = create;
})(Registry || (Registry = {}));

const dot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const width = options.thickness * options.sx;
        const height = options.thickness * options.sy;
        attr(elem, {
            width,
            height,
            rx: width,
            ry: height,
            fill: options.color,
        });
    },
};

const fixedDot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
        attr(elem, {
            width: size,
            height: size,
            rx: size,
            ry: size,
            fill: options.color,
        });
    },
};

const mesh = {
    color: 'rgba(224,224,224,1)',
    thickness: 1,
    markup: 'path',
    update(elem, options) {
        let d;
        const width = options.width;
        const height = options.height;
        const thickness = options.thickness;
        if (width - thickness >= 0 && height - thickness >= 0) {
            d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
        }
        else {
            d = 'M 0 0 0 0';
        }
        attr(elem, {
            d,
            stroke: options.color,
            'stroke-width': options.thickness,
        });
    },
};

const doubleMesh = [
    {
        color: 'rgba(224,224,224,1)',
        thickness: 1,
        markup: 'path',
        update(elem, options) {
            let d;
            const width = options.width;
            const height = options.height;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            attr(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
    {
        color: 'rgba(224,224,224,0.2)',
        thickness: 3,
        factor: 4,
        markup: 'path',
        update(elem, options) {
            let d;
            const factor = options.factor || 1;
            const width = options.width * factor;
            const height = options.height * factor;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            // update wrapper size
            options.width = width;
            options.height = height;
            attr(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
];

const patterns$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    dot,
    doubleMesh,
    fixedDot,
    mesh
}, Symbol.toStringTag, { value: 'Module' }));

class Grid {
    constructor() {
        this.patterns = {};
        this.root = Vector.create(createSvgDocument(), {
            width: '100%',
            height: '100%',
        }, [createSvgElement('defs')]).node;
    }
    add(id, elem) {
        const firstChild = this.root.childNodes[0];
        if (firstChild) {
            firstChild.appendChild(elem);
        }
        this.patterns[id] = elem;
        Vector.create('rect', {
            width: '100%',
            height: '100%',
            fill: `url(#${id})`,
        }).appendTo(this.root);
    }
    get(id) {
        return this.patterns[id];
    }
    has(id) {
        return this.patterns[id] != null;
    }
}
(function (Grid) {
    Grid.presets = patterns$1;
    Grid.registry = Registry.create({
        type: 'grid',
    });
    Grid.registry.register(Grid.presets, true);
})(Grid || (Grid = {}));

const flipX = function (img) {
    // d b
    // d b
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width * 2;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    // left image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped right image
    ctx.translate(2 * width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const flipY = function (img) {
    // d d
    // q q
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width;
    canvas.height = height * 2;
    const ctx = canvas.getContext('2d');
    // top image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped bottom image
    ctx.translate(0, 2 * height);
    ctx.scale(1, -1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const flipXY = function (img) {
    // d b
    // q p
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = 2 * width;
    canvas.height = 2 * height;
    const ctx = canvas.getContext('2d');
    // top-left image
    ctx.drawImage(img, 0, 0, width, height);
    // xy-flipped bottom-right image
    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    // x-flipped top-right image
    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
    ctx.drawImage(img, 0, 0, width, height);
    // y-flipped bottom-left image
    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const watermark = function (img, options) {
    const width = img.width;
    const height = img.height;
    const canvas = document.createElement('canvas');
    canvas.width = width * 3;
    canvas.height = height * 3;
    const ctx = canvas.getContext('2d');
    const angle = options.angle != null ? -options.angle : -20;
    const radians = Angle.toRad(angle);
    const stepX = canvas.width / 4;
    const stepY = canvas.height / 4;
    for (let i = 0; i < 4; i += 1) {
        for (let j = 0; j < 4; j += 1) {
            if ((i + j) % 2 > 0) {
                ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                ctx.rotate(radians);
                ctx.drawImage(img, -width / 2, -height / 2, width, height);
            }
        }
    }
    return canvas;
};

const patterns = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    flipX,
    flipXY,
    flipY,
    watermark
}, Symbol.toStringTag, { value: 'Module' }));

/* eslint-disable @typescript-eslint/ban-types */
var Background;
(function (Background) {
    Background.presets = Object.assign({}, patterns);
    Background.presets['flip-x'] = flipX;
    Background.presets['flip-y'] = flipY;
    Background.presets['flip-xy'] = flipXY;
    Background.registry = Registry.create({
        type: 'background pattern',
    });
    Background.registry.register(Background.presets, true);
})(Background || (Background = {}));

function getString(value, defaultValue) {
    return value != null ? value : defaultValue;
}
function getNumber(num, defaultValue) {
    return num != null && Number.isFinite(num) ? num : defaultValue;
}

function outline(args = {}) {
    const color = getString(args.color, 'blue');
    const width = getNumber(args.width, 1);
    const margin = getNumber(args.margin, 2);
    const opacity = getNumber(args.opacity, 1);
    const innerRadius = margin;
    const outerRadius = margin + width;
    return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}

function highlight(args = {}) {
    const color = getString(args.color, 'red');
    const blur = getNumber(args.blur, 0);
    const width = getNumber(args.width, 1);
    const opacity = getNumber(args.opacity, 1);
    return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}

function blur(args = {}) {
    const x = getNumber(args.x, 2);
    const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
    return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}

function dropShadow(args = {}) {
    const dx = getNumber(args.dx, 0);
    const dy = getNumber(args.dy, 0);
    const color = getString(args.color, 'black');
    const blur = getNumber(args.blur, 4);
    const opacity = getNumber(args.opacity, 1);
    return 'SVGFEDropShadowElement' in window
        ? `<filter>
         <feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}" />
       </filter>`.trim()
        : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}

function grayScale(args = {}) {
    const amount = getNumber(args.amount, 1);
    const a = 0.2126 + 0.7874 * (1 - amount);
    const b = 0.7152 - 0.7152 * (1 - amount);
    const c = 0.0722 - 0.0722 * (1 - amount);
    const d = 0.2126 - 0.2126 * (1 - amount);
    const e = 0.7152 + 0.2848 * (1 - amount);
    const f = 0.0722 - 0.0722 * (1 - amount);
    const g = 0.2126 - 0.2126 * (1 - amount);
    const h = 0.0722 + 0.9278 * (1 - amount);
    return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}

function sepia(args = {}) {
    const amount = getNumber(args.amount, 1);
    const a = 0.393 + 0.607 * (1 - amount);
    const b = 0.769 - 0.769 * (1 - amount);
    const c = 0.189 - 0.189 * (1 - amount);
    const d = 0.349 - 0.349 * (1 - amount);
    const e = 0.686 + 0.314 * (1 - amount);
    const f = 0.168 - 0.168 * (1 - amount);
    const g = 0.272 - 0.272 * (1 - amount);
    const h = 0.534 - 0.534 * (1 - amount);
    const i = 0.131 + 0.869 * (1 - amount);
    return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}

function saturate(args = {}) {
    const amount = getNumber(args.amount, 1);
    return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}

function hueRotate(args = {}) {
    const angle = getNumber(args.angle, 0);
    return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}

function invert(args = {}) {
    const amount = getNumber(args.amount, 1);
    const amount2 = 1 - amount;
    return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}

function brightness(args = {}) {
    const amount = getNumber(args.amount, 1);
    return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

function contrast(args = {}) {
    const amount = getNumber(args.amount, 1);
    const amount2 = 0.5 - amount / 2;
    return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

const filters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    blur,
    brightness,
    contrast,
    dropShadow,
    grayScale,
    highlight,
    hueRotate,
    invert,
    outline,
    saturate,
    sepia
}, Symbol.toStringTag, { value: 'Module' }));

var Filter;
(function (Filter) {
    Filter.presets = filters;
    Filter.registry = Registry.create({
        type: 'filter',
    });
    Filter.registry.register(Filter.presets, true);
})(Filter || (Filter = {}));

const raw = {
    xlinkHref: 'xlink:href',
    xlinkShow: 'xlink:show',
    xlinkRole: 'xlink:role',
    xlinkType: 'xlink:type',
    xlinkArcrole: 'xlink:arcrole',
    xlinkTitle: 'xlink:title',
    xlinkActuate: 'xlink:actuate',
    xmlSpace: 'xml:space',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    preserveAspectRatio: 'preserveAspectRatio',
    requiredExtension: 'requiredExtension',
    requiredFeatures: 'requiredFeatures',
    systemLanguage: 'systemLanguage',
    externalResourcesRequired: 'externalResourceRequired',
};

const ref = {
// We do not set `ref` attribute directly on an element.
// The attribute itself does not qualify for relative positioning.
};
// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
// otherwise, `refX` is the left coordinate of the bounding box
const refX = {
    position: positionWrapper('x', 'width', 'origin'),
};
const refY = {
    position: positionWrapper('y', 'height', 'origin'),
};
// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
// coordinate of the reference element.
const refDx = {
    position: positionWrapper('x', 'width', 'corner'),
};
const refDy = {
    position: positionWrapper('y', 'height', 'corner'),
};
// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
// the reference element size
// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
const refWidth = {
    set: setWrapper('width', 'width'),
};
const refHeight = {
    set: setWrapper('height', 'height'),
};
const refRx = {
    set: setWrapper('rx', 'width'),
};
const refRy = {
    set: setWrapper('ry', 'height'),
};
const refRInscribed = {
    set: ((attrName) => {
        const widthFn = setWrapper(attrName, 'width');
        const heightFn = setWrapper(attrName, 'height');
        return function (value, options) {
            const refBBox = options.refBBox;
            const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
            return call$1(fn, this, value, options);
        };
    })('r'),
};
const refRCircumscribed = {
    set(val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
        let rValue;
        if (Number.isFinite(value)) {
            if (percentage || (value >= 0 && value <= 1)) {
                rValue = value * diagonalLength;
            }
            else {
                rValue = Math.max(value + diagonalLength, 0);
            }
        }
        return { r: rValue };
    },
};
const refCx = {
    set: setWrapper('cx', 'width'),
};
const refCy = {
    set: setWrapper('cy', 'height'),
};
const refDResetOffset = {
    set: dWrapper({ resetOffset: true }),
};
const refDKeepOffset = {
    set: dWrapper({ resetOffset: false }),
};
const refPointsResetOffset = {
    set: pointsWrapper({ resetOffset: true }),
};
const refPointsKeepOffset = {
    set: pointsWrapper({ resetOffset: false }),
};
// aliases
// -------
const refR = refRInscribed;
const refD = refDResetOffset;
const refPoints = refPointsResetOffset;
// Allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20
const refX2 = refX;
const refY2 = refY;
const refWidth2 = refWidth;
const refHeight2 = refHeight;
// utils
// -----
function positionWrapper(axis, dimension, origin) {
    return (val, { refBBox }) => {
        if (val == null) {
            return null;
        }
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        let delta;
        if (Number.isFinite(value)) {
            const refOrigin = refBBox[origin];
            if (percentage || (value > 0 && value < 1)) {
                delta = refOrigin[axis] + refBBox[dimension] * value;
            }
            else {
                delta = refOrigin[axis] + value;
            }
        }
        const point = new Point();
        point[axis] = delta || 0;
        return point;
    };
}
function setWrapper(attrName, dimension) {
    return function (val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const attrs = {};
        if (Number.isFinite(value)) {
            const attrValue = percentage || (value >= 0 && value <= 1)
                ? value * refBBox[dimension]
                : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
        }
        return attrs;
    };
}
function shapeWrapper(shapeConstructor, options) {
    const cacheName = 'x6-shape';
    const resetOffset = options && options.resetOffset;
    return function (value, { elem, refBBox }) {
        let cache = data(elem, cacheName);
        if (!cache || cache.value !== value) {
            // only recalculate if value has changed
            const cachedShape = shapeConstructor(value);
            cache = {
                value,
                shape: cachedShape,
                shapeBBox: cachedShape.bbox(),
            };
            data(elem, cacheName, cache);
        }
        const shape = cache.shape.clone();
        const shapeBBox = cache.shapeBBox.clone();
        const shapeOrigin = shapeBBox.getOrigin();
        const refOrigin = refBBox.getOrigin();
        shapeBBox.x = refOrigin.x;
        shapeBBox.y = refOrigin.y;
        const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);
        // `maxRectScaleToFit` can give Infinity if width or height is 0
        const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
        const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
        shape.scale(sx, sy, shapeOrigin);
        if (resetOffset) {
            shape.translate(-shapeOrigin.x, -shapeOrigin.y);
        }
        return shape;
    };
}
// `d` attribute for SVGPaths
function dWrapper(options) {
    function pathConstructor(value) {
        return Path$1.parse(value);
    }
    const shape = shapeWrapper(pathConstructor, options);
    return (value, args) => {
        const path = shape(value, args);
        return {
            d: path.serialize(),
        };
    };
}
// `points` attribute for SVGPolylines and SVGPolygons
function pointsWrapper(options) {
    const shape = shapeWrapper((points) => new Polyline(points), options);
    return (value, args) => {
        const polyline = shape(value, args);
        return {
            points: polyline.serialize(),
        };
    };
}

const fill = {
    qualify: isPlainObject,
    set(fill, { view }) {
        return `url(#${view.graph.defineGradient(fill)})`;
    },
};

const stroke$1 = {
    qualify: isPlainObject,
    set(stroke, { view }) {
        const cell = view.cell;
        const options = Object.assign({}, stroke);
        if (cell.isEdge() && options.type === 'linearGradient') {
            const edgeView = view;
            const source = edgeView.sourcePoint;
            const target = edgeView.targetPoint;
            options.id = `gradient-${options.type}-${cell.id}`;
            options.attrs = Object.assign(Object.assign({}, options.attrs), { x1: source.x, y1: source.y, x2: target.x, y2: target.y, gradientUnits: 'userSpaceOnUse' });
            view.graph.defs.remove(options.id);
        }
        return `url(#${view.graph.defineGradient(options)})`;
    },
};

const text = {
    qualify(text, { attrs }) {
        return attrs.textWrap == null || !isPlainObject(attrs.textWrap);
    },
    set(text, { view, elem, attrs }) {
        const cacheName = 'x6-text';
        const cache = data(elem, cacheName);
        const json = (str) => {
            try {
                return JSON.parse(str);
            }
            catch (error) {
                return str;
            }
        };
        const options = {
            x: attrs.x,
            eol: attrs.eol,
            annotations: json(attrs.annotations),
            textPath: json(attrs['text-path'] || attrs.textPath),
            textVerticalAnchor: (attrs['text-vertical-anchor'] ||
                attrs.textVerticalAnchor),
            displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',
            lineHeight: (attrs['line-height'] || attrs.lineHeight),
        };
        const fontSize = (attrs['font-size'] || attrs.fontSize);
        const textHash = JSON.stringify([text, options]);
        if (fontSize) {
            elem.setAttribute('font-size', fontSize);
        }
        // Updates the text only if there was a change in the string
        // or any of its attributes.
        if (cache == null || cache !== textHash) {
            // Text Along Path Selector
            const textPath = options.textPath;
            if (textPath != null && typeof textPath === 'object') {
                const selector = textPath.selector;
                if (typeof selector === 'string') {
                    const pathNode = view.find(selector)[0];
                    if (pathNode instanceof SVGPathElement) {
                        ensureId(pathNode);
                        options.textPath = Object.assign({ 'xlink:href': `#${pathNode.id}` }, textPath);
                    }
                }
            }
            text$1(elem, `${text}`, options);
            data(elem, cacheName, textHash);
        }
    },
};
const textWrap = {
    qualify: isPlainObject,
    set(val, { view, elem, attrs, refBBox }) {
        const info = val;
        // option `width`
        const width = info.width || 0;
        if (isPercentage(width)) {
            refBBox.width *= parseFloat(width) / 100;
        }
        else if (width <= 0) {
            refBBox.width += width;
        }
        else {
            refBBox.width = width;
        }
        // option `height`
        const height = info.height || 0;
        if (isPercentage(height)) {
            refBBox.height *= parseFloat(height) / 100;
        }
        else if (height <= 0) {
            refBBox.height += height;
        }
        else {
            refBBox.height = height;
        }
        // option `text`
        let wrappedText;
        let txt = info.text;
        if (txt == null) {
            // the edge of the label is assigned to txt
            txt = attrs.text || (elem === null || elem === void 0 ? void 0 : elem.textContent);
        }
        if (txt != null) {
            wrappedText = breakText(`${txt}`, refBBox, {
                'font-weight': attrs['font-weight'] || attrs.fontWeight,
                'font-size': attrs['font-size'] || attrs.fontSize,
                'font-family': attrs['font-family'] || attrs.fontFamily,
                lineHeight: attrs.lineHeight,
            }, {
                // svgDocument: view.graph.view.svg,
                ellipsis: info.ellipsis,
                // hyphen: info.hyphen as string,
                // breakWord: info.breakWord as boolean,
            });
        }
        else {
            wrappedText = '';
        }
        call$1(text.set, this, wrappedText, {
            view,
            elem,
            attrs,
            refBBox,
            cell: view.cell,
        });
    },
};
const isTextInUse = (val, { attrs }) => {
    return attrs.text !== undefined;
};
const lineHeight = {
    qualify: isTextInUse,
};
const textVerticalAnchor = {
    qualify: isTextInUse,
};
const textPath = {
    qualify: isTextInUse,
};
const annotations = {
    qualify: isTextInUse,
};
const eol = {
    qualify: isTextInUse,
};
const displayEmpty = {
    qualify: isTextInUse,
};

const title = {
    qualify(title, { elem }) {
        // HTMLElement title is specified via an attribute (i.e. not an element)
        return elem instanceof SVGElement;
    },
    set(val, { elem }) {
        const cacheName = 'x6-title';
        const title = `${val}`;
        const cache = data(elem, cacheName);
        if (cache == null || cache !== title) {
            data(elem, cacheName, title);
            // Generally SVGTitleElement should be the first child
            // element of its parent.
            const firstChild = elem.firstChild;
            if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {
                // Update an existing title
                const titleElem = firstChild;
                titleElem.textContent = title;
            }
            else {
                // Create a new title
                const titleNode = document.createElementNS(elem.namespaceURI, 'title');
                titleNode.textContent = title;
                elem.insertBefore(titleNode, firstChild);
            }
        }
    },
};

// `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.
// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.
const xAlign = {
    offset: offsetWrapper('x', 'width', 'right'),
};
// `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.
// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
const yAlign = {
    offset: offsetWrapper('y', 'height', 'bottom'),
};
const resetOffset = {
    offset(val, { refBBox }) {
        return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 };
    },
};
function offsetWrapper(axis, dimension, corner) {
    return (value, { refBBox }) => {
        const point = new Point();
        let delta;
        if (value === 'middle') {
            delta = refBBox[dimension] / 2;
        }
        else if (value === corner) {
            delta = refBBox[dimension];
        }
        else if (typeof value === 'number' && Number.isFinite(value)) {
            delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
        }
        else if (isPercentage(value)) {
            delta = (refBBox[dimension] * parseFloat(value)) / 100;
        }
        else {
            delta = 0;
        }
        point[axis] = -(refBBox[axis] + delta);
        return point;
    };
}

const style = {
    qualify: isPlainObject,
    set(styles, { elem }) {
        css(elem, styles);
    },
};

const html = {
    set(html, { elem }) {
        elem.innerHTML = `${html}`;
    },
};

const filter = {
    qualify: isPlainObject,
    set(filter, { view }) {
        return `url(#${view.graph.defineFilter(filter)})`;
    },
};

const port = {
    set(port) {
        if (port != null && typeof port === 'object' && port.id) {
            return port.id;
        }
        return port;
    },
};

function normalize(d, offset1, offset2) {
    let offsetX;
    let offsetY;
    if (typeof offset1 === 'object') {
        offsetX = offset1.x;
        offsetY = offset1.y;
    }
    else {
        offsetX = offset1;
        offsetY = offset2;
    }
    const path = Path$1.parse(d);
    const bbox = path.bbox();
    if (bbox) {
        let ty = -bbox.height / 2 - bbox.y;
        let tx = -bbox.width / 2 - bbox.x;
        if (typeof offsetX === 'number') {
            tx -= offsetX;
        }
        if (typeof offsetY === 'number') {
            ty -= offsetY;
        }
        path.translate(tx, ty);
    }
    return path.serialize();
}

var __rest$p = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const block = (_a) => {
    var { size, width, height, offset, open } = _a, attrs = __rest$p(_a, ["size", "width", "height", "offset", "open"]);
    return createClassicMarker({ size, width, height, offset }, open === true, true, undefined, attrs);
};
const classic = (_a) => {
    var { size, width, height, offset, factor } = _a, attrs = __rest$p(_a, ["size", "width", "height", "offset", "factor"]);
    return createClassicMarker({ size, width, height, offset }, false, false, factor, attrs);
};
function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
    const size = options.size || 10;
    const width = options.width || size;
    const height = options.height || size;
    const path = new Path$1();
    const localAttrs = {};
    if (open) {
        path
            .moveTo(width, 0)
            .lineTo(0, height / 2)
            .lineTo(width, height);
        localAttrs.fill = 'none';
    }
    else {
        path.moveTo(0, height / 2);
        path.lineTo(width, 0);
        if (!full) {
            const f = clamp(factor, 0, 1);
            path.lineTo(width * f, height / 2);
        }
        path.lineTo(width, height);
        path.close();
    }
    return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), { tagName: 'path', d: normalize(path.serialize(), {
            x: options.offset != null ? options.offset : -width / 2,
        }) });
}

var __rest$o = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const diamond = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest$o(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new Path$1();
    path
        .moveTo(0, h / 2)
        .lineTo(w / 2, 0)
        .lineTo(w, h / 2)
        .lineTo(w / 2, h)
        .close();
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize(path.serialize(), offset == null ? -w / 2 : offset) });
};

var __rest$n = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const path = (_a) => {
    var { d, offsetX, offsetY } = _a, attrs = __rest$n(_a, ["d", "offsetX", "offsetY"]);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize(d, offsetX, offsetY) });
};

var __rest$m = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const cross = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest$m(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new Path$1();
    path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', fill: 'none', d: normalize(path.serialize(), offset || -w / 2) });
};

var __rest$l = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const async = (_a) => {
    var { width, height, offset, open, flip } = _a, attrs = __rest$l(_a, ["width", "height", "offset", "open", "flip"]);
    let h = height || 6;
    const w = width || 10;
    const opened = open === true;
    const fliped = flip === true;
    const result = Object.assign(Object.assign({}, attrs), { tagName: 'path' });
    if (fliped) {
        h = -h;
    }
    const path = new Path$1();
    path.moveTo(0, h).lineTo(w, 0);
    if (!opened) {
        path.lineTo(w, h);
        path.close();
    }
    else {
        result.fill = 'none';
    }
    result.d = normalize(path.serialize(), {
        x: offset || -w / 2,
        y: h / 2,
    });
    return result;
};

var __rest$k = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const circle = (_a) => {
    var { r } = _a, attrs = __rest$k(_a, ["r"]);
    const radius = r || 5;
    return Object.assign(Object.assign({ cx: radius }, attrs), { tagName: 'circle', r: radius });
};
const circlePlus = (_a) => {
    var { r } = _a, attrs = __rest$k(_a, ["r"]);
    const radius = r || 5;
    const path = new Path$1();
    path.moveTo(radius, 0).lineTo(radius, radius * 2);
    path.moveTo(0, radius).lineTo(radius * 2, radius);
    return {
        children: [
            Object.assign(Object.assign({}, circle({ r: radius })), { fill: 'none' }),
            Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize(path.serialize(), -radius) }),
        ],
    };
};

var __rest$j = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ellipse$1 = (_a) => {
    var { rx, ry } = _a, attrs = __rest$j(_a, ["rx", "ry"]);
    const radiusX = rx || 5;
    const radiusy = ry || 5;
    return Object.assign(Object.assign({ cx: radiusX }, attrs), { tagName: 'ellipse', rx: radiusX, ry: radiusy });
};

const markers = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    async,
    block,
    circle,
    circlePlus,
    classic,
    cross,
    diamond,
    ellipse: ellipse$1,
    path
}, Symbol.toStringTag, { value: 'Module' }));

var Marker;
(function (Marker) {
    Marker.presets = markers;
    Marker.registry = Registry.create({
        type: 'marker',
    });
    Marker.registry.register(Marker.presets, true);
})(Marker || (Marker = {}));
(function (Marker) {
    Marker.normalize = normalize;
})(Marker || (Marker = {}));

var __rest$i = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function qualify(value) {
    return typeof value === 'string' || isPlainObject(value);
}
const sourceMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-start', marker, view, attrs);
    },
};
const targetMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-end', marker, view, attrs, {
            transform: 'rotate(180)',
        });
    },
};
const vertexMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-mid', marker, view, attrs);
    },
};
function createMarker(type, marker, view, attrs, manual = {}) {
    const def = typeof marker === 'string' ? { name: marker } : marker;
    const { name, args } = def, others = __rest$i(def, ["name", "args"]);
    let preset = others;
    if (name && typeof name === 'string') {
        const fn = Marker.registry.get(name);
        if (fn) {
            preset = fn(Object.assign(Object.assign({}, others), args));
        }
        else {
            return Marker.registry.onNotFound(name);
        }
    }
    const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);
    return {
        [type]: `url(#${view.graph.defineMarker(options)})`,
    };
}
function normalizeAttr(attr, type) {
    const result = {};
    // The context 'fill' is disregared here. The usual case is to use the
    // marker with a connection(for which 'fill' attribute is set to 'none').
    const stroke = attr.stroke;
    if (typeof stroke === 'string') {
        result.stroke = stroke;
        result.fill = stroke;
    }
    // Again the context 'fill-opacity' is ignored.
    let strokeOpacity = attr.strokeOpacity;
    if (strokeOpacity == null) {
        strokeOpacity = attr['stroke-opacity'];
    }
    if (strokeOpacity == null) {
        strokeOpacity = attr.opacity;
    }
    if (strokeOpacity != null) {
        result['stroke-opacity'] = strokeOpacity;
        result['fill-opacity'] = strokeOpacity;
    }
    if (type !== 'marker-mid') {
        const strokeWidth = parseFloat((attr.strokeWidth || attr['stroke-width']));
        if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
            const offset = Math.ceil(strokeWidth / 2);
            result.refX = type === 'marker-start' ? offset : -offset;
        }
    }
    return result;
}

const isEdgeView = (val, { view }) => {
    return view.cell.isEdge();
};
const connection = {
    qualify: isEdgeView,
    set(val, args) {
        var _a, _b, _c, _d;
        const view = args.view;
        const reverse = (val.reverse || false);
        const stubs = (val.stubs || 0);
        let d;
        if (Number.isFinite(stubs) && stubs !== 0) {
            if (!reverse) {
                let offset;
                if (stubs < 0) {
                    const len = view.getConnectionLength() || 0;
                    offset = (len + stubs) / 2;
                }
                else {
                    offset = stubs;
                }
                const path = view.getConnection();
                if (path) {
                    const sourceParts = path.divideAtLength(offset);
                    const targetParts = path.divideAtLength(-offset);
                    if (sourceParts && targetParts) {
                        d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
                    }
                }
            }
            else {
                let offset;
                let length;
                const len = view.getConnectionLength() || 0;
                if (stubs < 0) {
                    offset = (len + stubs) / 2;
                    length = -stubs;
                }
                else {
                    offset = stubs;
                    length = len - stubs * 2;
                }
                const path = view.getConnection();
                d = (_d = (_c = (_b = (_a = path === null || path === void 0 ? void 0 : path.divideAtLength(offset)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
            }
        }
        return { d: d || view.getConnectionPathData() };
    },
};
const atConnectionLengthKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: true }),
};
const atConnectionLengthIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: false }),
};
const atConnectionRatioKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),
};
const atConnectionRatioIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),
};
// aliases
// -------
const atConnectionLength = atConnectionLengthKeepGradient;
const atConnectionRatio = atConnectionRatioKeepGradient;
// utils
// -----
function atConnectionWrapper(method, options) {
    const zeroVector = { x: 1, y: 0 };
    return (value, args) => {
        let p;
        let angle;
        const view = args.view;
        const tangent = view[method](Number(value));
        if (tangent) {
            angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
        }
        else {
            p = view.path.start;
            angle = 0;
        }
        if (angle === 0) {
            return { transform: `translate(${p.x},${p.y}')` };
        }
        return {
            transform: `translate(${p.x},${p.y}') rotate(${angle})`,
        };
    };
}

const attrs = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    annotations,
    atConnectionLength,
    atConnectionLengthIgnoreGradient,
    atConnectionLengthKeepGradient,
    atConnectionRatio,
    atConnectionRatioIgnoreGradient,
    atConnectionRatioKeepGradient,
    connection,
    displayEmpty,
    eol,
    fill,
    filter,
    html,
    lineHeight,
    port,
    ref,
    refCx,
    refCy,
    refD,
    refDKeepOffset,
    refDResetOffset,
    refDx,
    refDy,
    refHeight,
    refHeight2,
    refPoints,
    refPointsKeepOffset,
    refPointsResetOffset,
    refR,
    refRCircumscribed,
    refRInscribed,
    refRx,
    refRy,
    refWidth,
    refWidth2,
    refX,
    refX2,
    refY,
    refY2,
    resetOffset,
    sourceMarker,
    stroke: stroke$1,
    style,
    targetMarker,
    text,
    textPath,
    textVerticalAnchor,
    textWrap,
    title,
    vertexMarker,
    xAlign,
    yAlign
}, Symbol.toStringTag, { value: 'Module' }));

var Attr;
(function (Attr) {
    function isValidDefinition(def, val, options) {
        if (def != null) {
            if (typeof def === 'string') {
                return true;
            }
            if (typeof def.qualify !== 'function' ||
                call$1(def.qualify, this, val, options)) {
                return true;
            }
        }
        return false;
    }
    Attr.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));
(function (Attr) {
    Attr.presets = Object.assign(Object.assign({}, raw), attrs);
    Attr.registry = Registry.create({
        type: 'attribute definition',
    });
    Attr.registry.register(Attr.presets, true);
})(Attr || (Attr = {}));

const Config = {
    prefixCls: 'x6',
    autoInsertCSS: true,
    useCSSSelector: true,
    prefix(suffix) {
        return `${Config.prefixCls}-${suffix}`;
    },
};

const defaultClassName = Config.prefix('highlighted');
const className$1 = {
    highlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        addClass(magnet, cls);
    },
    unhighlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        removeClass(magnet, cls);
    },
};

const className = Config.prefix('highlight-opacity');
const opacity = {
    highlight(cellView, magnet) {
        addClass(magnet, className);
    },
    unhighlight(cellView, magnetEl) {
        removeClass(magnetEl, className);
    },
};

var Util;
(function (Util) {
    Util.normalizeMarker = normalize;
    /**
     * Transforms point by an SVG transformation represented by `matrix`.
     */
    function transformPoint(point, matrix) {
        const ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);
        return new Point(ret.x, ret.y);
    }
    Util.transformPoint = transformPoint;
    /**
     * Transforms line by an SVG transformation represented by `matrix`.
     */
    function transformLine(line, matrix) {
        return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
    }
    Util.transformLine = transformLine;
    /**
     * Transforms polyline by an SVG transformation represented by `matrix`.
     */
    function transformPolyline(polyline, matrix) {
        let points = polyline instanceof Polyline ? polyline.points : polyline;
        if (!Array.isArray(points)) {
            points = [];
        }
        return new Polyline(points.map((p) => transformPoint(p, matrix)));
    }
    Util.transformPolyline = transformPolyline;
    function transformRectangle(rect, matrix) {
        const svgDocument = createSvgElement('svg');
        const p = svgDocument.createSVGPoint();
        p.x = rect.x;
        p.y = rect.y;
        const corner1 = p.matrixTransform(matrix);
        p.x = rect.x + rect.width;
        p.y = rect.y;
        const corner2 = p.matrixTransform(matrix);
        p.x = rect.x + rect.width;
        p.y = rect.y + rect.height;
        const corner3 = p.matrixTransform(matrix);
        p.x = rect.x;
        p.y = rect.y + rect.height;
        const corner4 = p.matrixTransform(matrix);
        const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
        const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
        const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
        const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }
    Util.transformRectangle = transformRectangle;
    /**
     * Returns the bounding box of the element after transformations are
     * applied. If `withoutTransformations` is `true`, transformations of
     * the element will not be considered when computing the bounding box.
     * If `target` is specified, bounding box will be computed relatively
     * to the `target` element.
     */
    function bbox(elem, withoutTransformations, target) {
        let box;
        const ownerSVGElement = elem.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding
        // box defined and so fall back to 'zero' dimension element.
        if (!ownerSVGElement) {
            return new Rectangle(0, 0, 0, 0);
        }
        try {
            box = elem.getBBox();
        }
        catch (e) {
            // Fallback for IE.
            box = {
                x: elem.clientLeft,
                y: elem.clientTop,
                width: elem.clientWidth,
                height: elem.clientHeight,
            };
        }
        if (withoutTransformations) {
            return Rectangle.create(box);
        }
        const matrix = getTransformToElement(elem, target || ownerSVGElement);
        return transformRectangle(box, matrix);
    }
    Util.bbox = bbox;
    /**
     * Returns the bounding box of the element after transformations are
     * applied. Unlike `bbox()`, this function fixes a browser implementation
     * bug to return the correct bounding box if this elemenent is a group of
     * svg elements (if `options.recursive` is specified).
     */
    function getBBox(elem, options = {}) {
        let outputBBox;
        const ownerSVGElement = elem.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box
        // defined and so fall back to 'zero' dimension element.
        // If the element is not an SVGGraphicsElement, we could not measure the
        // bounding box either
        if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {
            if (isHTMLElement(elem)) {
                // If the element is a HTMLElement, return the position relative to the body
                const { left, top, width, height } = getBoundingOffsetRect(elem);
                return new Rectangle(left, top, width, height);
            }
            return new Rectangle(0, 0, 0, 0);
        }
        let target = options.target;
        const recursive = options.recursive;
        if (!recursive) {
            try {
                outputBBox = elem.getBBox();
            }
            catch (e) {
                outputBBox = {
                    x: elem.clientLeft,
                    y: elem.clientTop,
                    width: elem.clientWidth,
                    height: elem.clientHeight,
                };
            }
            if (!target) {
                return Rectangle.create(outputBBox);
            }
            // transform like target
            const matrix = getTransformToElement(elem, target);
            return transformRectangle(outputBBox, matrix);
        }
        // recursive
        {
            const children = elem.childNodes;
            const n = children.length;
            if (n === 0) {
                return getBBox(elem, {
                    target,
                });
            }
            if (!target) {
                target = elem; // eslint-disable-line
            }
            for (let i = 0; i < n; i += 1) {
                const child = children[i];
                let childBBox;
                if (child.childNodes.length === 0) {
                    childBBox = getBBox(child, {
                        target,
                    });
                }
                else {
                    // if child is a group element, enter it with a recursive call
                    childBBox = getBBox(child, {
                        target,
                        recursive: true,
                    });
                }
                if (!outputBBox) {
                    outputBBox = childBBox;
                }
                else {
                    outputBBox = outputBBox.union(childBBox);
                }
            }
            return outputBBox;
        }
    }
    Util.getBBox = getBBox;
    function getBoundingOffsetRect(elem) {
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        if (elem) {
            let current = elem;
            while (current) {
                left += current.offsetLeft;
                top += current.offsetTop;
                current = current.offsetParent;
                if (current) {
                    left += parseInt(getComputedStyle$1(current, 'borderLeft'), 10);
                    top += parseInt(getComputedStyle$1(current, 'borderTop'), 10);
                }
            }
            width = elem.offsetWidth;
            height = elem.offsetHeight;
        }
        return {
            left,
            top,
            width,
            height,
        };
    }
    Util.getBoundingOffsetRect = getBoundingOffsetRect;
    /**
     * Convert the SVGElement to an equivalent geometric shape. The element's
     * transformations are not taken into account.
     *
     * SVGRectElement      => Rectangle
     *
     * SVGLineElement      => Line
     *
     * SVGCircleElement    => Ellipse
     *
     * SVGEllipseElement   => Ellipse
     *
     * SVGPolygonElement   => Polyline
     *
     * SVGPolylineElement  => Polyline
     *
     * SVGPathElement      => Path
     *
     * others              => Rectangle
     */
    function toGeometryShape(elem) {
        const attr = (name) => {
            const s = elem.getAttribute(name);
            const v = s ? parseFloat(s) : 0;
            return Number.isNaN(v) ? 0 : v;
        };
        switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
            case 'rect':
                return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
            case 'circle':
                return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));
            case 'ellipse':
                return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));
            case 'polyline': {
                const points = getPointsFromSvgElement(elem);
                return new Polyline(points);
            }
            case 'polygon': {
                const points = getPointsFromSvgElement(elem);
                if (points.length > 1) {
                    points.push(points[0]);
                }
                return new Polyline(points);
            }
            case 'path': {
                let d = elem.getAttribute('d');
                if (!Path$1.isValid(d)) {
                    d = Path$1.normalize(d);
                }
                return Path$1.parse(d);
            }
            case 'line': {
                return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
            }
        }
        // Anything else is a rectangle
        return getBBox(elem);
    }
    Util.toGeometryShape = toGeometryShape;
    function translateAndAutoOrient(elem, position, reference, target) {
        const pos = Point.create(position);
        const ref = Point.create(reference);
        if (!target) {
            const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
            target = svg; // eslint-disable-line
        }
        // Clean-up previously set transformations except the scale.
        // If we didn't clean up the previous transformations then they'd
        // add up with the old ones. Scale is an exception as it doesn't
        // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
        // is that the element is scaled by the factor 2, not 8.
        const s = scale(elem);
        elem.setAttribute('transform', '');
        const bbox = getBBox(elem, {
            target,
        }).scale(s.sx, s.sy);
        // 1. Translate to origin.
        const translateToOrigin = createSVGTransform();
        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
        // 2. Rotate around origin.
        const rotateAroundOrigin = createSVGTransform();
        const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
        if (angle)
            rotateAroundOrigin.setRotate(angle, 0, 0);
        // 3. Translate to the `position` + the offset (half my width)
        //    towards the `reference` point.
        const translateFromOrigin = createSVGTransform();
        const finalPosition = pos.clone().move(ref, bbox.width / 2);
        translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
        // 4. Get the current transformation matrix of this node
        const ctm = getTransformToElement(elem, target);
        // 5. Apply transformations and the scale
        const transform = createSVGTransform();
        transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
        elem.setAttribute('transform', matrixToTransformString(transform.matrix));
    }
    Util.translateAndAutoOrient = translateAndAutoOrient;
    function findShapeNode(magnet) {
        if (magnet == null) {
            return null;
        }
        let node = magnet;
        do {
            let tagName = node.tagName;
            if (typeof tagName !== 'string')
                return null;
            tagName = tagName.toUpperCase();
            if (hasClass(node, 'x6-port')) {
                node = node.nextElementSibling;
            }
            else if (tagName === 'G') {
                node = node.firstElementChild;
            }
            else if (tagName === 'TITLE') {
                node = node.nextElementSibling;
            }
            else
                break;
        } while (node);
        return node;
    }
    Util.findShapeNode = findShapeNode;
    // BBox is calculated by the attribute and shape of the node.
    // Because of the reduction in DOM API calls, there is a significant performance improvement.
    function getBBoxV2(elem) {
        const node = findShapeNode(elem);
        if (!isSVGGraphicsElement(node)) {
            if (isHTMLElement(elem)) {
                const { left, top, width, height } = getBoundingOffsetRect(elem);
                return new Rectangle(left, top, width, height);
            }
            return new Rectangle(0, 0, 0, 0);
        }
        const shape = toGeometryShape(node);
        const bbox = shape.bbox() || Rectangle.create();
        // const transform = node.getAttribute('transform')
        // if (transform) {
        //   const nodeMatrix = Dom.transformStringToMatrix(transform)
        //   return transformRectangle(bbox, nodeMatrix)
        // }
        return bbox;
    }
    Util.getBBoxV2 = getBBoxV2;
})(Util || (Util = {}));

const defaultOptions = {
    padding: 3,
    rx: 0,
    ry: 0,
    attrs: {
        'stroke-width': 3,
        stroke: '#FEB663',
    },
};
const stroke = {
    highlight(cellView, magnet, options) {
        const id = Private$2.getHighlighterId(magnet, options);
        if (Private$2.hasCache(id)) {
            return;
        }
        // eslint-disable-next-line
        options = defaultsDeep$1({}, options, defaultOptions);
        const magnetVel = Vector.create(magnet);
        let pathData;
        let magnetBBox;
        try {
            pathData = magnetVel.toPathData();
        }
        catch (error) {
            // Failed to get path data from magnet element.
            // Draw a rectangle around the entire cell view instead.
            magnetBBox = Util.bbox(magnetVel.node, true);
            pathData = rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
        }
        const path = createSvgElement('path');
        attr(path, Object.assign({ d: pathData, 'pointer-events': 'none', 'vector-effect': 'non-scaling-stroke', fill: 'none' }, (options.attrs ? kebablizeAttrs(options.attrs) : null)));
        // const highlightVel = v.create('path').attr()
        if (cellView.isEdgeElement(magnet)) {
            attr(path, 'd', cellView.getConnectionPathData());
        }
        else {
            let highlightMatrix = magnetVel.getTransformToElement(cellView.container);
            // Add padding to the highlight element.
            const padding = options.padding;
            if (padding) {
                if (magnetBBox == null) {
                    magnetBBox = Util.bbox(magnetVel.node, true);
                }
                const cx = magnetBBox.x + magnetBBox.width / 2;
                const cy = magnetBBox.y + magnetBBox.height / 2;
                magnetBBox = Util.transformRectangle(magnetBBox, highlightMatrix);
                const width = Math.max(magnetBBox.width, 1);
                const height = Math.max(magnetBBox.height, 1);
                const sx = (width + padding) / width;
                const sy = (height + padding) / height;
                const paddingMatrix = createSVGMatrix({
                    a: sx,
                    b: 0,
                    c: 0,
                    d: sy,
                    e: cx - sx * cx,
                    f: cy - sy * cy,
                });
                highlightMatrix = highlightMatrix.multiply(paddingMatrix);
            }
            transform(path, highlightMatrix);
        }
        addClass(path, Config.prefix('highlight-stroke'));
        const cell = cellView.cell;
        const removeHandler = () => Private$2.removeHighlighter(id);
        cell.on('removed', removeHandler);
        if (cell.model) {
            cell.model.on('reseted', removeHandler);
        }
        cellView.container.appendChild(path);
        Private$2.setCache(id, path);
    },
    unhighlight(cellView, magnet, opt) {
        Private$2.removeHighlighter(Private$2.getHighlighterId(magnet, opt));
    },
};
var Private$2;
(function (Private) {
    function getHighlighterId(magnet, options) {
        ensureId(magnet);
        return magnet.id + JSON.stringify(options);
    }
    Private.getHighlighterId = getHighlighterId;
    const cache = {};
    function setCache(id, elem) {
        cache[id] = elem;
    }
    Private.setCache = setCache;
    function hasCache(id) {
        return cache[id] != null;
    }
    Private.hasCache = hasCache;
    function removeHighlighter(id) {
        const elem = cache[id];
        if (elem) {
            remove(elem);
            delete cache[id];
        }
    }
    Private.removeHighlighter = removeHighlighter;
})(Private$2 || (Private$2 = {}));

const highlighters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    className: className$1,
    opacity,
    stroke
}, Symbol.toStringTag, { value: 'Module' }));

var Highlighter;
(function (Highlighter) {
    function check(name, highlighter) {
        if (typeof highlighter.highlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
        }
        if (typeof highlighter.unhighlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
        }
    }
    Highlighter.check = check;
})(Highlighter || (Highlighter = {}));
(function (Highlighter) {
    Highlighter.presets = highlighters;
    Highlighter.registry = Registry.create({
        type: 'highlighter',
    });
    Highlighter.registry.register(Highlighter.presets, true);
})(Highlighter || (Highlighter = {}));

function normalizePoint$1(bbox, args = {}) {
    return new Point(normalizePercentage(args.x, bbox.width), normalizePercentage(args.y, bbox.height));
}
function toResult$1(point, angle, rawArgs) {
    return Object.assign({ angle, position: point.toJSON() }, rawArgs);
}

const absolute = (portsPositionArgs, elemBBox) => {
    return portsPositionArgs.map(({ x, y, angle }) => toResult$1(normalizePoint$1(elemBBox, { x, y }), angle || 0));
};

const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 20;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);
};
const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {
        return index * stepAngle;
    });
};
function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
    const center = elemBBox.getCenter();
    const start = elemBBox.getTopCenter();
    const ratio = elemBBox.width / elemBBox.height;
    const ellipse = Ellipse.fromRect(elemBBox);
    const count = portsPositionArgs.length;
    return portsPositionArgs.map((item, index) => {
        const angle = startAngle + stepFn(index, count);
        const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);
        const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;
        if (item.dx || item.dy) {
            p.translate(item.dx || 0, item.dy || 0);
        }
        if (item.dr) {
            p.move(center, item.dr);
        }
        return toResult$1(p.round(), theta, item);
    });
}

var __rest$h = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const line = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const start = normalizePoint$1(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
    const end = normalizePoint$1(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
    return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
const left$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
const right$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
const top$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
const bottom$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};
function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
    const line = new Line(p1, p2);
    const length = portsPositionArgs.length;
    return portsPositionArgs.map((_a, index) => {
        var { strict } = _a, offset = __rest$h(_a, ["strict"]);
        const ratio = strict || groupPositionArgs.strict
            ? (index + 1) / (length + 1)
            : (index + 0.5) / length;
        const p = line.pointAt(ratio);
        if (offset.dx || offset.dy) {
            p.translate(offset.dx || 0, offset.dy || 0);
        }
        return toResult$1(p.round(), 0, offset);
    });
}

const layouts$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    absolute,
    bottom: bottom$2,
    ellipse,
    ellipseSpread,
    left: left$2,
    line,
    right: right$2,
    top: top$2
}, Symbol.toStringTag, { value: 'Module' }));

var PortLayout;
(function (PortLayout) {
    PortLayout.presets = layouts$1;
    PortLayout.registry = Registry.create({
        type: 'port layout',
    });
    PortLayout.registry.register(PortLayout.presets, true);
})(PortLayout || (PortLayout = {}));

const defaults$2 = {
    position: { x: 0, y: 0 },
    angle: 0,
    attrs: {
        '.': {
            y: '0',
            'text-anchor': 'start',
        },
    },
};
function toResult(preset, args) {
    const { x, y, angle, attrs } = args || {};
    return defaultsDeep$1({}, { angle, attrs, position: { x, y } }, preset, defaults$2);
}

const manual = (portPosition, elemBBox, args) => toResult({ position: elemBBox.getTopLeft() }, args);
const left$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: -15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'end' } },
}, args);
const right$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'start' } },
}, args);
const top$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 0, y: -15 },
    attrs: { '.': { 'text-anchor': 'middle' } },
}, args);
const bottom$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 0, y: 15 },
    attrs: { '.': { y: '.6em', 'text-anchor': 'middle' } },
}, args);

const outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
const outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
const inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
const insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);
function outsideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else if (angle < bboxAngles[0]) {
        y = '0';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return toResult({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function insideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else if (angle < bboxAngles[0]) {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else {
        y = '0em';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return toResult({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function getBBoxAngles(elemBBox) {
    const center = elemBBox.getCenter();
    const tl = center.theta(elemBBox.getTopLeft());
    const bl = center.theta(elemBBox.getBottomLeft());
    const br = center.theta(elemBBox.getBottomRight());
    const tr = center.theta(elemBBox.getTopRight());
    return [tl, tr, br, bl];
}

const radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
const radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
function radialLayout(portCenterOffset, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 20;
    const origin = new Point(0, 0);
    const angle = -portCenterOffset.theta(origin);
    const pos = portCenterOffset
        .clone()
        .move(origin, offset)
        .diff(portCenterOffset)
        .round();
    let y = '.3em';
    let textAnchor;
    let orientAngle = angle;
    if ((angle + 90) % 180 === 0) {
        textAnchor = autoOrient ? 'end' : 'middle';
        if (!autoOrient && angle === -270) {
            y = '0em';
        }
    }
    else if (angle > -270 && angle < -90) {
        textAnchor = 'start';
        orientAngle = angle - 180;
    }
    else {
        textAnchor = 'end';
    }
    return toResult({
        position: pos.round().toJSON(),
        angle: autoOrient ? orientAngle : 0,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}

const layouts = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    bottom: bottom$1,
    inside,
    insideOriented,
    left: left$1,
    manual,
    outside,
    outsideOriented,
    radial,
    radialOriented,
    right: right$1,
    top: top$1
}, Symbol.toStringTag, { value: 'Module' }));

var PortLabelLayout;
(function (PortLabelLayout) {
    PortLabelLayout.presets = layouts;
    PortLabelLayout.registry = Registry.create({
        type: 'port label layout',
    });
    PortLabelLayout.registry.register(PortLabelLayout.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));

var __decorate$i = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class View extends Basecoat {
    get priority() {
        return 2;
    }
    /** If need remove `this.container` DOM */
    get disposeContainer() {
        return true;
    }
    constructor() {
        super();
        this.cid = Private$1.uniqueId();
        View.views[this.cid] = this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options) {
        return 0;
    }
    empty(elem = this.container) {
        empty(elem);
        return this;
    }
    unmount(elem = this.container) {
        remove(elem);
        return this;
    }
    remove(elem = this.container) {
        if (elem === this.container) {
            this.removeEventListeners(document);
            this.onRemove();
            delete View.views[this.cid];
            if (this.disposeContainer) {
                this.unmount(elem);
            }
        }
        else {
            this.unmount(elem);
        }
        return this;
    }
    onRemove() { }
    setClass(className, elem = this.container) {
        elem.classList.value = Array.isArray(className)
            ? className.join(' ')
            : className;
    }
    addClass(className, elem = this.container) {
        addClass(elem, Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    removeClass(className, elem = this.container) {
        removeClass(elem, Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    setStyle(style, elem = this.container) {
        css(elem, style);
        return this;
    }
    setAttrs(attrs, elem = this.container) {
        if (attrs != null && elem != null) {
            attr(elem, attrs);
        }
        return this;
    }
    /**
     * Returns the value of the specified attribute of `node`.
     *
     * If the node does not set a value for attribute, start recursing up
     * the DOM tree from node to lookup for attribute at the ancestors of
     * node. If the recursion reaches CellView's root node and attribute
     * is not found even there, return `null`.
     */
    findAttr(attrName, elem = this.container) {
        let current = elem;
        while (current && current.nodeType === 1) {
            const value = current.getAttribute(attrName);
            if (value != null) {
                return value;
            }
            if (current === this.container) {
                return null;
            }
            current = current.parentNode;
        }
        return null;
    }
    find(selector, rootElem = this.container, selectors = this.selectors) {
        return View.find(selector, rootElem, selectors).elems;
    }
    findOne(selector, rootElem = this.container, selectors = this.selectors) {
        const nodes = this.find(selector, rootElem, selectors);
        return nodes.length > 0 ? nodes[0] : null;
    }
    findByAttr(attrName, elem = this.container) {
        let node = elem;
        while (node && node.getAttribute) {
            const val = node.getAttribute(attrName);
            if ((val != null || node === this.container) && val !== 'false') {
                return node;
            }
            node = node.parentNode;
        }
        // If the overall cell has set `magnet === false`, then returns
        // `null` to announce there is no magnet found for this cell.
        // This is especially useful to set on cells that have 'ports'.
        // In this case, only the ports have set `magnet === true` and the
        // overall element has `magnet === false`.
        return null;
    }
    getSelector(elem, prevSelector) {
        let selector;
        if (elem === this.container) {
            if (typeof prevSelector === 'string') {
                selector = `> ${prevSelector}`;
            }
            return selector;
        }
        if (elem) {
            const nth = index(elem) + 1;
            selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;
            if (prevSelector) {
                selector += ` > ${prevSelector}`;
            }
            selector = this.getSelector(elem.parentNode, selector);
        }
        return selector;
    }
    prefixClassName(className) {
        return Config.prefix(className);
    }
    delegateEvents(events, append) {
        if (events == null) {
            return this;
        }
        if (!append) {
            this.undelegateEvents();
        }
        const splitter = /^(\S+)\s*(.*)$/;
        Object.keys(events).forEach((key) => {
            const match = key.match(splitter);
            if (match == null) {
                return;
            }
            const method = this.getEventHandler(events[key]);
            if (typeof method === 'function') {
                this.delegateEvent(match[1], match[2], method);
            }
        });
        return this;
    }
    undelegateEvents() {
        Event.off(this.container, this.getEventNamespace());
        return this;
    }
    delegateDocumentEvents(events, data) {
        this.addEventListeners(document, events, data);
        return this;
    }
    undelegateDocumentEvents() {
        this.removeEventListeners(document);
        return this;
    }
    delegateEvent(eventName, selector, listener) {
        Event.on(this.container, eventName + this.getEventNamespace(), selector, listener);
        return this;
    }
    undelegateEvent(eventName, selector, listener) {
        const name = eventName + this.getEventNamespace();
        if (selector == null) {
            Event.off(this.container, name);
        }
        else if (typeof selector === 'string') {
            Event.off(this.container, name, selector, listener);
        }
        else {
            Event.off(this.container, name, selector);
        }
        return this;
    }
    addEventListeners(elem, events, data) {
        if (events == null) {
            return this;
        }
        const ns = this.getEventNamespace();
        Object.keys(events).forEach((eventName) => {
            const method = this.getEventHandler(events[eventName]);
            if (typeof method === 'function') {
                Event.on(elem, eventName + ns, data, method);
            }
        });
        return this;
    }
    removeEventListeners(elem) {
        if (elem != null) {
            Event.off(elem, this.getEventNamespace());
        }
        return this;
    }
    getEventNamespace() {
        return `.${Config.prefixCls}-event-${this.cid}`;
    }
    // eslint-disable-next-line
    getEventHandler(handler) {
        // eslint-disable-next-line
        let method;
        if (typeof handler === 'string') {
            const fn = this[handler];
            if (typeof fn === 'function') {
                method = (...args) => fn.call(this, ...args);
            }
        }
        else {
            method = (...args) => handler.call(this, ...args);
        }
        return method;
    }
    getEventTarget(e, options = {}) {
        // Touchmove/Touchend event's target is not reflecting the element
        // under the coordinates as mousemove does.
        // It holds the element when a touchstart triggered.
        const { target, type, clientX = 0, clientY = 0 } = e;
        if (options.fromPoint || type === 'touchmove' || type === 'touchend') {
            return document.elementFromPoint(clientX, clientY);
        }
        return target;
    }
    stopPropagation(e) {
        this.setEventData(e, { propagationStopped: true });
        return this;
    }
    isPropagationStopped(e) {
        return this.getEventData(e).propagationStopped === true;
    }
    getEventData(e) {
        return this.eventData(e);
    }
    setEventData(e, data) {
        return this.eventData(e, data);
    }
    eventData(e, data) {
        if (e == null) {
            throw new TypeError('Event object required');
        }
        let currentData = e.data;
        const key = `__${this.cid}__`;
        // get
        if (data == null) {
            if (currentData == null) {
                return {};
            }
            return currentData[key] || {};
        }
        // set
        if (currentData == null) {
            currentData = e.data = {};
        }
        if (currentData[key] == null) {
            currentData[key] = Object.assign({}, data);
        }
        else {
            currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);
        }
        return currentData[key];
    }
    normalizeEvent(evt) {
        return View.normalizeEvent(evt);
    }
    dispose() {
        this.remove();
    }
}
__decorate$i([
    View.dispose()
], View.prototype, "dispose", null);
(function (View) {
    function createElement(tagName, isSvgElement) {
        return isSvgElement
            ? createSvgElement(tagName || 'g')
            : createElementNS(tagName || 'div');
    }
    View.createElement = createElement;
    function find(selector, rootElem, selectors) {
        if (!selector || selector === '.') {
            return { elems: [rootElem] };
        }
        if (selectors) {
            const nodes = selectors[selector];
            if (nodes) {
                return { elems: Array.isArray(nodes) ? nodes : [nodes] };
            }
        }
        {
            const validSelector = selector.includes('>')
                ? `:scope ${selector}`
                : selector;
            return {
                isCSSSelector: true,
                // $(rootElem).find(selector).toArray() as Element[]
                elems: Array.prototype.slice.call(rootElem.querySelectorAll(validSelector)),
            };
        }
    }
    View.find = find;
    function normalizeEvent(evt) {
        let normalizedEvent = evt;
        const originalEvent = evt.originalEvent;
        const touchEvt = originalEvent &&
            originalEvent.changedTouches &&
            originalEvent.changedTouches[0];
        if (touchEvt) {
            // eslint-disable-next-line no-restricted-syntax
            for (const key in evt) {
                if (touchEvt[key] === undefined) {
                    touchEvt[key] = evt[key];
                }
            }
            normalizedEvent = touchEvt;
        }
        return normalizedEvent;
    }
    View.normalizeEvent = normalizeEvent;
})(View || (View = {}));
(function (View) {
    View.views = {};
    function getView(cid) {
        return View.views[cid] || null;
    }
    View.getView = getView;
})(View || (View = {}));
var Private$1;
(function (Private) {
    let counter = 0;
    function uniqueId() {
        const id = `v${counter}`;
        counter += 1;
        return id;
    }
    Private.uniqueId = uniqueId;
})(Private$1 || (Private$1 = {}));

class Cache {
    constructor(view) {
        this.view = view;
        this.clean();
    }
    clean() {
        if (this.elemCache) {
            this.elemCache.dispose();
        }
        this.elemCache = new Dictionary();
        this.pathCache = {};
    }
    get(elem) {
        const cache = this.elemCache;
        if (!cache.has(elem)) {
            this.elemCache.set(elem, {});
        }
        return this.elemCache.get(elem);
    }
    getData(elem) {
        const meta = this.get(elem);
        if (!meta.data) {
            meta.data = {};
        }
        return meta.data;
    }
    getMatrix(elem) {
        const meta = this.get(elem);
        if (meta.matrix == null) {
            const target = this.view.container;
            meta.matrix = getTransformToParentElement(elem, target);
        }
        return createSVGMatrix(meta.matrix);
    }
    getShape(elem) {
        const meta = this.get(elem);
        if (meta.shape == null) {
            meta.shape = Util.toGeometryShape(elem);
        }
        return meta.shape.clone();
    }
    getBoundingRect(elem) {
        const meta = this.get(elem);
        if (meta.boundingRect == null) {
            meta.boundingRect = Util.getBBoxV2(elem);
        }
        return meta.boundingRect.clone();
    }
}

// eslint-disable-next-line
var Markup;
(function (Markup) {
    function isJSONMarkup(markup) {
        return markup != null && !isStringMarkup(markup);
    }
    Markup.isJSONMarkup = isJSONMarkup;
    function isStringMarkup(markup) {
        return markup != null && typeof markup === 'string';
    }
    Markup.isStringMarkup = isStringMarkup;
    function clone(markup) {
        return markup == null || isStringMarkup(markup)
            ? markup
            : cloneDeep(markup);
    }
    Markup.clone = clone;
    /**
     * Removes blank space in markup to prevent create empty text node.
     */
    function sanitize(markup) {
        return `${markup}`
            .trim()
            .replace(/[\r|\n]/g, ' ')
            .replace(/>\s+</g, '><');
    }
    Markup.sanitize = sanitize;
    function parseJSONMarkup(markup, options = { ns: ns.svg }) {
        const fragment = document.createDocumentFragment();
        const groups = {};
        const selectors = {};
        const queue = [
            {
                markup: Array.isArray(markup) ? markup : [markup],
                parent: fragment,
                ns: options.ns,
            },
        ];
        while (queue.length > 0) {
            const item = queue.pop();
            let ns$1 = item.ns || ns.svg;
            const defines = item.markup;
            const parentNode = item.parent;
            defines.forEach((define) => {
                // tagName
                const tagName = define.tagName;
                if (!tagName) {
                    throw new TypeError('Invalid tagName');
                }
                // ns
                if (define.ns) {
                    ns$1 = define.ns;
                }
                const node = ns$1
                    ? createElementNS(tagName, ns$1)
                    : createElement(tagName);
                // attrs
                const attrs = define.attrs;
                if (attrs) {
                    attr(node, kebablizeAttrs(attrs));
                }
                // style
                const style = define.style;
                if (style) {
                    css(node, style);
                }
                // classname
                const className = define.className;
                if (className != null) {
                    node.setAttribute('class', Array.isArray(className) ? className.join(' ') : className);
                }
                // textContent
                if (define.textContent) {
                    node.textContent = define.textContent;
                }
                // selector
                const selector = define.selector;
                if (selector != null) {
                    if (selectors[selector]) {
                        throw new TypeError('Selector must be unique');
                    }
                    selectors[selector] = node;
                }
                // group
                if (define.groupSelector) {
                    let nodeGroups = define.groupSelector;
                    if (!Array.isArray(nodeGroups)) {
                        nodeGroups = [nodeGroups];
                    }
                    nodeGroups.forEach((name) => {
                        if (!groups[name]) {
                            groups[name] = [];
                        }
                        groups[name].push(node);
                    });
                }
                parentNode.appendChild(node);
                // children
                const children = define.children;
                if (Array.isArray(children)) {
                    queue.push({ ns: ns$1, markup: children, parent: node });
                }
            });
        }
        Object.keys(groups).forEach((groupName) => {
            if (selectors[groupName]) {
                throw new Error('Ambiguous group selector');
            }
            selectors[groupName] = groups[groupName];
        });
        return { fragment, selectors, groups };
    }
    Markup.parseJSONMarkup = parseJSONMarkup;
    function createContainer(firstChild) {
        return firstChild instanceof SVGElement
            ? createSvgElement('g')
            : createElement('div');
    }
    function renderMarkup(markup) {
        if (isStringMarkup(markup)) {
            const nodes = Vector.createVectors(markup);
            const count = nodes.length;
            if (count === 1) {
                return {
                    elem: nodes[0].node,
                };
            }
            if (count > 1) {
                const elem = createContainer(nodes[0].node);
                nodes.forEach((node) => {
                    elem.appendChild(node.node);
                });
                return { elem };
            }
            return {};
        }
        const result = parseJSONMarkup(markup);
        const fragment = result.fragment;
        let elem = null;
        if (fragment.childNodes.length > 1) {
            elem = createContainer(fragment.firstChild);
            elem.appendChild(fragment);
        }
        else {
            elem = fragment.firstChild;
        }
        return { elem, selectors: result.selectors };
    }
    Markup.renderMarkup = renderMarkup;
    function parseLabelStringMarkup(markup) {
        const children = Vector.createVectors(markup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    Markup.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getSelector(elem, stop, prev) {
        if (elem != null) {
            let selector;
            const tagName = elem.tagName.toLowerCase();
            if (elem === stop) {
                if (typeof prev === 'string') {
                    selector = `> ${tagName} > ${prev}`;
                }
                else {
                    selector = `> ${tagName}`;
                }
                return selector;
            }
            const parent = elem.parentNode;
            if (parent && parent.childNodes.length > 1) {
                const nth = index(elem) + 1;
                selector = `${tagName}:nth-child(${nth})`;
            }
            else {
                selector = tagName;
            }
            if (prev) {
                selector += ` > ${prev}`;
            }
            return getSelector(elem.parentNode, stop, selector);
        }
        return prev;
    }
    Markup.getSelector = getSelector;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getPortContainerMarkup() {
        return 'g';
    }
    Markup.getPortContainerMarkup = getPortContainerMarkup;
    function getPortMarkup() {
        return {
            tagName: 'circle',
            selector: 'circle',
            attrs: {
                r: 10,
                fill: '#FFFFFF',
                stroke: '#000000',
            },
        };
    }
    Markup.getPortMarkup = getPortMarkup;
    function getPortLabelMarkup() {
        return {
            tagName: 'text',
            selector: 'text',
            attrs: {
                fill: '#000000',
            },
        };
    }
    Markup.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getEdgeMarkup() {
        return [
            {
                tagName: 'path',
                selector: 'wrap',
                groupSelector: 'lines',
                attrs: {
                    fill: 'none',
                    cursor: 'pointer',
                    stroke: 'transparent',
                    strokeLinecap: 'round',
                },
            },
            {
                tagName: 'path',
                selector: 'line',
                groupSelector: 'lines',
                attrs: {
                    fill: 'none',
                    pointerEvents: 'none',
                },
            },
        ];
    }
    Markup.getEdgeMarkup = getEdgeMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getForeignObjectMarkup(bare = false) {
        return {
            tagName: 'foreignObject',
            selector: 'fo',
            children: [
                {
                    ns: ns.xhtml,
                    tagName: 'body',
                    selector: 'foBody',
                    attrs: {
                        xmlns: ns.xhtml,
                    },
                    style: {
                        width: '100%',
                        height: '100%',
                        background: 'transparent',
                    },
                    children: bare
                        ? []
                        : [
                            {
                                tagName: 'div',
                                selector: 'foContent',
                                style: {
                                    width: '100%',
                                    height: '100%',
                                },
                            },
                        ],
                },
            ],
        };
    }
    Markup.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));

class AttrManager {
    constructor(view) {
        this.view = view;
    }
    get cell() {
        return this.view.cell;
    }
    getDefinition(attrName) {
        return this.cell.getAttrDefinition(attrName);
    }
    processAttrs(elem, raw) {
        let normal;
        let set;
        let offset;
        let position;
        const specials = [];
        // divide the attributes between normal and special
        Object.keys(raw).forEach((name) => {
            const val = raw[name];
            const definition = this.getDefinition(name);
            const isValid = call$1(Attr.isValidDefinition, this.view, definition, val, {
                elem,
                attrs: raw,
                cell: this.cell,
                view: this.view,
            });
            if (definition && isValid) {
                if (typeof definition === 'string') {
                    if (normal == null) {
                        normal = {};
                    }
                    normal[definition] = val;
                }
                else if (val !== null) {
                    specials.push({ name, definition });
                }
            }
            else {
                if (normal == null) {
                    normal = {};
                }
                const normalName = CASE_SENSITIVE_ATTR.includes(name)
                    ? name
                    : kebabCase(name);
                normal[normalName] = val;
            }
        });
        specials.forEach(({ name, definition }) => {
            const val = raw[name];
            const setDefine = definition;
            if (typeof setDefine.set === 'function') {
                if (set == null) {
                    set = {};
                }
                set[name] = val;
            }
            const offsetDefine = definition;
            if (typeof offsetDefine.offset === 'function') {
                if (offset == null) {
                    offset = {};
                }
                offset[name] = val;
            }
            const positionDefine = definition;
            if (typeof positionDefine.position === 'function') {
                if (position == null) {
                    position = {};
                }
                position[name] = val;
            }
        });
        return {
            raw,
            normal,
            set,
            offset,
            position,
        };
    }
    mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
        allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
        allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
        allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);
        // Handle also the special transform property.
        const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;
        if (transform != null && roProcessedAttrs.normal) {
            roProcessedAttrs.normal.transform = transform;
        }
        allProcessedAttrs.normal = roProcessedAttrs.normal;
    }
    findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
        const merge = [];
        const result = new Dictionary();
        Object.keys(cellAttrs).forEach((selector) => {
            const attrs = cellAttrs[selector];
            if (!isPlainObject(attrs)) {
                return;
            }
            const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);
            selectorCache[selector] = elems;
            for (let i = 0, l = elems.length; i < l; i += 1) {
                const elem = elems[i];
                const unique = selectors && selectors[selector] === elem;
                const prev = result.get(elem);
                if (prev) {
                    if (!prev.array) {
                        merge.push(elem);
                        prev.array = true;
                        prev.attrs = [prev.attrs];
                        prev.priority = [prev.priority];
                    }
                    const attributes = prev.attrs;
                    const selectedLength = prev.priority;
                    if (unique) {
                        // node referenced by `selector`
                        attributes.unshift(attrs);
                        selectedLength.unshift(-1);
                    }
                    else {
                        // node referenced by `groupSelector` or CSSSelector
                        const sortIndex = sortedIndex(selectedLength, isCSSSelector ? -1 : l);
                        attributes.splice(sortIndex, 0, attrs);
                        selectedLength.splice(sortIndex, 0, l);
                    }
                }
                else {
                    result.set(elem, {
                        elem,
                        attrs,
                        priority: unique ? -1 : l,
                        array: false,
                    });
                }
            }
        });
        merge.forEach((node) => {
            const item = result.get(node);
            const arr = item.attrs;
            item.attrs = arr.reduceRight((memo, attrs) => merge$1(memo, attrs), {});
        });
        return result;
    }
    updateRelativeAttrs(elem, processedAttrs, refBBox) {
        const rawAttrs = processedAttrs.raw || {};
        let nodeAttrs = processedAttrs.normal || {};
        const setAttrs = processedAttrs.set;
        const positionAttrs = processedAttrs.position;
        const offsetAttrs = processedAttrs.offset;
        const getOptions = () => ({
            elem,
            cell: this.cell,
            view: this.view,
            attrs: rawAttrs,
            refBBox: refBBox.clone(),
        });
        if (setAttrs != null) {
            Object.keys(setAttrs).forEach((name) => {
                const val = setAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ret = call$1(def.set, this.view, val, getOptions());
                    if (typeof ret === 'object') {
                        nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
                    }
                    else if (ret != null) {
                        nodeAttrs[name] = ret;
                    }
                }
            });
        }
        if (elem instanceof HTMLElement) {
            // TODO: setting the `transform` attribute on HTMLElements
            // via `node.style.transform = 'matrix(...)';` would introduce
            // a breaking change (e.g. basic.TextBlock).
            this.view.setAttrs(nodeAttrs, elem);
            return;
        }
        // The final translation of the subelement.
        const nodeTransform = nodeAttrs.transform;
        const transform = nodeTransform ? `${nodeTransform}` : null;
        const nodeMatrix = transformStringToMatrix(transform);
        const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);
        if (nodeTransform) {
            delete nodeAttrs.transform;
            nodeMatrix.e = 0;
            nodeMatrix.f = 0;
        }
        let positioned = false;
        if (positionAttrs != null) {
            Object.keys(positionAttrs).forEach((name) => {
                const val = positionAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ts = call$1(def.position, this.view, val, getOptions());
                    if (ts != null) {
                        positioned = true;
                        nodePosition.translate(Point.create(ts));
                    }
                }
            });
        }
        // The node bounding box could depend on the `size`
        // set from the previous loop.
        this.view.setAttrs(nodeAttrs, elem);
        let offseted = false;
        if (offsetAttrs != null) {
            // Check if the node is visible
            const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
                const nodeBBox = Util.transformRectangle(nodeBoundingRect, nodeMatrix);
                Object.keys(offsetAttrs).forEach((name) => {
                    const val = offsetAttrs[name];
                    const def = this.getDefinition(name);
                    if (def != null) {
                        const ts = call$1(def.offset, this.view, val, {
                            elem,
                            cell: this.cell,
                            view: this.view,
                            attrs: rawAttrs,
                            refBBox: nodeBBox,
                        });
                        if (ts != null) {
                            offseted = true;
                            nodePosition.translate(Point.create(ts));
                        }
                    }
                });
            }
        }
        if (nodeTransform != null || positioned || offseted) {
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            elem.setAttribute('transform', matrixToTransformString(nodeMatrix));
        }
    }
    update(rootNode, attrs, options) {
        const selectorCache = {};
        const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);
        // `nodesAttrs` are different from all attributes, when
        // rendering only attributes sent to this method.
        const nodesAllAttrs = options.attrs
            ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)
            : nodesAttrs;
        const specialItems = [];
        nodesAttrs.each((data) => {
            const node = data.elem;
            const nodeAttrs = data.attrs;
            const processed = this.processAttrs(node, nodeAttrs);
            if (processed.set == null &&
                processed.position == null &&
                processed.offset == null) {
                this.view.setAttrs(processed.normal, node);
            }
            else {
                const data = nodesAllAttrs.get(node);
                const nodeAllAttrs = data ? data.attrs : null;
                const refSelector = nodeAllAttrs && nodeAttrs.ref == null
                    ? nodeAllAttrs.ref
                    : nodeAttrs.ref;
                let refNode;
                if (refSelector) {
                    refNode = (selectorCache[refSelector] ||
                        this.view.find(refSelector, rootNode, options.selectors))[0];
                    if (!refNode) {
                        throw new Error(`"${refSelector}" reference does not exist.`);
                    }
                }
                else {
                    refNode = null;
                }
                const item = {
                    node,
                    refNode,
                    attributes: nodeAllAttrs,
                    processedAttributes: processed,
                };
                // If an element in the list is positioned relative to this one, then
                // we want to insert this one before it in the list.
                const index = specialItems.findIndex((item) => item.refNode === node);
                if (index > -1) {
                    specialItems.splice(index, 0, item);
                }
                else {
                    specialItems.push(item);
                }
            }
        });
        const bboxCache = new Dictionary();
        let rotatableMatrix;
        specialItems.forEach((item) => {
            const node = item.node;
            const refNode = item.refNode;
            let unrotatedRefBBox;
            const isRefNodeRotatable = refNode != null &&
                options.rotatableNode != null &&
                contains(options.rotatableNode, refNode);
            // Find the reference element bounding box. If no reference was
            // provided, we use the optional bounding box.
            if (refNode) {
                unrotatedRefBBox = bboxCache.get(refNode);
            }
            if (!unrotatedRefBBox) {
                const target = (isRefNodeRotatable ? options.rotatableNode : rootNode);
                unrotatedRefBBox = refNode
                    ? Util.getBBox(refNode, { target })
                    : options.rootBBox;
                if (refNode) {
                    bboxCache.set(refNode, unrotatedRefBBox);
                }
            }
            let processedAttrs;
            if (options.attrs && item.attributes) {
                // If there was a special attribute affecting the position amongst
                // passed-in attributes we have to merge it with the rest of the
                // element's attributes as they are necessary to update the position
                // relatively (i.e `ref-x` && 'ref-dx').
                processedAttrs = this.processAttrs(node, item.attributes);
                this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
            }
            else {
                processedAttrs = item.processedAttributes;
            }
            let refBBox = unrotatedRefBBox;
            if (isRefNodeRotatable &&
                options.rotatableNode != null &&
                !options.rotatableNode.contains(node)) {
                // If the referenced node is inside the rotatable group while the
                // updated node is outside, we need to take the rotatable node
                // transformation into account.
                if (!rotatableMatrix) {
                    rotatableMatrix = transformStringToMatrix(attr(options.rotatableNode, 'transform'));
                }
                refBBox = Util.transformRectangle(unrotatedRefBBox, rotatableMatrix);
            }
            this.updateRelativeAttrs(node, processedAttrs, refBBox);
        });
    }
}

/* eslint-disable no-bitwise */
class FlagManager {
    get cell() {
        return this.view.cell;
    }
    constructor(view, actions, bootstrap = []) {
        this.view = view;
        const flags = {};
        const attrs = {};
        let shift = 0;
        Object.keys(actions).forEach((attr) => {
            let labels = actions[attr];
            if (!Array.isArray(labels)) {
                labels = [labels];
            }
            labels.forEach((label) => {
                let flag = flags[label];
                if (!flag) {
                    shift += 1;
                    flag = flags[label] = 1 << shift;
                }
                attrs[attr] |= flag;
            });
        });
        let labels = bootstrap;
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        labels.forEach((label) => {
            if (!flags[label]) {
                shift += 1;
                flags[label] = 1 << shift;
            }
        });
        // 26 - 30 are reserved for paper flags
        // 31+ overflows maximal number
        if (shift > 25) {
            throw new Error('Maximum number of flags exceeded.');
        }
        this.flags = flags;
        this.attrs = attrs;
        this.bootstrap = bootstrap;
    }
    getFlag(label) {
        const flags = this.flags;
        if (flags == null) {
            return 0;
        }
        if (Array.isArray(label)) {
            return label.reduce((memo, key) => memo | flags[key], 0);
        }
        return flags[label] | 0;
    }
    hasAction(flag, label) {
        return flag & this.getFlag(label);
    }
    removeAction(flag, label) {
        return flag ^ (flag & this.getFlag(label));
    }
    getBootstrapFlag() {
        return this.getFlag(this.bootstrap);
    }
    getChangedFlag() {
        let flag = 0;
        if (!this.attrs) {
            return flag;
        }
        Object.keys(this.attrs).forEach((attr) => {
            if (this.cell.hasChanged(attr)) {
                flag |= this.attrs[attr];
            }
        });
        return flag;
    }
}

var __decorate$h = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$g = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class CellView extends View {
    static getDefaults() {
        return this.defaults;
    }
    static config(options) {
        this.defaults = this.getOptions(options);
    }
    static getOptions(options) {
        const mergeActions = (arr1, arr2) => {
            if (arr2 != null) {
                return uniq([
                    ...(Array.isArray(arr1) ? arr1 : [arr1]),
                    ...(Array.isArray(arr2) ? arr2 : [arr2]),
                ]);
            }
            return Array.isArray(arr1) ? [...arr1] : [arr1];
        };
        const ret = cloneDeep(this.getDefaults());
        const { bootstrap, actions, events, documentEvents } = options, others = __rest$g(options, ["bootstrap", "actions", "events", "documentEvents"]);
        if (bootstrap) {
            ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
        }
        if (actions) {
            Object.entries(actions).forEach(([key, val]) => {
                const raw = ret.actions[key];
                if (val && raw) {
                    ret.actions[key] = mergeActions(raw, val);
                }
                else if (val) {
                    ret.actions[key] = mergeActions(val);
                }
            });
        }
        if (events) {
            ret.events = Object.assign(Object.assign({}, ret.events), events);
        }
        if (options.documentEvents) {
            ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
        }
        return merge$1(ret, others);
    }
    get [Symbol.toStringTag]() {
        return CellView.toStringTag;
    }
    constructor(cell, options = {}) {
        super();
        this.cell = cell;
        this.options = this.ensureOptions(options);
        this.graph = this.options.graph;
        this.attr = new AttrManager(this);
        this.flag = new FlagManager(this, this.options.actions, this.options.bootstrap);
        this.cache = new Cache(this);
        this.setContainer(this.ensureContainer());
        this.setup();
        this.init();
    }
    init() { }
    onRemove() {
        this.removeTools();
    }
    get priority() {
        return this.options.priority;
    }
    get rootSelector() {
        return this.options.rootSelector;
    }
    getConstructor() {
        return this.constructor;
    }
    ensureOptions(options) {
        return this.getConstructor().getOptions(options);
    }
    getContainerTagName() {
        return this.options.isSvgElement ? 'g' : 'div';
    }
    getContainerStyle() { }
    getContainerAttrs() {
        return {
            'data-cell-id': this.cell.id,
            'data-shape': this.cell.shape,
        };
    }
    getContainerClassName() {
        return this.prefixClassName('cell');
    }
    ensureContainer() {
        return View.createElement(this.getContainerTagName(), this.options.isSvgElement);
    }
    setContainer(container) {
        if (this.container !== container) {
            this.undelegateEvents();
            this.container = container;
            if (this.options.events != null) {
                this.delegateEvents(this.options.events);
            }
            const attrs = this.getContainerAttrs();
            if (attrs != null) {
                this.setAttrs(attrs, container);
            }
            const style = this.getContainerStyle();
            if (style != null) {
                this.setStyle(style, container);
            }
            const className = this.getContainerClassName();
            if (className != null) {
                this.addClass(className, container);
            }
        }
        return this;
    }
    isNodeView() {
        return false;
    }
    isEdgeView() {
        return false;
    }
    render() {
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options = {}) {
        return 0;
    }
    getBootstrapFlag() {
        return this.flag.getBootstrapFlag();
    }
    getFlag(actions) {
        return this.flag.getFlag(actions);
    }
    hasAction(flag, actions) {
        return this.flag.hasAction(flag, actions);
    }
    removeAction(flag, actions) {
        return this.flag.removeAction(flag, actions);
    }
    handleAction(flag, action, handle, additionalRemovedActions) {
        if (this.hasAction(flag, action)) {
            handle();
            const removedFlags = [action];
            if (additionalRemovedActions) {
                if (typeof additionalRemovedActions === 'string') {
                    removedFlags.push(additionalRemovedActions);
                }
                else {
                    removedFlags.push(...additionalRemovedActions);
                }
            }
            return this.removeAction(flag, removedFlags);
        }
        return flag;
    }
    setup() {
        this.cell.on('changed', this.onCellChanged, this);
    }
    onCellChanged({ options }) {
        this.onAttrsChange(options);
    }
    onAttrsChange(options) {
        let flag = this.flag.getChangedFlag();
        if (options.updated || !flag) {
            return;
        }
        if (options.dirty && this.hasAction(flag, 'update')) {
            flag |= this.getFlag('render'); // eslint-disable-line no-bitwise
        }
        // tool changes should be sync render
        if (options.toolId) {
            options.async = false;
        }
        if (this.graph != null) {
            this.graph.renderer.requestViewUpdate(this, flag, options);
        }
    }
    parseJSONMarkup(markup, rootElem) {
        const result = Markup.parseJSONMarkup(markup);
        const selectors = result.selectors;
        const rootSelector = this.rootSelector;
        if (rootElem && rootSelector) {
            if (selectors[rootSelector]) {
                throw new Error('Invalid root selector');
            }
            selectors[rootSelector] = rootElem;
        }
        return result;
    }
    can(feature) {
        let interacting = this.graph.options.interacting;
        if (typeof interacting === 'function') {
            interacting = call$1(interacting, this.graph, this);
        }
        if (typeof interacting === 'object') {
            let val = interacting[feature];
            if (typeof val === 'function') {
                val = call$1(val, this.graph, this);
            }
            return val !== false;
        }
        if (typeof interacting === 'boolean') {
            return interacting;
        }
        return false;
    }
    cleanCache() {
        this.cache.clean();
        return this;
    }
    getCache(elem) {
        return this.cache.get(elem);
    }
    getDataOfElement(elem) {
        return this.cache.getData(elem);
    }
    getMatrixOfElement(elem) {
        return this.cache.getMatrix(elem);
    }
    getShapeOfElement(elem) {
        return this.cache.getShape(elem);
    }
    getBoundingRectOfElement(elem) {
        return this.cache.getBoundingRect(elem);
    }
    getBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const rm = this.getRootRotatedMatrix();
        const tm = this.getRootTranslatedMatrix();
        return Util.transformRectangle(rect, tm.multiply(rm).multiply(matrix));
    }
    getUnrotatedBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const tm = this.getRootTranslatedMatrix();
        return Util.transformRectangle(rect, tm.multiply(matrix));
    }
    getBBox(options = {}) {
        let bbox;
        if (options.useCellGeometry) {
            const cell = this.cell;
            const angle = cell.isNode() ? cell.getAngle() : 0;
            bbox = cell.getBBox().bbox(angle);
        }
        else {
            bbox = this.getBBoxOfElement(this.container);
        }
        return this.graph.coord.localToGraphRect(bbox);
    }
    getRootTranslatedMatrix() {
        const cell = this.cell;
        const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 };
        return createSVGMatrix().translate(pos.x, pos.y);
    }
    getRootRotatedMatrix() {
        let matrix = createSVGMatrix();
        const cell = this.cell;
        const angle = cell.isNode() ? cell.getAngle() : 0;
        if (angle) {
            const bbox = cell.getBBox();
            const cx = bbox.width / 2;
            const cy = bbox.height / 2;
            matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
        }
        return matrix;
    }
    findMagnet(elem = this.container) {
        return this.findByAttr('magnet', elem);
    }
    updateAttrs(rootNode, attrs, options = {}) {
        if (options.rootBBox == null) {
            options.rootBBox = new Rectangle();
        }
        if (options.selectors == null) {
            options.selectors = this.selectors;
        }
        this.attr.update(rootNode, attrs, options);
    }
    isEdgeElement(magnet) {
        return this.cell.isEdge() && (magnet == null || magnet === this.container);
    }
    // #region highlight
    prepareHighlight(elem, options = {}) {
        const magnet = elem || this.container;
        options.partial = magnet === this.container;
        return magnet;
    }
    highlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:highlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isEdgeView()) {
            this.notify('edge:highlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isNodeView()) {
            this.notify('node:highlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    unhighlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:unhighlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isNodeView()) {
            this.notify('node:unhighlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isEdgeView()) {
            this.notify('edge:unhighlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    notifyUnhighlight(magnet, options) { }
    // #endregion
    getEdgeTerminal(magnet, x, y, edge, type) {
        const cell = this.cell;
        const portId = this.findAttr('port', magnet);
        const selector = magnet.getAttribute('data-selector');
        const terminal = { cell: cell.id };
        if (selector != null) {
            terminal.magnet = selector;
        }
        if (portId != null) {
            terminal.port = portId;
            if (cell.isNode()) {
                if (!cell.hasPort(portId) && selector == null) {
                    // port created via the `port` attribute (not API)
                    terminal.selector = this.getSelector(magnet);
                }
            }
        }
        else if (selector == null && this.container !== magnet) {
            terminal.selector = this.getSelector(magnet);
        }
        return terminal;
    }
    getMagnetFromEdgeTerminal(terminal) {
        const cell = this.cell;
        const root = this.container;
        const portId = terminal.port;
        let selector = terminal.magnet;
        let magnet;
        if (portId != null && cell.isNode() && cell.hasPort(portId)) {
            magnet = this.findPortElem(portId, selector) || root;
        }
        else {
            if (!selector) {
                selector = terminal.selector;
            }
            if (!selector && portId != null) {
                selector = `[port="${portId}"]`;
            }
            magnet = this.findOne(selector, root, this.selectors);
        }
        return magnet;
    }
    hasTools(name) {
        const tools = this.tools;
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    addTools(config) {
        this.removeTools();
        if (config) {
            if (!this.can('toolsAddable')) {
                return this;
            }
            const tools = ToolsView.isToolsView(config)
                ? config
                : new ToolsView(config);
            this.tools = tools;
            tools.config({ view: this });
            tools.mount();
        }
        return this;
    }
    updateTools(options = {}) {
        if (this.tools) {
            this.tools.update(options);
        }
        return this;
    }
    removeTools() {
        if (this.tools) {
            this.tools.remove();
            this.tools = null;
        }
        return this;
    }
    hideTools() {
        if (this.tools) {
            this.tools.hide();
        }
        return this;
    }
    showTools() {
        if (this.tools) {
            this.tools.show();
        }
        return this;
    }
    renderTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    notify(name, args) {
        this.trigger(name, args);
        this.graph.trigger(name, args);
        return this;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line @typescript-eslint/no-this-alias
        const cell = view.cell;
        if (x == null || y == null) {
            return { e, view, cell };
        }
        return { e, x, y, view, cell };
    }
    onClick(e, x, y) {
        this.notify('cell:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        this.notify('cell:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        this.notify('cell:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        if (this.cell.model) {
            this.cachedModelForMouseEvent = this.cell.model;
            this.cachedModelForMouseEvent.startBatch('mouse');
        }
        this.notify('cell:mousedown', this.getEventArgs(e, x, y));
    }
    onMouseUp(e, x, y) {
        this.notify('cell:mouseup', this.getEventArgs(e, x, y));
        if (this.cachedModelForMouseEvent) {
            this.cachedModelForMouseEvent.stopBatch('mouse', { cell: this.cell });
            this.cachedModelForMouseEvent = null;
        }
    }
    onMouseMove(e, x, y) {
        this.notify('cell:mousemove', this.getEventArgs(e, x, y));
    }
    onMouseOver(e) {
        this.notify('cell:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        this.notify('cell:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        this.notify('cell:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        this.notify('cell:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        this.notify('cell:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        this.notify('cell:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) { }
    onMagnetDblClick(e, magnet, x, y) { }
    onMagnetContextMenu(e, magnet, x, y) { }
    onLabelMouseDown(e, x, y) { }
    checkMouseleave(e) {
        const target = this.getEventTarget(e, { fromPoint: true });
        const view = this.graph.findViewByElem(target);
        if (view === this) {
            return;
        }
        // Leaving the current view
        this.onMouseLeave(e);
        if (!view) {
            return;
        }
        // Entering another view
        view.onMouseEnter(e);
    }
    dispose() {
        this.cell.off('changed', this.onCellChanged, this);
    }
}
CellView.defaults = {
    isSvgElement: true,
    rootSelector: 'root',
    priority: 0,
    bootstrap: [],
    actions: {},
};
__decorate$h([
    CellView.dispose()
], CellView.prototype, "dispose", null);
(function (CellView) {
    CellView.Flag = FlagManager;
    CellView.Attr = AttrManager;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.toStringTag = `X6.${CellView.name}`;
    function isCellView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof CellView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === CellView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function') {
            return true;
        }
        return false;
    }
    CellView.isCellView = isCellView;
})(CellView || (CellView = {}));
// decorators
// ----
(function (CellView) {
    function priority(value) {
        return function (ctor) {
            ctor.config({ priority: value });
        };
    }
    CellView.priority = priority;
    function bootstrap(actions) {
        return function (ctor) {
            ctor.config({ bootstrap: actions });
        };
    }
    CellView.bootstrap = bootstrap;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.registry = Registry.create({
        type: 'view',
    });
})(CellView || (CellView = {}));

class ToolsView extends View {
    get name() {
        return this.options.name;
    }
    get graph() {
        return this.cellView.graph;
    }
    get cell() {
        return this.cellView.cell;
    }
    get [Symbol.toStringTag]() {
        return ToolsView.toStringTag;
    }
    constructor(options = {}) {
        super();
        this.svgContainer = this.createContainer(true, options);
        this.htmlContainer = this.createContainer(false, options);
        this.config(options);
    }
    createContainer(svg, options) {
        const container = svg
            ? View.createElement('g', true)
            : View.createElement('div', false);
        addClass(container, this.prefixClassName('cell-tools'));
        if (options.className) {
            addClass(container, options.className);
        }
        return container;
    }
    config(options) {
        this.options = Object.assign(Object.assign({}, this.options), options);
        if (!CellView.isCellView(options.view) || options.view === this.cellView) {
            return this;
        }
        this.cellView = options.view;
        if (this.cell.isEdge()) {
            addClass(this.svgContainer, this.prefixClassName('edge-tools'));
            addClass(this.htmlContainer, this.prefixClassName('edge-tools'));
        }
        else if (this.cell.isNode()) {
            addClass(this.svgContainer, this.prefixClassName('node-tools'));
            addClass(this.htmlContainer, this.prefixClassName('node-tools'));
        }
        this.svgContainer.setAttribute('data-cell-id', this.cell.id);
        this.htmlContainer.setAttribute('data-cell-id', this.cell.id);
        if (this.name) {
            this.svgContainer.setAttribute('data-tools-name', this.name);
            this.htmlContainer.setAttribute('data-tools-name', this.name);
        }
        const tools = this.options.items;
        if (!Array.isArray(tools)) {
            return this;
        }
        this.tools = [];
        const normalizedTools = [];
        tools.forEach((meta) => {
            if (ToolsView.ToolItem.isToolItem(meta)) {
                if (meta.name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                if (name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
        });
        for (let i = 0; i < normalizedTools.length; i += 1) {
            const meta = normalizedTools[i];
            let tool;
            if (ToolsView.ToolItem.isToolItem(meta)) {
                tool = meta;
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                const args = typeof meta === 'object' ? meta.args || {} : {};
                if (name) {
                    if (this.cell.isNode()) {
                        const ctor = NodeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return NodeTool.registry.onNotFound(name);
                        }
                    }
                    else if (this.cell.isEdge()) {
                        const ctor = EdgeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return EdgeTool.registry.onNotFound(name);
                        }
                    }
                }
            }
            if (tool) {
                tool.config(this.cellView, this);
                tool.render();
                const container = tool.options.isSVGElement !== false
                    ? this.svgContainer
                    : this.htmlContainer;
                container.appendChild(tool.container);
                this.tools.push(tool);
            }
        }
        return this;
    }
    update(options = {}) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (options.toolId !== tool.cid && tool.isVisible()) {
                    tool.update();
                }
            });
        }
        return this;
    }
    focus(focusedTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (focusedTool === tool) {
                    tool.show();
                }
                else {
                    tool.hide();
                }
            });
        }
        return this;
    }
    blur(blurredTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (tool !== blurredTool && !tool.isVisible()) {
                    tool.show();
                    tool.update();
                }
            });
        }
        return this;
    }
    hide() {
        return this.focus(null);
    }
    show() {
        return this.blur(null);
    }
    remove() {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => tool.remove());
            this.tools = null;
        }
        remove(this.svgContainer);
        remove(this.htmlContainer);
        return super.remove();
    }
    mount() {
        const tools = this.tools;
        const cellView = this.cellView;
        if (cellView && tools) {
            const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false);
            const hasHTML = tools.some((tool) => tool.options.isSVGElement === false);
            if (hasSVG) {
                const parent = this.options.local
                    ? cellView.container
                    : cellView.graph.view.decorator;
                parent.appendChild(this.svgContainer);
            }
            if (hasHTML) {
                this.graph.container.appendChild(this.htmlContainer);
            }
        }
        return this;
    }
}
(function (ToolsView) {
    ToolsView.toStringTag = `X6.${ToolsView.name}`;
    function isToolsView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof ToolsView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === ToolsView.toStringTag) &&
            view.graph != null &&
            view.cell != null &&
            typeof view.config === 'function' &&
            typeof view.update === 'function' &&
            typeof view.focus === 'function' &&
            typeof view.blur === 'function' &&
            typeof view.show === 'function' &&
            typeof view.hide === 'function') {
            return true;
        }
        return false;
    }
    ToolsView.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));
(function (ToolsView) {
    class ToolItem extends View {
        static getDefaults() {
            return this.defaults;
        }
        static config(options) {
            this.defaults = this.getOptions(options);
        }
        static getOptions(options) {
            return merge$1(cloneDeep(this.getDefaults()), options);
        }
        get graph() {
            return this.cellView.graph;
        }
        get cell() {
            return this.cellView.cell;
        }
        get name() {
            return this.options.name;
        }
        get [Symbol.toStringTag]() {
            return ToolItem.toStringTag;
        }
        constructor(options = {}) {
            super();
            this.visible = true;
            this.options = this.getOptions(options);
            this.container = View.createElement(this.options.tagName || 'g', this.options.isSVGElement !== false);
            addClass(this.container, this.prefixClassName('cell-tool'));
            if (typeof this.options.className === 'string') {
                addClass(this.container, this.options.className);
            }
            this.init();
        }
        init() { }
        getOptions(options) {
            const ctor = this.constructor;
            return ctor.getOptions(options);
        }
        delegateEvents() {
            if (this.options.events) {
                super.delegateEvents(this.options.events);
            }
            return this;
        }
        config(view, toolsView) {
            this.cellView = view;
            this.parent = toolsView;
            this.stamp(this.container);
            if (this.cell.isEdge()) {
                addClass(this.container, this.prefixClassName('edge-tool'));
            }
            else if (this.cell.isNode()) {
                addClass(this.container, this.prefixClassName('node-tool'));
            }
            if (this.name) {
                this.container.setAttribute('data-tool-name', this.name);
            }
            this.delegateEvents();
            return this;
        }
        render() {
            this.empty();
            const markup = this.options.markup;
            if (markup) {
                const meta = Markup.parseJSONMarkup(markup);
                this.container.appendChild(meta.fragment);
                this.childNodes = meta.selectors;
            }
            this.onRender();
            return this;
        }
        onRender() { }
        update() {
            return this;
        }
        stamp(elem) {
            if (elem) {
                elem.setAttribute('data-cell-id', this.cellView.cell.id);
            }
        }
        show() {
            this.container.style.display = '';
            this.visible = true;
            return this;
        }
        hide() {
            this.container.style.display = 'none';
            this.visible = false;
            return this;
        }
        isVisible() {
            return this.visible;
        }
        focus() {
            const opacity = this.options.focusOpacity;
            if (opacity != null && Number.isFinite(opacity)) {
                this.container.style.opacity = `${opacity}`;
            }
            this.parent.focus(this);
            return this;
        }
        blur() {
            this.container.style.opacity = '';
            this.parent.blur(this);
            return this;
        }
        guard(evt) {
            if (this.graph == null || this.cellView == null) {
                return true;
            }
            return this.graph.view.guard(evt, this.cellView);
        }
    }
    // #region static
    ToolItem.defaults = {
        isSVGElement: true,
        tagName: 'g',
    };
    ToolsView.ToolItem = ToolItem;
    (function (ToolItem) {
        let counter = 0;
        function getClassName(name) {
            if (name) {
                return pascalCase(name);
            }
            counter += 1;
            return `CustomTool${counter}`;
        }
        function define(options) {
            const tool = createClass(getClassName(options.name), this);
            tool.config(options);
            return tool;
        }
        ToolItem.define = define;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
    (function (ToolItem) {
        ToolItem.toStringTag = `X6.${ToolItem.name}`;
        function isToolItem(instance) {
            if (instance == null) {
                return false;
            }
            if (instance instanceof ToolItem) {
                return true;
            }
            const tag = instance[Symbol.toStringTag];
            const view = instance;
            if ((tag == null || tag === ToolItem.toStringTag) &&
                view.graph != null &&
                view.cell != null &&
                typeof view.config === 'function' &&
                typeof view.update === 'function' &&
                typeof view.focus === 'function' &&
                typeof view.blur === 'function' &&
                typeof view.show === 'function' &&
                typeof view.hide === 'function' &&
                typeof view.isVisible === 'function') {
                return true;
            }
            return false;
        }
        ToolItem.isToolItem = isToolItem;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
})(ToolsView || (ToolsView = {}));

const noop = (terminal) => terminal;

function toPercentage(value, max) {
    if (max === 0) {
        return '0%';
    }
    return `${Math.round((value / max) * 100)}%`;
}
function pin(relative) {
    const strategy = (terminal, view, magnet, coords) => {
        return view.isEdgeElement(magnet)
            ? pinEdgeTerminal(relative, terminal, view, magnet, coords)
            : pinNodeTerminal(relative, terminal, view, magnet, coords);
    };
    return strategy;
}
function pinNodeTerminal(relative, data, view, magnet, coords) {
    const node = view.cell;
    const angle = node.getAngle();
    const bbox = view.getUnrotatedBBoxOfElement(magnet);
    const center = node.getBBox().getCenter();
    const pos = Point.create(coords).rotate(angle, center);
    let dx = pos.x - bbox.x;
    let dy = pos.y - bbox.y;
    if (relative) {
        dx = toPercentage(dx, bbox.width);
        dy = toPercentage(dy, bbox.height);
    }
    data.anchor = {
        name: 'topLeft',
        args: {
            dx,
            dy,
            rotate: true,
        },
    };
    return data;
}
function pinEdgeTerminal(relative, end, view, magnet, coords) {
    const connection = view.getConnection();
    if (!connection) {
        return end;
    }
    const length = connection.closestPointLength(coords);
    if (relative) {
        const totalLength = connection.length();
        end.anchor = {
            name: 'ratio',
            args: {
                ratio: length / totalLength,
            },
        };
    }
    else {
        end.anchor = {
            name: 'length',
            args: {
                length,
            },
        };
    }
    return end;
}
const pinRelative = pin(true);
const pinAbsolute = pin(false);

const strategies = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    noop,
    pinAbsolute,
    pinRelative
}, Symbol.toStringTag, { value: 'Module' }));

var ConnectionStrategy;
(function (ConnectionStrategy) {
    ConnectionStrategy.presets = strategies;
    ConnectionStrategy.registry = Registry.create({
        type: 'connection strategy',
    });
    ConnectionStrategy.registry.register(ConnectionStrategy.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));

function getAnchor(pos, terminalView, terminalMagnet, type) {
    const end = call$1(ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
    return end.anchor;
}
function getViewBBox(view, quick) {
    if (quick) {
        return view.cell.getBBox();
    }
    return view.cell.isEdge()
        ? view.getConnection().bbox()
        : view.getUnrotatedBBoxOfElement(view.container);
}

class Button extends ToolsView.ToolItem {
    onRender() {
        addClass(this.container, this.prefixClassName('cell-tool-button'));
        this.update();
    }
    update() {
        this.updatePosition();
        return this;
    }
    updatePosition() {
        const view = this.cellView;
        const matrix = view.cell.isEdge()
            ? this.getEdgeMatrix()
            : this.getNodeMatrix();
        transform(this.container, matrix, { absolute: true });
    }
    getNodeMatrix() {
        const view = this.cellView;
        const options = this.options;
        let { x = 0, y = 0 } = options;
        const { offset, useCellGeometry, rotate } = options;
        let bbox = getViewBBox(view, useCellGeometry);
        const angle = view.cell.getAngle();
        if (!rotate) {
            bbox = bbox.bbox(angle);
        }
        let offsetX = 0;
        let offsetY = 0;
        if (typeof offset === 'number') {
            offsetX = offset;
            offsetY = offset;
        }
        else if (typeof offset === 'object') {
            offsetX = offset.x;
            offsetY = offset.y;
        }
        x = normalizePercentage(x, bbox.width);
        y = normalizePercentage(y, bbox.height);
        let matrix = createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
        if (rotate) {
            matrix = matrix.rotate(angle);
        }
        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
        return matrix;
    }
    getEdgeMatrix() {
        const view = this.cellView;
        const options = this.options;
        const { offset = 0, distance = 0, rotate } = options;
        let tangent;
        let position;
        let angle;
        const d = normalizePercentage(distance, 1);
        if (d >= 0 && d <= 1) {
            tangent = view.getTangentAtRatio(d);
        }
        else {
            tangent = view.getTangentAtLength(d);
        }
        if (tangent) {
            position = tangent.start;
            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
        }
        else {
            position = view.getConnection().start;
            angle = 0;
        }
        let matrix = createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        if (typeof offset === 'object') {
            matrix = matrix.translate(offset.x || 0, offset.y || 0);
        }
        else {
            matrix = matrix.translate(0, offset);
        }
        if (!rotate) {
            matrix = matrix.rotate(-angle);
        }
        return matrix;
    }
    onMouseDown(e) {
        if (this.guard(e)) {
            return;
        }
        e.stopPropagation();
        e.preventDefault();
        const onClick = this.options.onClick;
        if (typeof onClick === 'function') {
            call$1(onClick, this.cellView, {
                e,
                view: this.cellView,
                cell: this.cellView.cell,
                btn: this,
            });
        }
    }
}
(function (Button) {
    Button.config({
        name: 'button',
        useCellGeometry: true,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
    });
})(Button || (Button = {}));
(function (Button) {
    Button.Remove = Button.define({
        name: 'button-remove',
        markup: [
            {
                tagName: 'circle',
                selector: 'button',
                attrs: {
                    r: 7,
                    fill: '#FF1D00',
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'path',
                selector: 'icon',
                attrs: {
                    d: 'M -3 -3 3 3 M -3 3 3 -3',
                    fill: 'none',
                    stroke: '#FFFFFF',
                    'stroke-width': 2,
                    'pointer-events': 'none',
                },
            },
        ],
        distance: 60,
        offset: 0,
        useCellGeometry: true,
        onClick({ view, btn }) {
            btn.parent.remove();
            view.cell.remove({ ui: true, toolId: btn.cid });
        },
    });
})(Button || (Button = {}));

var __rest$f = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Boundary extends ToolsView.ToolItem {
    onRender() {
        addClass(this.container, this.prefixClassName('cell-tool-boundary'));
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest$f(_a, ["class"]);
            attr(this.container, kebablizeAttrs(attrs));
            if (className) {
                addClass(this.container, className);
            }
        }
        this.update();
    }
    update() {
        const view = this.cellView;
        const options = this.options;
        const { useCellGeometry, rotate } = options;
        const padding = normalizeSides(options.padding);
        let bbox = getViewBBox(view, useCellGeometry).moveAndExpand({
            x: -padding.left,
            y: -padding.top,
            width: padding.left + padding.right,
            height: padding.top + padding.bottom,
        });
        const cell = view.cell;
        if (cell.isNode()) {
            const angle = cell.getAngle();
            if (angle) {
                if (rotate) {
                    const origin = cell.getBBox().getCenter();
                    rotate$1(this.container, angle, origin.x, origin.y, {
                        absolute: true,
                    });
                }
                else {
                    bbox = bbox.bbox(angle);
                }
            }
        }
        attr(this.container, bbox.toJSON());
        return this;
    }
}
(function (Boundary) {
    Boundary.config({
        name: 'boundary',
        tagName: 'rect',
        padding: 10,
        useCellGeometry: true,
        attrs: {
            fill: 'none',
            stroke: '#333',
            'stroke-width': 0.5,
            'stroke-dasharray': '5, 5',
            'pointer-events': 'none',
        },
    });
})(Boundary || (Boundary = {}));

class Vertices extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    onRender() {
        this.addClass(this.prefixClassName('edge-tool-vertices'));
        if (this.options.addable) {
            this.updatePath();
        }
        this.resetHandles();
        this.renderHandles();
        return this;
    }
    update() {
        const vertices = this.vertices;
        if (vertices.length === this.handles.length) {
            this.updateHandles();
        }
        else {
            this.resetHandles();
            this.renderHandles();
        }
        if (this.options.addable) {
            this.updatePath();
        }
        return this;
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    renderHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const createHandle = this.options.createHandle;
            const processHandle = this.options.processHandle;
            const handle = createHandle({
                index: i,
                graph: this.graph,
                guard: (evt) => this.guard(evt),
                attrs: this.options.attrs || {},
            });
            if (processHandle) {
                processHandle(handle);
            }
            handle.updatePosition(vertex.x, vertex.y);
            this.stamp(handle.container);
            this.container.appendChild(handle.container);
            this.handles.push(handle);
            this.startHandleListening(handle);
        }
    }
    updateHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const handle = this.handles[i];
            if (handle) {
                handle.updatePosition(vertex.x, vertex.y);
            }
        }
    }
    updatePath() {
        const connection = this.childNodes.connection;
        if (connection) {
            connection.setAttribute('d', this.cellView.getConnectionPathData());
        }
    }
    startHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.on('change', this.onHandleChange, this);
            handle.on('changing', this.onHandleChanging, this);
            handle.on('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.on('remove', this.onHandleRemove, this);
        }
    }
    stopHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.off('change', this.onHandleChange, this);
            handle.off('changing', this.onHandleChanging, this);
            handle.off('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.off('remove', this.onHandleRemove, this);
        }
    }
    getNeighborPoints(index) {
        const edgeView = this.cellView;
        const vertices = this.vertices;
        const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;
        const next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;
        return {
            prev: Point.create(prev),
            next: Point.create(next),
        };
    }
    getMouseEventArgs(evt) {
        const e = this.normalizeEvent(evt);
        const { x, y } = this.graph.snapToGrid(e.clientX, e.clientY);
        return { e, x, y };
    }
    onHandleChange({ e }) {
        this.focus();
        const edgeView = this.cellView;
        edgeView.cell.startBatch('move-vertex', { ui: true, toolId: this.cid });
        if (!this.options.stopPropagation) {
            const { e: evt, x, y } = this.getMouseEventArgs(e);
            this.eventData(evt, { start: { x, y } });
            edgeView.notifyMouseDown(evt, x, y);
        }
    }
    onHandleChanging({ handle, e, }) {
        const edgeView = this.cellView;
        const index = handle.options.index;
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        const vertex = { x, y };
        this.snapVertex(vertex, index);
        edgeView.cell.setVertexAt(index, vertex, { ui: true, toolId: this.cid });
        handle.updatePosition(vertex.x, vertex.y);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseMove(evt, x, y);
        }
    }
    stopBatch(vertexAdded) {
        this.cell.stopBatch('move-vertex', { ui: true, toolId: this.cid });
        if (vertexAdded) {
            this.cell.stopBatch('add-vertex', { ui: true, toolId: this.cid });
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.addable) {
            this.updatePath();
        }
        if (!options.removeRedundancies) {
            this.stopBatch(this.eventData(e).vertexAdded);
            return;
        }
        const verticesRemoved = edgeView.removeRedundantLinearVertices({
            ui: true,
            toolId: this.cid,
        });
        if (verticesRemoved) {
            this.render();
        }
        this.blur();
        this.stopBatch(this.eventData(e).vertexAdded);
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseUp(evt, x, y);
            const { start } = this.eventData(evt);
            if (start) {
                const { x: startX, y: startY } = start;
                if (startX === x && startY === y) {
                    edgeView.onClick(evt, x, y);
                }
            }
        }
        edgeView.checkMouseleave(evt);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    snapVertex(vertex, index) {
        const snapRadius = this.options.snapRadius || 0;
        if (snapRadius > 0) {
            const neighbors = this.getNeighborPoints(index);
            const prev = neighbors.prev;
            const next = neighbors.next;
            if (Math.abs(vertex.x - prev.x) < snapRadius) {
                vertex.x = prev.x;
            }
            else if (Math.abs(vertex.x - next.x) < snapRadius) {
                vertex.x = next.x;
            }
            if (Math.abs(vertex.y - prev.y) < snapRadius) {
                vertex.y = neighbors.prev.y;
            }
            else if (Math.abs(vertex.y - next.y) < snapRadius) {
                vertex.y = next.y;
            }
        }
    }
    onHandleRemove({ handle, e }) {
        if (this.options.removable) {
            const index = handle.options.index;
            const edgeView = this.cellView;
            edgeView.cell.removeVertexAt(index, { ui: true });
            if (this.options.addable) {
                this.updatePath();
            }
            edgeView.checkMouseleave(this.normalizeEvent(e));
        }
    }
    allowAddVertex(e) {
        const guard = this.guard(e);
        const addable = this.options.addable && this.cellView.can('vertexAddable');
        const matchModifiers = this.options.modifiers
            ? ModifierKey.isMatch(e, this.options.modifiers)
            : true;
        return !guard && addable && matchModifiers;
    }
    onPathMouseDown(evt) {
        const edgeView = this.cellView;
        if (!this.allowAddVertex(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const e = this.normalizeEvent(evt);
        const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
        edgeView.cell.startBatch('add-vertex', { ui: true, toolId: this.cid });
        const index = edgeView.getVertexIndex(vertex.x, vertex.y);
        this.snapVertex(vertex, index);
        edgeView.cell.insertVertex(vertex, index, {
            ui: true,
            toolId: this.cid,
        });
        this.render();
        const handle = this.handles[index];
        this.eventData(e, { vertexAdded: true });
        handle.onMouseDown(e);
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Vertices) {
    class Handle extends View {
        get graph() {
            return this.options.graph;
        }
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
                dblclick: 'onDoubleClick',
            });
        }
        render() {
            this.container = View.createElement('circle', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Vertices.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-vertex'));
        }
        updatePosition(x, y) {
            this.setAttrs({ cx: x, cy: y });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
            this.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
            this.emit('change', { e: evt, handle: this });
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.graph.view.delegateEvents();
        }
        onDoubleClick(evt) {
            this.emit('remove', { e: evt, handle: this });
        }
    }
    Vertices.Handle = Handle;
})(Vertices || (Vertices = {}));
(function (Vertices) {
    const pathClassName = Config.prefix('edge-tool-vertex-path');
    Vertices.config({
        name: 'vertices',
        snapRadius: 20,
        addable: true,
        removable: true,
        removeRedundancies: true,
        stopPropagation: true,
        attrs: {
            r: 6,
            fill: '#333',
            stroke: '#fff',
            cursor: 'move',
            'stroke-width': 2,
        },
        createHandle: (options) => new Vertices.Handle(options),
        markup: [
            {
                tagName: 'path',
                selector: 'connection',
                className: pathClassName,
                attrs: {
                    fill: 'none',
                    stroke: 'transparent',
                    'stroke-width': 10,
                    cursor: 'pointer',
                },
            },
        ],
        events: {
            [`mousedown .${pathClassName}`]: 'onPathMouseDown',
            [`touchstart .${pathClassName}`]: 'onPathMouseDown',
        },
    });
})(Vertices || (Vertices = {}));

class Segments extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    update() {
        this.render();
        return this;
    }
    onRender() {
        addClass(this.container, this.prefixClassName('edge-tool-segments'));
        this.resetHandles();
        const edgeView = this.cellView;
        const vertices = [...this.vertices];
        vertices.unshift(edgeView.sourcePoint);
        vertices.push(edgeView.targetPoint);
        for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
            const vertex = vertices[i];
            const nextVertex = vertices[i + 1];
            const handle = this.renderHandle(vertex, nextVertex, i);
            this.stamp(handle.container);
            this.handles.push(handle);
        }
        return this;
    }
    renderHandle(vertex, nextVertex, index) {
        const handle = this.options.createHandle({
            index,
            graph: this.graph,
            guard: (evt) => this.guard(evt),
            attrs: this.options.attrs || {},
        });
        if (this.options.processHandle) {
            this.options.processHandle(handle);
        }
        this.updateHandle(handle, vertex, nextVertex);
        this.container.appendChild(handle.container);
        this.startHandleListening(handle);
        return handle;
    }
    startHandleListening(handle) {
        handle.on('change', this.onHandleChange, this);
        handle.on('changing', this.onHandleChanging, this);
        handle.on('changed', this.onHandleChanged, this);
    }
    stopHandleListening(handle) {
        handle.off('change', this.onHandleChange, this);
        handle.off('changing', this.onHandleChanging, this);
        handle.off('changed', this.onHandleChanged, this);
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    shiftHandleIndexes(delta) {
        const handles = this.handles;
        for (let i = 0, n = handles.length; i < n; i += 1) {
            handles[i].options.index += delta;
        }
    }
    resetAnchor(type, anchor) {
        const edge = this.cellView.cell;
        const options = {
            ui: true,
            toolId: this.cid,
        };
        if (anchor) {
            edge.prop([type, 'anchor'], anchor, options);
        }
        else {
            edge.removeProp([type, 'anchor'], options);
        }
    }
    snapHandle(handle, position, data) {
        const axis = handle.options.axis;
        const index = handle.options.index;
        const edgeView = this.cellView;
        const edge = edgeView.cell;
        const vertices = edge.getVertices();
        const prev = vertices[index - 2] || data.sourceAnchor;
        const next = vertices[index + 1] || data.targetAnchor;
        const snapRadius = this.options.snapRadius;
        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
            position[axis] = prev[axis];
        }
        else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
            position[axis] = next[axis];
        }
        return position;
    }
    onHandleChanging({ handle, e, }) {
        const graph = this.graph;
        const options = this.options;
        const edgeView = this.cellView;
        const anchorFn = options.anchor;
        const axis = handle.options.axis;
        const index = handle.options.index - 1;
        const data = this.getEventData(e);
        const evt = this.normalizeEvent(e);
        const coords = graph.snapToGrid(evt.clientX, evt.clientY);
        const position = this.snapHandle(handle, coords.clone(), data);
        const vertices = cloneDeep(this.vertices);
        let vertex = vertices[index];
        let nextVertex = vertices[index + 1];
        // First Segment
        const sourceView = edgeView.sourceView;
        const sourceBBox = edgeView.sourceBBox;
        let changeSourceAnchor = false;
        let deleteSourceAnchor = false;
        if (!vertex) {
            vertex = edgeView.sourceAnchor.toJSON();
            vertex[axis] = position[axis];
            if (sourceBBox.containsPoint(vertex)) {
                changeSourceAnchor = true;
            }
            else {
                vertices.unshift(vertex);
                this.shiftHandleIndexes(1);
                deleteSourceAnchor = true;
            }
        }
        else if (index === 0) {
            if (sourceBBox.containsPoint(vertex)) {
                vertices.shift();
                this.shiftHandleIndexes(-1);
                changeSourceAnchor = true;
            }
            else {
                vertex[axis] = position[axis];
                deleteSourceAnchor = true;
            }
        }
        else {
            vertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && sourceView) {
            if (changeSourceAnchor) {
                const sourceAnchorPosition = data.sourceAnchor.clone();
                sourceAnchorPosition[axis] = position[axis];
                const sourceAnchor = call$1(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);
                this.resetAnchor('source', sourceAnchor);
            }
            if (deleteSourceAnchor) {
                this.resetAnchor('source', data.sourceAnchorDef);
            }
        }
        // Last segment
        const targetView = edgeView.targetView;
        const targetBBox = edgeView.targetBBox;
        let changeTargetAnchor = false;
        let deleteTargetAnchor = false;
        if (!nextVertex) {
            nextVertex = edgeView.targetAnchor.toJSON();
            nextVertex[axis] = position[axis];
            if (targetBBox.containsPoint(nextVertex)) {
                changeTargetAnchor = true;
            }
            else {
                vertices.push(nextVertex);
                deleteTargetAnchor = true;
            }
        }
        else if (index === vertices.length - 2) {
            if (targetBBox.containsPoint(nextVertex)) {
                vertices.pop();
                changeTargetAnchor = true;
            }
            else {
                nextVertex[axis] = position[axis];
                deleteTargetAnchor = true;
            }
        }
        else {
            nextVertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && targetView) {
            if (changeTargetAnchor) {
                const targetAnchorPosition = data.targetAnchor.clone();
                targetAnchorPosition[axis] = position[axis];
                const targetAnchor = call$1(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);
                this.resetAnchor('target', targetAnchor);
            }
            if (deleteTargetAnchor) {
                this.resetAnchor('target', data.targetAnchorDef);
            }
        }
        if (!Point.equalPoints(vertices, this.vertices)) {
            this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });
        }
        this.updateHandle(handle, vertex, nextVertex, 0);
        if (!options.stopPropagation) {
            edgeView.notifyMouseMove(evt, coords.x, coords.y);
        }
    }
    onHandleChange({ handle, e }) {
        const options = this.options;
        const handles = this.handles;
        const edgeView = this.cellView;
        const index = handle.options.index;
        if (!Array.isArray(handles)) {
            return;
        }
        for (let i = 0, n = handles.length; i < n; i += 1) {
            if (i !== index) {
                handles[i].hide();
            }
        }
        this.focus();
        this.setEventData(e, {
            sourceAnchor: edgeView.sourceAnchor.clone(),
            targetAnchor: edgeView.targetAnchor.clone(),
            sourceAnchorDef: cloneDeep(this.cell.prop(['source', 'anchor'])),
            targetAnchorDef: cloneDeep(this.cell.prop(['target', 'anchor'])),
        });
        this.cell.startBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            const normalizedEvent = this.normalizeEvent(e);
            const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
            edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        const normalizedEvent = this.normalizeEvent(e);
        const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
        this.render();
        this.blur();
        this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
        }
        edgeView.checkMouseleave(normalizedEvent);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    updateHandle(handle, vertex, nextVertex, offset = 0) {
        const precision = this.options.precision || 0;
        const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
        const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;
        if (vertical || horizontal) {
            const segmentLine = new Line(vertex, nextVertex);
            const length = segmentLine.length();
            if (length < this.options.threshold) {
                handle.hide();
            }
            else {
                const position = segmentLine.getCenter();
                const axis = vertical ? 'x' : 'y';
                position[axis] += offset || 0;
                const angle = segmentLine.vector().vectorAngle(new Point(1, 0));
                handle.updatePosition(position.x, position.y, angle, this.cellView);
                handle.show();
                handle.options.axis = axis;
            }
        }
        else {
            handle.hide();
        }
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Segments) {
    class Handle extends View {
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
            });
        }
        render() {
            this.container = View.createElement('rect', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Segments.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-segment'));
        }
        updatePosition(x, y, angle, view) {
            const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);
            let matrix = createSVGMatrix().translate(p.x, p.y);
            if (!p.equals({ x, y })) {
                const line = new Line(x, y, p.x, p.y);
                let deg = line.vector().vectorAngle(new Point(1, 0));
                if (deg !== 0) {
                    deg += 90;
                }
                matrix = matrix.rotate(deg);
            }
            else {
                matrix = matrix.rotate(angle);
            }
            this.setAttrs({
                transform: matrixToTransformString(matrix),
                cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',
            });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            this.trigger('change', { e: evt, handle: this });
            evt.stopPropagation();
            evt.preventDefault();
            this.options.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.options.graph.view.delegateEvents();
        }
        show() {
            this.container.style.display = '';
        }
        hide() {
            this.container.style.display = 'none';
        }
    }
    Segments.Handle = Handle;
})(Segments || (Segments = {}));
(function (Segments) {
    Segments.config({
        name: 'segments',
        precision: 0.5,
        threshold: 40,
        snapRadius: 10,
        stopPropagation: true,
        removeRedundancies: true,
        attrs: {
            width: 20,
            height: 8,
            x: -10,
            y: -4,
            rx: 4,
            ry: 4,
            fill: '#333',
            stroke: '#fff',
            'stroke-width': 2,
        },
        createHandle: (options) => new Segments.Handle(options),
        anchor: getAnchor,
    });
})(Segments || (Segments = {}));

class Anchor extends ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    onRender() {
        addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
        this.toggleArea(false);
        this.update();
    }
    update() {
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            this.updateAnchor();
            this.updateArea();
            this.container.style.display = '';
        }
        else {
            this.container.style.display = 'none';
        }
        return this;
    }
    updateAnchor() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const anchorNode = childNodes.anchor;
        if (!anchorNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const options = this.options;
        const position = edgeView.getTerminalAnchor(type);
        const customAnchor = edgeView.cell.prop([type, 'anchor']);
        anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);
        const anchorAttrs = customAnchor
            ? options.customAnchorAttrs
            : options.defaultAnchorAttrs;
        if (anchorAttrs) {
            Object.keys(anchorAttrs).forEach((attrName) => {
                anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
            });
        }
    }
    updateArea() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const areaNode = childNodes.area;
        if (!areaNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            const terminalCell = terminalView.cell;
            const magnet = edgeView.getTerminalMagnet(type);
            let padding = this.options.areaPadding || 0;
            if (!Number.isFinite(padding)) {
                padding = 0;
            }
            let bbox;
            let angle;
            let center;
            if (terminalView.isEdgeElement(magnet)) {
                bbox = terminalView.getBBox();
                angle = 0;
                center = bbox.getCenter();
            }
            else {
                bbox = terminalView.getUnrotatedBBoxOfElement(magnet);
                angle = terminalCell.getAngle();
                center = bbox.getCenter();
                if (angle) {
                    center.rotate(-angle, terminalCell.getBBox().getCenter());
                }
            }
            bbox.inflate(padding);
            attr(areaNode, {
                x: -bbox.width / 2,
                y: -bbox.height / 2,
                width: bbox.width,
                height: bbox.height,
                transform: `translate(${center.x}, ${center.y}) rotate(${angle})`,
            });
        }
    }
    toggleArea(visible) {
        if (this.childNodes) {
            const elem = this.childNodes.area;
            if (elem) {
                elem.style.display = visible ? '' : 'none';
            }
        }
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        this.graph.view.undelegateEvents();
        if (this.options.documentEvents) {
            this.delegateDocumentEvents(this.options.documentEvents);
        }
        this.focus();
        this.toggleArea(this.options.restrictArea);
        this.cell.startBatch('move-anchor', {
            ui: true,
            toolId: this.cid,
        });
    }
    resetAnchor(anchor) {
        const type = this.type;
        const cell = this.cell;
        if (anchor) {
            cell.prop([type, 'anchor'], anchor, {
                rewrite: true,
                ui: true,
                toolId: this.cid,
            });
        }
        else {
            cell.removeProp([type, 'anchor'], {
                ui: true,
                toolId: this.cid,
            });
        }
    }
    onMouseMove(evt) {
        const terminalType = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(terminalType);
        if (terminalView == null) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const terminalCell = terminalView.cell;
        const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
        let coords = this.graph.coord.clientToLocalPoint(e.clientX, e.clientY);
        const snapFn = this.options.snap;
        if (typeof snapFn === 'function') {
            const tmp = call$1(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
            coords = Point.create(tmp);
        }
        if (this.options.restrictArea) {
            if (terminalView.isEdgeElement(terminalMagnet)) {
                const pointAtConnection = terminalView.getClosestPoint(coords);
                if (pointAtConnection) {
                    coords = pointAtConnection;
                }
            }
            else {
                const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
                const angle = terminalCell.getAngle();
                const origin = terminalCell.getBBox().getCenter();
                const rotatedCoords = coords.clone().rotate(angle, origin);
                if (!bbox.containsPoint(rotatedCoords)) {
                    coords = bbox
                        .getNearestPointToPoint(rotatedCoords)
                        .rotate(-angle, origin);
                }
            }
        }
        let anchor;
        const anchorFn = this.options.anchor;
        if (typeof anchorFn === 'function') {
            anchor = call$1(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
        }
        this.resetAnchor(anchor);
        this.update();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMouseUp(evt) {
        this.graph.view.delegateEvents();
        this.undelegateDocumentEvents();
        this.blur();
        this.toggleArea(false);
        const edgeView = this.cellView;
        if (this.options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        this.cell.stopBatch('move-anchor', { ui: true, toolId: this.cid });
    }
    onDblClick() {
        const anchor = this.options.resetAnchor;
        if (anchor) {
            this.resetAnchor(anchor === true ? undefined : anchor);
        }
        this.update();
    }
}
(function (Anchor) {
    Anchor.config({
        tagName: 'g',
        markup: [
            {
                tagName: 'circle',
                selector: 'anchor',
                attrs: {
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'rect',
                selector: 'area',
                attrs: {
                    'pointer-events': 'none',
                    fill: 'none',
                    stroke: '#33334F',
                    'stroke-dasharray': '2,4',
                    rx: 5,
                    ry: 5,
                },
            },
        ],
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
            dblclick: 'onDblClick',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
        customAnchorAttrs: {
            'stroke-width': 4,
            stroke: '#33334F',
            fill: '#FFFFFF',
            r: 5,
        },
        defaultAnchorAttrs: {
            'stroke-width': 2,
            stroke: '#FFFFFF',
            fill: '#33334F',
            r: 6,
        },
        areaPadding: 6,
        snapRadius: 10,
        resetAnchor: true,
        restrictArea: true,
        removeRedundancies: true,
        anchor: getAnchor,
        snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
            const snapRadius = toolView.options.snapRadius || 0;
            const isSource = terminalType === 'source';
            const refIndex = isSource ? 0 : -1;
            const ref = this.cell.getVertexAt(refIndex) ||
                this.getTerminalAnchor(isSource ? 'target' : 'source');
            if (ref) {
                if (Math.abs(ref.x - pos.x) < snapRadius)
                    pos.x = ref.x;
                if (Math.abs(ref.y - pos.y) < snapRadius)
                    pos.y = ref.y;
            }
            return pos;
        },
    });
})(Anchor || (Anchor = {}));
const SourceAnchor = Anchor.define({
    name: 'source-anchor',
    type: 'source',
});
const TargetAnchor = Anchor.define({
    name: 'target-anchor',
    type: 'target',
});

var __rest$e = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Arrowhead extends ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    get ratio() {
        return this.options.ratio;
    }
    init() {
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest$e(_a, ["class"]);
            this.setAttrs(attrs, this.container);
            if (className) {
                addClass(this.container, className);
            }
        }
    }
    onRender() {
        addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
        this.update();
    }
    update() {
        const ratio = this.ratio;
        const edgeView = this.cellView;
        const tangent = edgeView.getTangentAtRatio(ratio);
        const position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio);
        const angle = (tangent && tangent.vector().vectorAngle(new Point(1, 0))) || 0;
        if (!position) {
            return this;
        }
        const matrix = createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        transform(this.container, matrix, { absolute: true });
        return this;
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const edgeView = this.cellView;
        if (edgeView.can('arrowheadMovable')) {
            edgeView.cell.startBatch('move-arrowhead', {
                ui: true,
                toolId: this.cid,
            });
            const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
            const data = edgeView.prepareArrowheadDragging(this.type, {
                x: coords.x,
                y: coords.y,
                options: Object.assign(Object.assign({}, this.options), { toolId: this.cid }),
            });
            this.cellView.setEventData(evt, data);
            this.delegateDocumentEvents(this.options.documentEvents, evt.data);
            edgeView.graph.view.undelegateEvents();
            this.container.style.pointerEvents = 'none';
        }
        this.focus();
    }
    onMouseMove(evt) {
        const e = this.normalizeEvent(evt);
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        this.cellView.onMouseMove(e, coords.x, coords.y);
        this.update();
    }
    onMouseUp(evt) {
        this.undelegateDocumentEvents();
        const e = this.normalizeEvent(evt);
        const edgeView = this.cellView;
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        edgeView.onMouseUp(e, coords.x, coords.y);
        this.graph.view.delegateEvents();
        this.blur();
        this.container.style.pointerEvents = '';
        edgeView.cell.stopBatch('move-arrowhead', {
            ui: true,
            toolId: this.cid,
        });
    }
}
(function (Arrowhead) {
    Arrowhead.config({
        tagName: 'path',
        isSVGElement: true,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
    });
})(Arrowhead || (Arrowhead = {}));
const SourceArrowhead = Arrowhead.define({
    name: 'source-arrowhead',
    type: 'source',
    ratio: 0,
    attrs: {
        d: 'M 10 -8 -10 0 10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});
const TargetArrowhead = Arrowhead.define({
    name: 'target-arrowhead',
    type: 'target',
    ratio: 1,
    attrs: {
        d: 'M -10 -8 10 0 -10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});

class CellEditor extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.labelIndex = -1;
        this.distance = 0.5;
        this.dblClick = this.onCellDblClick.bind(this);
    }
    onRender() {
        const cellView = this.cellView;
        if (cellView) {
            cellView.on('cell:dblclick', this.dblClick);
        }
    }
    createElement() {
        const classNames = [
            this.prefixClassName(`${this.cell.isEdge() ? 'edge' : 'node'}-tool-editor`),
            this.prefixClassName('cell-tool-editor'),
        ];
        this.editor = ToolsView.createElement('div', false);
        this.addClass(classNames, this.editor);
        this.editor.contentEditable = 'true';
        this.container.appendChild(this.editor);
    }
    removeElement() {
        this.undelegateDocumentEvents();
        if (this.editor) {
            this.container.removeChild(this.editor);
            this.editor = null;
        }
    }
    updateEditor() {
        const { cell, editor } = this;
        if (!editor) {
            return;
        }
        const { style } = editor;
        if (cell.isNode()) {
            this.updateNodeEditorTransform();
        }
        else if (cell.isEdge()) {
            this.updateEdgeEditorTransform();
        }
        // set font style
        const { attrs } = this.options;
        style.fontSize = `${attrs.fontSize}px`;
        style.fontFamily = attrs.fontFamily;
        style.color = attrs.color;
        style.backgroundColor = attrs.backgroundColor;
        // set init value
        const text = this.getCellText() || '';
        editor.innerText = text;
        this.setCellText(''); // clear display value when edit status because char ghosting.
        return this;
    }
    updateNodeEditorTransform() {
        const { graph, cell, editor } = this;
        if (!editor) {
            return;
        }
        let pos = Point.create();
        let minWidth = 20;
        let translate = '';
        let { x, y } = this.options;
        const { width, height } = this.options;
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            const bbox = cell.getBBox();
            x = normalizePercentage(x, bbox.width);
            y = normalizePercentage(y, bbox.height);
            pos = bbox.topLeft.translate(x, y);
            minWidth = bbox.width - x * 2;
        }
        else {
            const bbox = cell.getBBox();
            pos = bbox.center;
            minWidth = bbox.width - 4;
            translate = 'translate(-50%, -50%)';
        }
        const scale = graph.scale();
        const { style } = editor;
        pos = graph.localToGraph(pos);
        style.left = `${pos.x}px`;
        style.top = `${pos.y}px`;
        style.transform = `scale(${scale.sx}, ${scale.sy}) ${translate}`;
        style.minWidth = `${minWidth}px`;
        if (typeof width === 'number') {
            style.width = `${width}px`;
        }
        if (typeof height === 'number') {
            style.height = `${height}px`;
        }
    }
    updateEdgeEditorTransform() {
        if (!this.event) {
            return;
        }
        const { graph, editor } = this;
        if (!editor) {
            return;
        }
        let pos = Point.create();
        let minWidth = 20;
        const { style } = editor;
        const target = this.event.target;
        const parent = target.parentElement;
        const isEdgeLabel = parent && hasClass(parent, this.prefixClassName('edge-label'));
        if (isEdgeLabel) {
            const index = parent.getAttribute('data-index') || '0';
            this.labelIndex = parseInt(index, 10);
            const matrix = parent.getAttribute('transform');
            const { translation } = parseTransformString(matrix);
            pos = new Point(translation.tx, translation.ty);
            minWidth = Util.getBBox(target).width;
        }
        else {
            if (!this.options.labelAddable) {
                return this;
            }
            pos = graph.clientToLocal(Point.create(this.event.clientX, this.event.clientY));
            const view = this.cellView;
            const d = view.path.closestPointLength(pos);
            this.distance = d;
            this.labelIndex = -1;
        }
        pos = graph.localToGraph(pos);
        const scale = graph.scale();
        style.left = `${pos.x}px`;
        style.top = `${pos.y}px`;
        style.minWidth = `${minWidth}px`;
        style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`;
    }
    onDocumentMouseUp(e) {
        if (this.editor && e.target !== this.editor) {
            const value = this.editor.innerText.replace(/\n$/, '') || '';
            // set value, when value is null, we will remove label in edge
            this.setCellText(value !== '' ? value : null);
            // remove tool
            this.removeElement();
        }
    }
    onCellDblClick({ e }) {
        if (!this.editor) {
            e.stopPropagation();
            this.removeElement();
            this.event = e;
            this.createElement();
            this.updateEditor();
            this.autoFocus();
            this.delegateDocumentEvents(this.options.documentEvents);
        }
    }
    onMouseDown(e) {
        e.stopPropagation();
    }
    autoFocus() {
        setTimeout(() => {
            if (this.editor) {
                this.editor.focus();
                this.selectText();
            }
        });
    }
    selectText() {
        if (window.getSelection && this.editor) {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(this.editor);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
    getCellText() {
        const { getText } = this.options;
        if (typeof getText === 'function') {
            return call$1(getText, this.cellView, {
                cell: this.cell,
                index: this.labelIndex,
            });
        }
        if (typeof getText === 'string') {
            if (this.cell.isNode()) {
                return this.cell.attr(getText);
            }
            if (this.cell.isEdge()) {
                if (this.labelIndex !== -1) {
                    return this.cell.prop(`labels/${this.labelIndex}/attrs/${getText}`);
                }
            }
        }
    }
    setCellText(value) {
        const setText = this.options.setText;
        if (typeof setText === 'function') {
            call$1(setText, this.cellView, {
                cell: this.cell,
                value,
                index: this.labelIndex,
                distance: this.distance,
            });
            return;
        }
        if (typeof setText === 'string') {
            if (this.cell.isNode()) {
                if (value !== null) {
                    this.cell.attr(setText, value);
                }
                return;
            }
            if (this.cell.isEdge()) {
                const edge = this.cell;
                if (this.labelIndex === -1) {
                    if (value) {
                        const newLabel = {
                            position: {
                                distance: this.distance,
                            },
                            attrs: {},
                        };
                        setByPath(newLabel, `attrs/${setText}`, value);
                        edge.appendLabel(newLabel);
                    }
                }
                else {
                    if (value !== null) {
                        edge.prop(`labels/${this.labelIndex}/attrs/${setText}`, value);
                    }
                    else if (typeof this.labelIndex === 'number') {
                        edge.removeLabelAt(this.labelIndex);
                    }
                }
            }
        }
    }
    onRemove() {
        const cellView = this.cellView;
        if (cellView) {
            cellView.off('cell:dblclick', this.dblClick);
        }
        this.removeElement();
    }
}
(function (CellEditor) {
    CellEditor.config({
        tagName: 'div',
        isSVGElement: false,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
        documentEvents: {
            mouseup: 'onDocumentMouseUp',
            touchend: 'onDocumentMouseUp',
            touchcancel: 'onDocumentMouseUp',
        },
    });
})(CellEditor || (CellEditor = {}));
(function (CellEditor) {
    CellEditor.NodeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        getText: 'text/text',
        setText: 'text/text',
    });
    CellEditor.EdgeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        labelAddable: true,
        getText: 'label/text',
        setText: 'label/text',
    });
})(CellEditor || (CellEditor = {}));

var __rest$d = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var NodeTool;
(function (NodeTool) {
    NodeTool.presets = {
        boundary: Boundary,
        button: Button,
        'button-remove': Button.Remove,
        'node-editor': CellEditor.NodeEditor,
    };
    NodeTool.registry = Registry.create({
        type: 'node tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = ToolsView.ToolItem;
            const { inherit } = options, others = __rest$d(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    NodeTool.registry.register(NodeTool.presets, true);
})(NodeTool || (NodeTool = {}));
var EdgeTool;
(function (EdgeTool) {
    EdgeTool.presets = {
        boundary: Boundary,
        vertices: Vertices,
        segments: Segments,
        button: Button,
        'button-remove': Button.Remove,
        'source-anchor': SourceAnchor,
        'target-anchor': TargetAnchor,
        'source-arrowhead': SourceArrowhead,
        'target-arrowhead': TargetArrowhead,
        'edge-editor': CellEditor.EdgeEditor,
    };
    EdgeTool.registry = Registry.create({
        type: 'edge tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = ToolsView.ToolItem;
            const { inherit } = options, others = __rest$d(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    EdgeTool.registry.register(EdgeTool.presets, true);
})(EdgeTool || (EdgeTool = {}));

const center = createBBoxAnchor('center');
const top = createBBoxAnchor('topCenter');
const bottom = createBBoxAnchor('bottomCenter');
const left = createBBoxAnchor('leftMiddle');
const right = createBBoxAnchor('rightMiddle');
const topLeft = createBBoxAnchor('topLeft');
const topRight = createBBoxAnchor('topRight');
const bottomLeft = createBBoxAnchor('bottomLeft');
const bottomRight = createBBoxAnchor('bottomRight');
function createBBoxAnchor(method) {
    return function (view, magnet, ref, options = {}) {
        const bbox = options.rotate
            ? view.getUnrotatedBBoxOfElement(magnet)
            : view.getBBoxOfElement(magnet);
        const result = bbox[method];
        result.x += normalizePercentage(options.dx, bbox.width);
        result.y += normalizePercentage(options.dy, bbox.height);
        const cell = view.cell;
        return options.rotate
            ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter())
            : result;
    };
}

// eslint-disable-next-line
function resolve$1(fn) {
    return function (view, magnet, ref, options) {
        if (ref instanceof Element) {
            const refView = this.graph.findViewByElem(ref);
            let refPoint;
            if (refView) {
                if (refView.isEdgeElement(ref)) {
                    const distance = options.fixedAt != null ? options.fixedAt : '50%';
                    refPoint = getPointAtEdge(refView, distance);
                }
                else {
                    refPoint = refView.getBBoxOfElement(ref).getCenter();
                }
            }
            else {
                refPoint = new Point();
            }
            return fn.call(this, view, magnet, refPoint, options);
        }
        return fn.apply(this, arguments); // eslint-disable-line
    };
}
function getPointAtEdge(edgeView, value) {
    const isPercentage$1 = isPercentage(value);
    const num = typeof value === 'string' ? parseFloat(value) : value;
    if (isPercentage$1) {
        return edgeView.getPointAtRatio(num / 100);
    }
    return edgeView.getPointAtLength(num);
}

const orthogonal$1 = function (view, magnet, refPoint, options) {
    const angle = Angle.normalize(view.cell.getAngle());
    const bbox = view.getBBoxOfElement(magnet);
    const result = bbox.getCenter();
    const topLeft = bbox.getTopLeft();
    const bottomRight = bbox.getBottomRight();
    let padding = options.padding;
    if (!Number.isFinite(padding)) {
        padding = 0;
    }
    if (topLeft.y + padding <= refPoint.y &&
        refPoint.y <= bottomRight.y - padding) {
        const dy = refPoint.y - result.y;
        result.x +=
            angle === 0 || angle === 180
                ? 0
                : (dy * 1) / Math.tan(Angle.toRad(angle));
        result.y += dy;
    }
    else if (topLeft.x + padding <= refPoint.x &&
        refPoint.x <= bottomRight.x - padding) {
        const dx = refPoint.x - result.x;
        result.y +=
            angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));
        result.x += dx;
    }
    return result;
};
/**
 * Tries to place the anchor of the edge inside the view bbox so that the
 * edge is made orthogonal. The anchor is placed along two line segments
 * inside the view bbox (between the centers of the top and bottom side and
 * between the centers of the left and right sides). If it is not possible
 * to place the anchor so that the edge would be orthogonal, the anchor is
 * placed at the center of the view bbox instead.
 */
const orth$2 = resolve$1(orthogonal$1);

/**
 * Places the anchor of the edge at center of the node bbox.
 */
const nodeCenter = function (view, magnet, ref, options, endType) {
    const result = view.cell.getConnectionPoint(this.cell, endType);
    if (options.dx || options.dy) {
        result.translate(options.dx || 0, options.dy || 0);
    }
    return result;
};

const middleSide = function (view, magnet, refPoint, options) {
    let bbox;
    let angle = 0;
    let center;
    const node = view.cell;
    if (options.rotate) {
        bbox = view.getUnrotatedBBoxOfElement(magnet);
        center = node.getBBox().getCenter();
        angle = node.getAngle();
    }
    else {
        bbox = view.getBBoxOfElement(magnet);
    }
    const padding = options.padding;
    if (padding != null && Number.isFinite(padding)) {
        bbox.inflate(padding);
    }
    if (options.rotate) {
        refPoint.rotate(angle, center);
    }
    const side = bbox.getNearestSideToPoint(refPoint);
    let result;
    switch (side) {
        case 'left':
            result = bbox.getLeftMiddle();
            break;
        case 'right':
            result = bbox.getRightMiddle();
            break;
        case 'top':
            result = bbox.getTopCenter();
            break;
        case 'bottom':
            result = bbox.getBottomCenter();
            break;
    }
    const direction = options.direction;
    if (direction === 'H') {
        if (side === 'top' || side === 'bottom') {
            if (refPoint.x <= bbox.x + bbox.width) {
                result = bbox.getLeftMiddle();
            }
            else {
                result = bbox.getRightMiddle();
            }
        }
    }
    else if (direction === 'V') {
        if (refPoint.y <= bbox.y + bbox.height) {
            result = bbox.getTopCenter();
        }
        else {
            result = bbox.getBottomCenter();
        }
    }
    return options.rotate ? result.rotate(-angle, center) : result;
};
/**
 * Places the anchor of the edge in the middle of the side of view bbox
 * closest to the other endpoint.
 */
const midSide = resolve$1(middleSide);

const anchors$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    bottom,
    bottomLeft,
    bottomRight,
    center,
    left,
    midSide,
    nodeCenter,
    orth: orth$2,
    right,
    top,
    topLeft,
    topRight
}, Symbol.toStringTag, { value: 'Module' }));

var NodeAnchor;
(function (NodeAnchor) {
    NodeAnchor.presets = anchors$1;
    NodeAnchor.registry = Registry.create({
        type: 'node endpoint',
    });
    NodeAnchor.registry.register(NodeAnchor.presets, true);
})(NodeAnchor || (NodeAnchor = {}));

const ratio = function (view, magnet, ref, options) {
    let ratio = options.ratio != null ? options.ratio : 0.5;
    if (ratio > 1) {
        ratio /= 100;
    }
    return view.getPointAtRatio(ratio);
};

const length = function (view, magnet, ref, options) {
    const length = options.length != null ? options.length : 20;
    return view.getPointAtLength(length);
};

const getClosestPoint = function (view, magnet, refPoint, options) {
    const closestPoint = view.getClosestPoint(refPoint);
    return closestPoint != null ? closestPoint : new Point();
};
const closest = resolve$1(getClosestPoint);

const orthogonal = function (view, magnet, refPoint, options) {
    const OFFSET = 1e6;
    const path = view.getConnection();
    const segmentSubdivisions = view.getConnectionSubdivisions();
    const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
    const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
    const vIntersections = vLine.intersect(path, {
        segmentSubdivisions,
    });
    const hIntersections = hLine.intersect(path, {
        segmentSubdivisions,
    });
    const intersections = [];
    if (vIntersections) {
        intersections.push(...vIntersections);
    }
    if (hIntersections) {
        intersections.push(...hIntersections);
    }
    if (intersections.length > 0) {
        return refPoint.closest(intersections);
    }
    if (options.fallbackAt != null) {
        return getPointAtEdge(view, options.fallbackAt);
    }
    return call$1(getClosestPoint, this, view, magnet, refPoint, options);
};
const orth$1 = resolve$1(orthogonal);

const anchors = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    closest,
    length,
    orth: orth$1,
    ratio
}, Symbol.toStringTag, { value: 'Module' }));

var EdgeAnchor;
(function (EdgeAnchor) {
    EdgeAnchor.presets = anchors;
    EdgeAnchor.registry = Registry.create({
        type: 'edge endpoint',
    });
    EdgeAnchor.registry.register(EdgeAnchor.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));

function offset(p1, p2, offset) {
    let tx;
    if (typeof offset === 'object') {
        if (Number.isFinite(offset.y)) {
            const line = new Line(p2, p1);
            const { start, end } = line.parallel(offset.y);
            p2 = start; // eslint-disable-line
            p1 = end; // eslint-disable-line
        }
        tx = offset.x;
    }
    else {
        tx = offset;
    }
    if (tx == null || !Number.isFinite(tx)) {
        return p1;
    }
    const length = p1.distance(p2);
    if (tx === 0 && length > 0) {
        return p1;
    }
    return p1.move(p2, -Math.min(tx, length - 1));
}
function getStrokeWidth(magnet) {
    const stroke = magnet.getAttribute('stroke-width');
    if (stroke === null) {
        return 0;
    }
    return parseFloat(stroke) || 0;
}
function findShapeNode(magnet) {
    if (magnet == null) {
        return null;
    }
    let node = magnet;
    do {
        let tagName = node.tagName;
        if (typeof tagName !== 'string')
            return null;
        tagName = tagName.toUpperCase();
        if (tagName === 'G') {
            node = node.firstElementChild;
        }
        else if (tagName === 'TITLE') {
            node = node.nextElementSibling;
        }
        else
            break;
    } while (node);
    return node;
}

/**
 * Places the connection point at the intersection between the edge
 * path end segment and the target node bbox.
 */
const bbox = function (line, view, magnet, options) {
    const bbox = view.getBBoxOfElement(magnet);
    if (options.stroked) {
        bbox.inflate(getStrokeWidth(magnet) / 2);
    }
    const intersections = line.intersect(bbox);
    const p = intersections && intersections.length
        ? line.start.closest(intersections)
        : line.end;
    return offset(p, line.start, options.offset);
};

/**
 * Places the connection point at the intersection between the
 * link path end segment and the element's unrotated bbox.
 */
const rect = function (line, view, magnet, options, type) {
    const cell = view.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;
    if (angle === 0) {
        return call$1(bbox, this, line, view, magnet, options, type);
    }
    const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);
    if (options.stroked) {
        bboxRaw.inflate(getStrokeWidth(magnet) / 2);
    }
    const center = bboxRaw.getCenter();
    const lineRaw = line.clone().rotate(angle, center);
    const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
    const p = intersections && intersections.length
        ? lineRaw.start.closest(intersections).rotate(-angle, center)
        : line.end;
    return offset(p, line.start, options.offset);
};

/**
 * Places the connection point at the intersection between the
 * edge path end segment and the actual shape of the target magnet.
 */
const boundary = function (line, view, magnet, options) {
    let node;
    let intersection;
    const anchor = line.end;
    const selector = options.selector;
    if (typeof selector === 'string') {
        node = view.findOne(selector);
    }
    else if (Array.isArray(selector)) {
        node = getByPath(magnet, selector);
    }
    else {
        node = findShapeNode(magnet);
    }
    if (!isSVGGraphicsElement(node)) {
        if (node === magnet || !isSVGGraphicsElement(magnet)) {
            return anchor;
        }
        node = magnet;
    }
    const localShape = view.getShapeOfElement(node);
    const magnetMatrix = view.getMatrixOfElement(node);
    const translateMatrix = view.getRootTranslatedMatrix();
    const rotateMatrix = view.getRootRotatedMatrix();
    const targetMatrix = translateMatrix
        .multiply(rotateMatrix)
        .multiply(magnetMatrix);
    const localMatrix = targetMatrix.inverse();
    const localLine = Util.transformLine(line, localMatrix);
    const localRef = localLine.start.clone();
    const data = view.getDataOfElement(node);
    if (options.insideout === false) {
        if (data.shapeBBox == null) {
            data.shapeBBox = localShape.bbox();
        }
        const localBBox = data.shapeBBox;
        if (localBBox != null && localBBox.containsPoint(localRef)) {
            return anchor;
        }
    }
    if (options.extrapolate === true) {
        localLine.setLength(1e6);
    }
    // Caching segment subdivisions for paths
    let pathOptions;
    if (Path$1.isPath(localShape)) {
        const precision = options.precision || 2;
        if (data.segmentSubdivisions == null) {
            data.segmentSubdivisions = localShape.getSegmentSubdivisions({
                precision,
            });
        }
        pathOptions = {
            precision,
            segmentSubdivisions: data.segmentSubdivisions,
        };
        intersection = localLine.intersect(localShape, pathOptions);
    }
    else {
        intersection = localLine.intersect(localShape);
    }
    if (intersection) {
        if (Array.isArray(intersection)) {
            intersection = localRef.closest(intersection);
        }
    }
    else if (options.sticky === true) {
        // No intersection, find the closest point instead
        if (Rectangle.isRectangle(localShape)) {
            intersection = localShape.getNearestPointToPoint(localRef);
        }
        else if (Ellipse.isEllipse(localShape)) {
            intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);
        }
        else {
            intersection = localShape.closestPoint(localRef, pathOptions);
        }
    }
    const cp = intersection
        ? Util.transformPoint(intersection, targetMatrix)
        : anchor;
    let cpOffset = options.offset || 0;
    if (options.stroked !== false) {
        if (typeof cpOffset === 'object') {
            cpOffset = Object.assign({}, cpOffset);
            if (cpOffset.x == null) {
                cpOffset.x = 0;
            }
            cpOffset.x += getStrokeWidth(node) / 2;
        }
        else {
            cpOffset += getStrokeWidth(node) / 2;
        }
    }
    return offset(cp, line.start, cpOffset);
};

function alignLine(line, type, offset = 0) {
    const { start, end } = line;
    let a;
    let b;
    let direction;
    let coordinate;
    switch (type) {
        case 'left':
            coordinate = 'x';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'right':
            coordinate = 'x';
            a = start;
            b = end;
            direction = 1;
            break;
        case 'top':
            coordinate = 'y';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'bottom':
            coordinate = 'y';
            a = start;
            b = end;
            direction = 1;
            break;
        default:
            return;
    }
    if (start[coordinate] < end[coordinate]) {
        a[coordinate] = b[coordinate];
    }
    else {
        b[coordinate] = a[coordinate];
    }
    if (Number.isFinite(offset)) {
        a[coordinate] += direction * offset;
        b[coordinate] += direction * offset;
    }
}
/**
 * Places the connection point at the edge's endpoint.
 */
const anchor = function (line, view, magnet, options) {
    const { alignOffset, align } = options;
    if (align) {
        alignLine(line, align, alignOffset);
    }
    return offset(line.end, line.start, options.offset);
};

const connectionPoints = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    anchor,
    bbox,
    boundary,
    rect
}, Symbol.toStringTag, { value: 'Module' }));

var ConnectionPoint;
(function (ConnectionPoint) {
    ConnectionPoint.presets = connectionPoints;
    ConnectionPoint.registry = Registry.create({
        type: 'connection point',
    });
    ConnectionPoint.registry.register(ConnectionPoint.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));

const normal$1 = function (vertices) {
    return [...vertices];
};

/**
 * Routes the edge always to/from a certain side
 */
const oneSide = function (vertices, options, edgeView) {
    const side = options.side || 'bottom';
    const padding = normalizeSides(options.padding || 40);
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    let coord;
    let dim;
    let factor;
    switch (side) {
        case 'top':
            factor = -1;
            coord = 'y';
            dim = 'height';
            break;
        case 'left':
            factor = -1;
            coord = 'x';
            dim = 'width';
            break;
        case 'right':
            factor = 1;
            coord = 'x';
            dim = 'width';
            break;
        case 'bottom':
        default:
            factor = 1;
            coord = 'y';
            dim = 'height';
            break;
    }
    // Move the points from the center of the element to outside of it.
    sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
    targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]);
    // Make edge orthogonal (at least the first and last vertex).
    if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
        targetPoint[coord] = sourcePoint[coord];
    }
    else {
        sourcePoint[coord] = targetPoint[coord];
    }
    return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};

function getPointBBox(p) {
    return new Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
    const sides = normalizeSides(options.padding || 20);
    return {
        x: -sides.left,
        y: -sides.top,
        width: sides.left + sides.right,
        height: sides.top + sides.bottom,
    };
}
function getSourceBBox$1(view, options = {}) {
    return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox$1(view, options = {}) {
    return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const bbox = getSourceBBox$1(view, options);
    return bbox.getCenter();
}
function getTargetAnchor(view, options = {}) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const bbox = getTargetBBox$1(view, options);
    return bbox.getCenter();
}

/**
 * Returns a route with orthogonal line segments.
 */
const orth = function (vertices, options, edgeView) {
    let sourceBBox = getSourceBBox$1(edgeView, options);
    let targetBBox = getTargetBBox$1(edgeView, options);
    const sourceAnchor = getSourceAnchor(edgeView, options);
    const targetAnchor = getTargetAnchor(edgeView, options);
    // If anchor lies outside of bbox, the bbox expands to include it
    sourceBBox = sourceBBox.union(getPointBBox(sourceAnchor));
    targetBBox = targetBBox.union(getPointBBox(targetAnchor));
    const points = vertices.map((p) => Point.create(p));
    points.unshift(sourceAnchor);
    points.push(targetAnchor);
    // bearing of previous route segment
    let bearing = null;
    const result = [];
    for (let i = 0, len = points.length - 1; i < len; i += 1) {
        let route = null;
        const from = points[i];
        const to = points[i + 1];
        const isOrthogonal = Private.getBearing(from, to) != null;
        if (i === 0) {
            // source
            if (i + 1 === len) {
                // source -> target
                // Expand one of the nodes by 1px to detect situations when the two
                // nodes are positioned next to each other with no gap in between.
                if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
                    route = Private.insideNode(from, to, sourceBBox, targetBBox);
                }
                else if (!isOrthogonal) {
                    route = Private.nodeToNode(from, to, sourceBBox, targetBBox);
                }
            }
            else {
                // source -> vertex
                if (sourceBBox.containsPoint(to)) {
                    route = Private.insideNode(from, to, sourceBBox, getPointBBox(to).moveAndExpand(getPaddingBox(options)));
                }
                else if (!isOrthogonal) {
                    route = Private.nodeToVertex(from, to, sourceBBox);
                }
            }
        }
        else if (i + 1 === len) {
            // vertex -> target
            // prevent overlaps with previous line segment
            const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
                route = Private.insideNode(from, to, getPointBBox(from).moveAndExpand(getPaddingBox(options)), targetBBox, bearing);
            }
            else if (!isOrthogonal) {
                route = Private.vertexToNode(from, to, targetBBox, bearing);
            }
        }
        else if (!isOrthogonal) {
            // vertex -> vertex
            route = Private.vertexToVertex(from, to, bearing);
        }
        // set bearing for next iteration
        if (route) {
            result.push(...route.points);
            bearing = route.direction;
        }
        else {
            // orthogonal route and not looped
            bearing = Private.getBearing(from, to);
        }
        // push `to` point to identified orthogonal vertices array
        if (i + 1 < len) {
            result.push(to);
        }
    }
    return result;
};
var Private;
(function (Private) {
    /**
     * Bearing to opposite bearing map
     */
    const opposites = {
        N: 'S',
        S: 'N',
        E: 'W',
        W: 'E',
    };
    /**
     * Bearing to radians map
     */
    const radians = {
        N: (-Math.PI / 2) * 3,
        S: -Math.PI / 2,
        E: 0,
        W: Math.PI,
    };
    /**
     * Returns a point `p` where lines p,p1 and p,p2 are perpendicular
     * and p is not contained in the given box
     */
    function freeJoin(p1, p2, bbox) {
        let p = new Point(p1.x, p2.y);
        if (bbox.containsPoint(p)) {
            p = new Point(p2.x, p1.y);
        }
        // kept for reference
        // if (bbox.containsPoint(p)) {
        //   return null
        // }
        return p;
    }
    /**
     * Returns either width or height of a bbox based on the given bearing.
     */
    function getBBoxSize(bbox, bearing) {
        return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
    }
    Private.getBBoxSize = getBBoxSize;
    function getBearing(from, to) {
        if (from.x === to.x) {
            return from.y > to.y ? 'N' : 'S';
        }
        if (from.y === to.y) {
            return from.x > to.x ? 'W' : 'E';
        }
        return null;
    }
    Private.getBearing = getBearing;
    function vertexToVertex(from, to, bearing) {
        const p1 = new Point(from.x, to.y);
        const p2 = new Point(to.x, from.y);
        const d1 = getBearing(from, p1);
        const d2 = getBearing(from, p2);
        const opposite = bearing ? opposites[bearing] : null;
        const p = d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))
            ? p1
            : p2;
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.vertexToVertex = vertexToVertex;
    function nodeToVertex(from, to, fromBBox) {
        const p = freeJoin(from, to, fromBBox);
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.nodeToVertex = nodeToVertex;
    function vertexToNode(from, to, toBBox, bearing) {
        const points = [new Point(from.x, to.y), new Point(to.x, from.y)];
        const freePoints = points.filter((p) => !toBBox.containsPoint(p));
        const freeBearingPoints = freePoints.filter((p) => getBearing(p, from) !== bearing);
        let p;
        if (freeBearingPoints.length > 0) {
            // Try to pick a point which bears the same direction as the previous segment.
            p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop();
            p = p || freeBearingPoints[0];
            return {
                points: [p],
                direction: getBearing(p, to),
            };
        }
        {
            // Here we found only points which are either contained in the element or they would create
            // a link segment going in opposite direction from the previous one.
            // We take the point inside element and move it outside the element in the direction the
            // route is going. Now we can join this point with the current end (using freeJoin).
            p = difference$1(points, freePoints)[0];
            const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
            const p1 = freeJoin(p2, from, toBBox);
            return {
                points: [p1, p2],
                direction: getBearing(p2, to),
            };
        }
    }
    Private.vertexToNode = vertexToNode;
    function nodeToNode(from, to, fromBBox, toBBox) {
        let route = nodeToVertex(to, from, toBBox);
        const p1 = route.points[0];
        if (fromBBox.containsPoint(p1)) {
            route = nodeToVertex(from, to, fromBBox);
            const p2 = route.points[0];
            if (toBBox.containsPoint(p2)) {
                const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
                const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
                const mid = new Line(fromBorder, toBorder).getCenter();
                const startRoute = nodeToVertex(from, mid, fromBBox);
                const endRoute = vertexToVertex(mid, to, startRoute.direction);
                route.points = [startRoute.points[0], endRoute.points[0]];
                route.direction = endRoute.direction;
            }
        }
        return route;
    }
    Private.nodeToNode = nodeToNode;
    // Finds route for situations where one node is inside the other.
    // Typically the route is directed outside the outer node first and
    // then back towards the inner node.
    function insideNode(from, to, fromBBox, toBBox, bearing) {
        const boundary = fromBBox.union(toBBox).inflate(1);
        // start from the point which is closer to the boundary
        const center = boundary.getCenter();
        const reversed = center.distance(to) > center.distance(from);
        const start = reversed ? to : from;
        const end = reversed ? from : to;
        let p1;
        let p2;
        let p3;
        if (bearing) {
            // Points on circle with radius equals 'W + H` are always outside the rectangle
            // with width W and height H if the center of that circle is the center of that rectangle.
            p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
            p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);
        }
        else {
            p1 = boundary.getNearestPointToPoint(start).move(start, 1);
        }
        p2 = freeJoin(p1, end, boundary);
        let points;
        if (p1.round().equals(p2.round())) {
            p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
            p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();
            p3 = freeJoin(p1, p2, boundary);
            points = reversed ? [p2, p3, p1] : [p1, p3, p2];
        }
        else {
            points = reversed ? [p2, p1] : [p1, p2];
        }
        const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
        return {
            points,
            direction,
        };
    }
    Private.insideNode = insideNode;
})(Private || (Private = {}));

const defaults$1 = {
    step: 10,
    maxLoopCount: 2000,
    precision: 1,
    maxDirectionChange: 90,
    perpendicular: true,
    excludeTerminals: [],
    excludeNodes: [],
    excludeShapes: [],
    startDirections: ['top', 'right', 'bottom', 'left'],
    endDirections: ['top', 'right', 'bottom', 'left'],
    directionMap: {
        top: { x: 0, y: -1 },
        right: { x: 1, y: 0 },
        bottom: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
    },
    cost() {
        const step = resolve(this.step, this);
        return step;
    },
    directions() {
        const step = resolve(this.step, this);
        const cost = resolve(this.cost, this);
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost, offsetX: -step, offsetY: 0 },
            { cost, offsetX: 0, offsetY: step },
            { cost, offsetX: 0, offsetY: -step },
        ];
    },
    penalties() {
        const step = resolve(this.step, this);
        return {
            0: 0,
            45: step / 2,
            90: step / 2,
        };
    },
    paddingBox() {
        const step = resolve(this.step, this);
        return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step,
        };
    },
    fallbackRouter: orth,
    draggingRouter: null,
    snapToGrid: true,
};
function resolve(input, options) {
    if (typeof input === 'function') {
        return input.call(options);
    }
    return input;
}
function resolveOptions(options) {
    const result = Object.keys(options).reduce((memo, key) => {
        const ret = memo;
        if (key === 'fallbackRouter' ||
            key === 'draggingRouter' ||
            key === 'fallbackRoute') {
            ret[key] = options[key];
        }
        else {
            ret[key] = resolve(options[key], options);
        }
        return memo;
    }, {});
    if (result.padding) {
        const sides = normalizeSides(result.padding);
        result.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom,
        };
    }
    result.directions.forEach((direction) => {
        const point1 = new Point(0, 0);
        const point2 = new Point(direction.offsetX, direction.offsetY);
        direction.angle = Angle.normalize(point1.theta(point2));
    });
    return result;
}

const OPEN = 1;
const CLOSE = 2;
class SortedSet {
    constructor() {
        this.items = [];
        this.hash = {};
        this.values = {};
    }
    add(item, value) {
        if (this.hash[item]) {
            // item removal
            this.items.splice(this.items.indexOf(item), 1);
        }
        else {
            this.hash[item] = OPEN;
        }
        this.values[item] = value;
        const index = sortedIndexBy(this.items, item, (key) => this.values[key]);
        this.items.splice(index, 0, item);
    }
    pop() {
        const item = this.items.shift();
        if (item) {
            this.hash[item] = CLOSE;
        }
        return item;
    }
    isOpen(item) {
        return this.hash[item] === OPEN;
    }
    isClose(item) {
        return this.hash[item] === CLOSE;
    }
    isEmpty() {
        return this.items.length === 0;
    }
}

/**
 * Helper structure to identify whether a point lies inside an obstacle.
 */
class ObstacleMap {
    constructor(options) {
        this.options = options;
        this.mapGridSize = 100;
        this.map = {};
    }
    /**
     * Builds a map of all nodes for quicker obstacle queries i.e. is a point
     * contained in any obstacle?
     *
     * A simplified grid search.
     */
    build(model, edge) {
        const options = this.options;
        // source or target node could be excluded from set of obstacles
        const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
            const terminal = edge[type];
            if (terminal) {
                const cell = model.getCell(terminal.cell);
                if (cell) {
                    memo.push(cell);
                }
            }
            return memo;
        }, []);
        let excludedAncestors = [];
        const source = model.getCell(edge.getSourceCellId());
        if (source) {
            excludedAncestors = union$1(excludedAncestors, source.getAncestors().map((cell) => cell.id));
        }
        const target = model.getCell(edge.getTargetCellId());
        if (target) {
            excludedAncestors = union$1(excludedAncestors, target.getAncestors().map((cell) => cell.id));
        }
        // The graph is divided into smaller cells, where each holds information
        // about which node belong to it. When we query whether a point lies
        // inside an obstacle we don't need to go through all obstacles, we check
        // only those in a particular cell.
        const mapGridSize = this.mapGridSize;
        model.getNodes().reduce((map, node) => {
            const excludedTerminal = excludedTerminals.some((cell) => cell.id === node.id);
            const excludedShape = node.shape
                ? options.excludeShapes.includes(node.shape)
                : false;
            const excludedNode = options.excludeNodes.some((item) => {
                if (typeof item === 'string') {
                    return node.id === item;
                }
                return item === node;
            });
            const excludedAncestor = excludedAncestors.includes(node.id);
            const excluded = excludedShape || excludedTerminal || excludedNode || excludedAncestor;
            if (node.isVisible() && !excluded) {
                const bbox = node.getBBox().moveAndExpand(options.paddingBox);
                const origin = bbox.getOrigin().snapToGrid(mapGridSize);
                const corner = bbox.getCorner().snapToGrid(mapGridSize);
                for (let x = origin.x; x <= corner.x; x += mapGridSize) {
                    for (let y = origin.y; y <= corner.y; y += mapGridSize) {
                        const key = new Point(x, y).toString();
                        if (map[key] == null) {
                            map[key] = [];
                        }
                        map[key].push(bbox);
                    }
                }
            }
            return map;
        }, this.map);
        return this;
    }
    isAccessible(point) {
        const key = point.clone().snapToGrid(this.mapGridSize).toString();
        const rects = this.map[key];
        return rects ? rects.every((rect) => !rect.containsPoint(point)) : true;
    }
}

function getSourceBBox(view, options) {
    const bbox = view.sourceBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getTargetBBox(view, options) {
    const bbox = view.targetBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getSourceEndpoint(view, options) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const sourceBBox = getSourceBBox(view, options);
    return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const targetBBox = getTargetBBox(view, options);
    return targetBBox.getCenter();
}
// returns a direction index from start point to end point
// corrects for grid deformation between start and end
function getDirectionAngle(start, end, directionCount, grid, options) {
    const quadrant = 360 / directionCount;
    const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
    return quadrant * Math.floor(normalizedAngle / quadrant);
}
function fixAngleEnd(start, end, grid, options) {
    const step = options.step;
    const diffX = end.x - start.x;
    const diffY = end.y - start.y;
    const gridStepsX = diffX / grid.x;
    const gridStepsY = diffY / grid.y;
    const distanceX = gridStepsX * step;
    const distanceY = gridStepsY * step;
    return new Point(start.x + distanceX, start.y + distanceY);
}
/**
 * Returns the change in direction between two direction angles.
 */
function getDirectionChange(angle1, angle2) {
    const change = Math.abs(angle1 - angle2);
    return change > 180 ? 360 - change : change;
}
// fix direction offsets according to current grid
function getGridOffsets(grid, options) {
    const step = options.step;
    options.directions.forEach((direction) => {
        direction.gridOffsetX = (direction.offsetX / step) * grid.x;
        direction.gridOffsetY = (direction.offsetY / step) * grid.y;
    });
    return options.directions;
}
// get grid size in x and y dimensions, adapted to source and target positions
function getGrid(step, source, target) {
    return {
        source: source.clone(),
        x: getGridDimension(target.x - source.x, step),
        y: getGridDimension(target.y - source.y, step),
    };
}
function getGridDimension(diff, step) {
    // return step if diff = 0
    if (!diff) {
        return step;
    }
    const abs = Math.abs(diff);
    const count = Math.round(abs / step);
    // return `abs` if less than one step apart
    if (!count) {
        return abs;
    }
    // otherwise, return corrected step
    const roundedDiff = count * step;
    const remainder = abs - roundedDiff;
    const correction = remainder / count;
    return step + correction;
}
function snapGrid(point, grid) {
    const source = grid.source;
    const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x;
    const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y;
    return new Point(x, y);
}
function round(point, precision) {
    return point.round(precision);
}
function align(point, grid, precision) {
    return round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
    return point.toString();
}
function normalizePoint(point) {
    return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
    let min = Infinity;
    for (let i = 0, len = anchors.length; i < len; i += 1) {
        const dist = from.manhattanDistance(anchors[i]);
        if (dist < min) {
            min = dist;
        }
    }
    return min;
}
// Find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)
function getRectPoints(anchor, bbox, directionList, grid, options) {
    const precision = options.precision;
    const directionMap = options.directionMap;
    const centerVector = anchor.diff(bbox.getCenter());
    const rectPoints = Object.keys(directionMap).reduce((res, key) => {
        if (directionList.includes(key)) {
            const direction = directionMap[key];
            // Create a line that is guaranteed to intersect the bbox if bbox
            // is in the direction even if anchor lies outside of bbox.
            const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));
            const intersectionLine = new Line(anchor, ending);
            // Get the farther intersection, in case there are two
            // (that happens if anchor lies next to bbox)
            const intersections = intersectionLine.intersect(bbox) || [];
            let farthestIntersectionDistance;
            let farthestIntersection = null;
            for (let i = 0; i < intersections.length; i += 1) {
                const intersection = intersections[i];
                const distance = anchor.squaredDistance(intersection);
                if (farthestIntersectionDistance == null ||
                    distance > farthestIntersectionDistance) {
                    farthestIntersectionDistance = distance;
                    farthestIntersection = intersection;
                }
            }
            // If an intersection was found in this direction, it is our rectPoint
            if (farthestIntersection) {
                let target = align(farthestIntersection, grid, precision);
                // If the rectPoint lies inside the bbox, offset it by one more step
                if (bbox.containsPoint(target)) {
                    target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
                }
                res.push(target);
            }
        }
        return res;
    }, []);
    // if anchor lies outside of bbox, add it to the array of points
    if (!bbox.containsPoint(anchor)) {
        rectPoints.push(align(anchor, grid, precision));
    }
    return rectPoints;
}
// reconstructs a route by concatenating points with their parents
function reconstructRoute(parents, points, tailPoint, from, to) {
    const route = [];
    let prevDiff = normalizePoint(to.diff(tailPoint));
    // tailPoint is assumed to be aligned already
    let currentKey = getKey(tailPoint);
    let parent = parents[currentKey];
    let point;
    while (parent) {
        // point is assumed to be aligned already
        point = points[currentKey];
        const diff = normalizePoint(point.diff(parent));
        if (!diff.equals(prevDiff)) {
            route.unshift(point);
            prevDiff = diff;
        }
        // parent is assumed to be aligned already
        currentKey = getKey(parent);
        parent = parents[currentKey];
    }
    // leadPoint is assumed to be aligned already
    const leadPoint = points[currentKey];
    const fromDiff = normalizePoint(leadPoint.diff(from));
    if (!fromDiff.equals(prevDiff)) {
        route.unshift(leadPoint);
    }
    return route;
}

/**
 * Finds the route between two points (`from`, `to`).
 */
function findRoute(edgeView, from, to, map, options) {
    const precision = options.precision;
    let sourceEndpoint;
    let targetEndpoint;
    if (Rectangle.isRectangle(from)) {
        sourceEndpoint = round(getSourceEndpoint(edgeView, options).clone(), precision);
    }
    else {
        sourceEndpoint = round(from.clone(), precision);
    }
    if (Rectangle.isRectangle(to)) {
        targetEndpoint = round(getTargetEndpoint(edgeView, options).clone(), precision);
    }
    else {
        targetEndpoint = round(to.clone(), precision);
    }
    // Get grid for this route.
    const grid = getGrid(options.step, sourceEndpoint, targetEndpoint);
    // Get pathfinding points.
    // -----------------------
    const startPoint = sourceEndpoint;
    const endPoint = targetEndpoint;
    let startPoints;
    let endPoints;
    if (Rectangle.isRectangle(from)) {
        startPoints = getRectPoints(startPoint, from, options.startDirections, grid, options);
    }
    else {
        startPoints = [startPoint];
    }
    if (Rectangle.isRectangle(to)) {
        endPoints = getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
    }
    else {
        endPoints = [endPoint];
    }
    // take into account only accessible rect points (those not under obstacles)
    startPoints = startPoints.filter((p) => map.isAccessible(p));
    endPoints = endPoints.filter((p) => map.isAccessible(p));
    // There is an accessible route point on both sides.
    if (startPoints.length > 0 && endPoints.length > 0) {
        const openSet = new SortedSet();
        // Keeps the actual points for given nodes of the open set.
        const points = {};
        // Keeps the point that is immediate predecessor of given element.
        const parents = {};
        // Cost from start to a point along best known path.
        const costs = {};
        for (let i = 0, n = startPoints.length; i < n; i += 1) {
            // startPoint is assumed to be aligned already
            const startPoint = startPoints[i];
            const key = getKey(startPoint);
            openSet.add(key, getCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
        }
        const previousRouteDirectionAngle = options.previousDirectionAngle;
        // undefined for first route
        const isPathBeginning = previousRouteDirectionAngle === undefined;
        // directions
        let direction;
        let directionChange;
        const directions = getGridOffsets(grid, options);
        const numDirections = directions.length;
        const endPointsKeys = endPoints.reduce((res, endPoint) => {
            const key = getKey(endPoint);
            res.push(key);
            return res;
        }, []);
        // main route finding loop
        const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);
        let loopsRemaining = options.maxLoopCount;
        while (!openSet.isEmpty() && loopsRemaining > 0) {
            // Get the closest item and mark it CLOSED
            const currentKey = openSet.pop();
            const currentPoint = points[currentKey];
            const currentParent = parents[currentKey];
            const currentCost = costs[currentKey];
            const isStartPoint = currentPoint.equals(startPoint);
            const isRouteBeginning = currentParent == null;
            let previousDirectionAngle;
            if (!isRouteBeginning) {
                previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
            }
            else if (!isPathBeginning) {
                // a vertex on the route
                previousDirectionAngle = previousRouteDirectionAngle;
            }
            else if (!isStartPoint) {
                // beginning of route on the path
                previousDirectionAngle = getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
            }
            else {
                previousDirectionAngle = null;
            }
            // Check if we reached any endpoint
            const skipEndCheck = isRouteBeginning && sameStartEndPoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
                options.previousDirectionAngle = previousDirectionAngle;
                return reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
            }
            // Go over all possible directions and find neighbors
            for (let i = 0; i < numDirections; i += 1) {
                direction = directions[i];
                const directionAngle = direction.angle;
                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
                // Don't use the point changed rapidly.
                if (!(isPathBeginning && isStartPoint) &&
                    directionChange > options.maxDirectionChange) {
                    continue;
                }
                const neighborPoint = align(currentPoint
                    .clone()
                    .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
                const neighborKey = getKey(neighborPoint);
                // Closed points were already evaluated.
                if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
                    continue;
                }
                // Neighbor is an end point.
                if (endPointsKeys.indexOf(neighborKey) >= 0) {
                    const isEndPoint = neighborPoint.equals(endPoint);
                    if (!isEndPoint) {
                        const endDirectionAngle = getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
                        const endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
                        if (endDirectionChange > options.maxDirectionChange) {
                            continue;
                        }
                    }
                }
                // The current direction is ok.
                // ----------------------------
                const neighborCost = direction.cost;
                const neighborPenalty = isStartPoint
                    ? 0
                    : options.penalties[directionChange];
                const costFromStart = currentCost + neighborCost + neighborPenalty;
                // Neighbor point has not been processed yet or the cost of
                // the path from start is lower than previously calculated.
                if (!openSet.isOpen(neighborKey) ||
                    costFromStart < costs[neighborKey]) {
                    points[neighborKey] = neighborPoint;
                    parents[neighborKey] = currentPoint;
                    costs[neighborKey] = costFromStart;
                    openSet.add(neighborKey, costFromStart + getCost(neighborPoint, endPoints));
                }
            }
            loopsRemaining -= 1;
        }
    }
    if (options.fallbackRoute) {
        return call$1(options.fallbackRoute, this, startPoint, endPoint, options);
    }
    return null;
}
function snap(vertices, gridSize = 10) {
    if (vertices.length <= 1) {
        return vertices;
    }
    for (let i = 0, len = vertices.length; i < len - 1; i += 1) {
        const first = vertices[i];
        const second = vertices[i + 1];
        if (first.x === second.x) {
            const x = gridSize * Math.round(first.x / gridSize);
            if (first.x !== x) {
                first.x = x;
                second.x = x;
            }
        }
        else if (first.y === second.y) {
            const y = gridSize * Math.round(first.y / gridSize);
            if (first.y !== y) {
                first.y = y;
                second.y = y;
            }
        }
    }
    return vertices;
}
const router = function (vertices, optionsRaw, edgeView) {
    const options = resolveOptions(optionsRaw);
    const sourceBBox = getSourceBBox(edgeView, options);
    const targetBBox = getTargetBBox(edgeView, options);
    const sourceEndpoint = getSourceEndpoint(edgeView, options);
    // pathfinding
    const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
    const oldVertices = vertices.map((p) => Point.create(p));
    const newVertices = [];
    // The origin of first route's grid, does not need snapping
    let tailPoint = sourceEndpoint;
    let from;
    let to;
    for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
        let partialRoute = null;
        from = to || sourceBBox;
        to = oldVertices[i];
        // This is the last iteration
        if (to == null) {
            to = targetBBox;
            // If the target is a point, we should use dragging route
            // instead of main routing method if it has been provided.
            const edge = edgeView.cell;
            const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;
            if (isEndingAtPoint && typeof options.draggingRouter === 'function') {
                const dragFrom = from === sourceBBox ? sourceEndpoint : from;
                const dragTo = to.getOrigin();
                partialRoute = call$1(options.draggingRouter, edgeView, dragFrom, dragTo, options);
            }
        }
        // Find the partial route
        if (partialRoute == null) {
            partialRoute = findRoute(edgeView, from, to, map, options);
        }
        // Cannot found the partial route.
        if (partialRoute === null) {
            // eslint-next-line
            console.warn(`Unable to execute manhattan algorithm, use orth instead`);
            return call$1(options.fallbackRouter, this, vertices, options, edgeView);
        }
        // Remove the first point if the previous partial route has
        // the same point as last.
        const leadPoint = partialRoute[0];
        if (leadPoint && leadPoint.equals(tailPoint)) {
            partialRoute.shift();
        }
        // Save tailPoint for next iteration
        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
        newVertices.push(...partialRoute);
    }
    if (options.snapToGrid) {
        return snap(newVertices, edgeView.graph.grid.getGridSize());
    }
    return newVertices;
};

const manhattan = function (vertices, options, edgeView) {
    return call$1(router, this, vertices, Object.assign(Object.assign({}, defaults$1), options), edgeView);
};

const defaults = {
    maxDirectionChange: 45,
    // an array of directions to find next points on the route
    // different from start/end directions
    directions() {
        const step = resolve(this.step, this);
        const cost = resolve(this.cost, this);
        const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)); // eslint-disable-line no-bitwise
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost: diagonalCost, offsetX: step, offsetY: step },
            { cost, offsetX: 0, offsetY: step },
            { cost: diagonalCost, offsetX: -step, offsetY: step },
            { cost, offsetX: -step, offsetY: 0 },
            { cost: diagonalCost, offsetX: -step, offsetY: -step },
            { cost, offsetX: 0, offsetY: -step },
            { cost: diagonalCost, offsetX: step, offsetY: -step },
        ];
    },
    // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute(from, to, options) {
        // Find a route which breaks by 45 degrees ignoring all obstacles.
        const theta = from.theta(to);
        const route = [];
        let a = { x: to.x, y: from.y };
        let b = { x: from.x, y: to.y };
        if (theta % 180 > 90) {
            const t = a;
            a = b;
            b = t;
        }
        const p1 = theta % 90 < 45 ? a : b;
        const l1 = new Line(from, p1);
        const alpha = 90 * Math.ceil(theta / 90);
        const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);
        const l2 = new Line(to, p2);
        const intersectionPoint = l1.intersectsWithLine(l2);
        const point = intersectionPoint || to;
        const directionFrom = intersectionPoint ? point : from;
        const quadrant = 360 / options.directions.length;
        const angleTheta = directionFrom.theta(to);
        const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
        const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
        options.previousDirectionAngle = directionAngle;
        if (point)
            route.push(point.round());
        route.push(to);
        return route;
    },
};
const metro = function (vertices, options, linkView) {
    return call$1(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);
};

const er = function (vertices, options, edgeView) {
    const offsetRaw = options.offset || 32;
    const min = options.min == null ? 16 : options.min;
    let offset = 0;
    let direction = options.direction;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    if (typeof offsetRaw === 'number') {
        offset = offsetRaw;
    }
    if (direction == null) {
        let dx = targetBBox.left - sourceBBox.right;
        let dy = targetBBox.top - sourceBBox.bottom;
        if (dx >= 0 && dy >= 0) {
            direction = dx >= dy ? 'L' : 'T';
        }
        else if (dx <= 0 && dy >= 0) {
            dx = sourceBBox.left - targetBBox.right;
            if (dx >= 0) {
                direction = dx >= dy ? 'R' : 'T';
            }
            else {
                direction = 'T';
            }
        }
        else if (dx >= 0 && dy <= 0) {
            dy = sourceBBox.top - targetBBox.bottom;
            if (dy >= 0) {
                direction = dx >= dy ? 'L' : 'B';
            }
            else {
                direction = 'L';
            }
        }
        else {
            dx = sourceBBox.left - targetBBox.right;
            dy = sourceBBox.top - targetBBox.bottom;
            if (dx >= 0 && dy >= 0) {
                direction = dx >= dy ? 'R' : 'B';
            }
            else if (dx <= 0 && dy >= 0) {
                direction = 'B';
            }
            else if (dx >= 0 && dy <= 0) {
                direction = 'R';
            }
            else {
                direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B';
            }
        }
    }
    if (direction === 'H') {
        direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R';
    }
    else if (direction === 'V') {
        direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B';
    }
    if (offsetRaw === 'center') {
        if (direction === 'L') {
            offset = (targetBBox.left - sourceBBox.right) / 2;
        }
        else if (direction === 'R') {
            offset = (sourceBBox.left - targetBBox.right) / 2;
        }
        else if (direction === 'T') {
            offset = (targetBBox.top - sourceBBox.bottom) / 2;
        }
        else if (direction === 'B') {
            offset = (sourceBBox.top - targetBBox.bottom) / 2;
        }
    }
    let coord;
    let dim;
    let factor;
    const horizontal = direction === 'L' || direction === 'R';
    if (horizontal) {
        if (targetPoint.y === sourcePoint.y) {
            return [...vertices];
        }
        factor = direction === 'L' ? 1 : -1;
        coord = 'x';
        dim = 'width';
    }
    else {
        if (targetPoint.x === sourcePoint.x) {
            return [...vertices];
        }
        factor = direction === 'T' ? 1 : -1;
        coord = 'y';
        dim = 'height';
    }
    const source = sourcePoint.clone();
    const target = targetPoint.clone();
    source[coord] += factor * (sourceBBox[dim] / 2 + offset);
    target[coord] -= factor * (targetBBox[dim] / 2 + offset);
    if (horizontal) {
        const sourceX = source.x;
        const targetX = target.x;
        const sourceDelta = sourceBBox.width / 2 + min;
        const targetDelta = targetBBox.width / 2 + min;
        if (targetPoint.x > sourcePoint.x) {
            if (targetX <= sourceX) {
                source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
                target.x = Math.min(sourceX, targetPoint.x - targetDelta);
            }
        }
        else if (targetX >= sourceX) {
            source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
            target.x = Math.max(sourceX, targetPoint.x + targetDelta);
        }
    }
    else {
        const sourceY = source.y;
        const targetY = target.y;
        const sourceDelta = sourceBBox.height / 2 + min;
        const targetDelta = targetBBox.height / 2 + min;
        if (targetPoint.y > sourcePoint.y) {
            if (targetY <= sourceY) {
                source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
                target.y = Math.min(sourceY, targetPoint.y - targetDelta);
            }
        }
        else if (targetY >= sourceY) {
            source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
            target.y = Math.max(sourceY, targetPoint.y + targetDelta);
        }
    }
    return [source.toJSON(), ...vertices, target.toJSON()];
};

function rollup(points, merge) {
    if (merge != null && merge !== false) {
        const amount = typeof merge === 'boolean' ? 0 : merge;
        if (amount > 0) {
            const center1 = Point.create(points[1]).move(points[2], amount);
            const center2 = Point.create(points[1]).move(points[0], amount);
            return [center1.toJSON(), ...points, center2.toJSON()];
        }
        {
            const center = points[1];
            return [Object.assign({}, center), ...points, Object.assign({}, center)];
        }
    }
    return points;
}
const loop$1 = function (vertices, options, edgeView) {
    const width = options.width || 50;
    const height = options.height || 80;
    const halfHeight = height / 2;
    const angle = options.angle || 'auto';
    const sourceAnchor = edgeView.sourceAnchor;
    const targetAnchor = edgeView.targetAnchor;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    if (sourceAnchor.equals(targetAnchor)) {
        const getVertices = (angle) => {
            const rad = Angle.toRad(angle);
            const sin = Math.sin(rad);
            const cos = Math.cos(rad);
            const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);
            const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);
            const p1 = ref.clone().rotate(-90, center);
            const p2 = ref.clone().rotate(90, center);
            return [p1.toJSON(), center.toJSON(), p2.toJSON()];
        };
        const validate = (end) => {
            const start = sourceAnchor.clone().move(end, -1);
            const line = new Line(start, end);
            return (!sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line));
        };
        const angles = [0, 90, 180, 270, 45, 135, 225, 315];
        if (typeof angle === 'number') {
            return rollup(getVertices(angle), options.merge);
        }
        const center = sourceBBox.getCenter();
        if (center.equals(sourceAnchor)) {
            return rollup(getVertices(0), options.merge);
        }
        const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));
        let ret = getVertices(deg);
        if (validate(ret[1])) {
            return rollup(ret, options.merge);
        }
        // return the best vertices
        for (let i = 1, l = angles.length; i < l; i += 1) {
            ret = getVertices(deg + angles[i]);
            if (validate(ret[1])) {
                return rollup(ret, options.merge);
            }
        }
        return rollup(ret, options.merge);
    }
    {
        const line = new Line(sourceAnchor, targetAnchor);
        let parallel = line.parallel(-width);
        let center = parallel.getCenter();
        let p1 = parallel.start.clone().move(parallel.end, halfHeight);
        let p2 = parallel.end.clone().move(parallel.start, halfHeight);
        const ref = line.parallel(-1);
        const line1 = new Line(ref.start, center);
        const line2 = new Line(ref.end, center);
        if (sourceBBox.containsPoint(center) ||
            targetBBox.containsPoint(center) ||
            sourceBBox.intersectsWithLine(line1) ||
            sourceBBox.intersectsWithLine(line2) ||
            targetBBox.intersectsWithLine(line1) ||
            targetBBox.intersectsWithLine(line2)) {
            parallel = line.parallel(width);
            center = parallel.getCenter();
            p1 = parallel.start.clone().move(parallel.end, halfHeight);
            p2 = parallel.end.clone().move(parallel.start, halfHeight);
        }
        if (options.merge) {
            const line = new Line(sourceAnchor, targetAnchor);
            const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);
            const intersects1 = sourceBBox.intersectsWithLine(normal);
            const intersects2 = targetBBox.intersectsWithLine(normal);
            const intersects = intersects1
                ? Array.isArray(intersects1)
                    ? intersects1
                    : [intersects1]
                : [];
            if (intersects2) {
                if (Array.isArray(intersects2)) {
                    intersects.push(...intersects2);
                }
                else {
                    intersects.push(intersects2);
                }
            }
            const anchor = line.center.closest(intersects);
            if (anchor) {
                edgeView.sourceAnchor = anchor.clone();
                edgeView.targetAnchor = anchor.clone();
            }
            else {
                edgeView.sourceAnchor = line.center.clone();
                edgeView.targetAnchor = line.center.clone();
            }
        }
        return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);
    }
};

const routers = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    er,
    loop: loop$1,
    manhattan,
    metro,
    normal: normal$1,
    oneSide,
    orth
}, Symbol.toStringTag, { value: 'Module' }));

var Router;
(function (Router) {
    Router.presets = routers;
    Router.registry = Registry.create({
        type: 'router',
    });
    Router.registry.register(Router.presets, true);
})(Router || (Router = {}));

const normal = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const polyline = new Polyline(points);
    const path = new Path$1(polyline);
    return options.raw ? path : path.serialize();
};

const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const fix = routePoints.length === 3 ? 0 : 1;
    const p1 = Point.create(routePoints[0 + fix]);
    const p2 = Point.create(routePoints[2 + fix]);
    const center = Point.create(routePoints[1 + fix]);
    if (!Point.equals(sourcePoint, targetPoint)) {
        const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
        const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);
        if (angle > 1) {
            p1.rotate(180 - angle, middle);
            p2.rotate(180 - angle, middle);
            center.rotate(180 - angle, middle);
        }
    }
    const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center.x} ${center.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
    return options.raw ? Path$1.parse(pathData) : pathData;
};

const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const path = new Path$1();
    path.appendSegment(Path$1.createSegment('M', sourcePoint));
    const f13 = 1 / 3;
    const f23 = 2 / 3;
    const radius = options.radius || 10;
    let prevDistance;
    let nextDistance;
    for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
        const curr = Point.create(routePoints[i]);
        const prev = routePoints[i - 1] || sourcePoint;
        const next = routePoints[i + 1] || targetPoint;
        prevDistance = nextDistance || curr.distance(prev) / 2;
        nextDistance = curr.distance(next) / 2;
        const startMove = -Math.min(radius, prevDistance);
        const endMove = -Math.min(radius, nextDistance);
        const roundedStart = curr.clone().move(prev, startMove).round();
        const roundedEnd = curr.clone().move(next, endMove).round();
        const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
        const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
        path.appendSegment(Path$1.createSegment('L', roundedStart));
        path.appendSegment(Path$1.createSegment('C', control1, control2, roundedEnd));
    }
    path.appendSegment(Path$1.createSegment('L', targetPoint));
    return options.raw ? path : path.serialize();
};

const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {
    let path;
    let direction = options.direction;
    if (routePoints && routePoints.length !== 0) {
        const points = [sourcePoint, ...routePoints, targetPoint];
        const curves = Curve.throughPoints(points);
        path = new Path$1(curves);
    }
    else {
        // If we have no route, use a default cubic bezier curve, cubic bezier
        // requires two control points, the control points have `x` midway
        // between source and target. This produces an S-like curve.
        path = new Path$1();
        path.appendSegment(Path$1.createSegment('M', sourcePoint));
        if (!direction) {
            direction =
                Math.abs(sourcePoint.x - targetPoint.x) >=
                    Math.abs(sourcePoint.y - targetPoint.y)
                    ? 'H'
                    : 'V';
        }
        if (direction === 'H') {
            const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            path.appendSegment(Path$1.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
        }
        else {
            const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            path.appendSegment(Path$1.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
        }
    }
    return options.raw ? path : path.serialize();
};

/* eslint-disable no-underscore-dangle */
// takes care of math. error for case when jump is too close to end of line
const CLOSE_PROXIMITY_PADDING = 1;
const F13 = 1 / 3;
const F23 = 2 / 3;
function setupUpdating(view) {
    let updateList = view.graph._jumpOverUpdateList;
    // first time setup for this paper
    if (updateList == null) {
        updateList = view.graph._jumpOverUpdateList = [];
        view.graph.on('cell:mouseup', () => {
            const list = view.graph._jumpOverUpdateList;
            // add timeout to wait for the target node to be connected
            // fix https://github.com/antvis/X6/issues/3387
            setTimeout(() => {
                for (let i = 0; i < list.length; i += 1) {
                    list[i].update();
                }
            });
        });
        view.graph.on('model:reseted', () => {
            updateList = view.graph._jumpOverUpdateList = [];
        });
    }
    // add this link to a list so it can be updated when some other link is updated
    if (updateList.indexOf(view) < 0) {
        updateList.push(view);
        // watch for change of connector type or removal of link itself
        // to remove the link from a list of jump over connectors
        const clean = () => updateList.splice(updateList.indexOf(view), 1);
        view.cell.once('change:connector', clean);
        view.cell.once('removed', clean);
    }
}
function createLines(sourcePoint, targetPoint, route = []) {
    const points = [sourcePoint, ...route, targetPoint];
    const lines = [];
    points.forEach((point, idx) => {
        const next = points[idx + 1];
        if (next != null) {
            lines.push(new Line(point, next));
        }
    });
    return lines;
}
function findLineIntersections(line, crossCheckLines) {
    const intersections = [];
    crossCheckLines.forEach((crossCheckLine) => {
        const intersection = line.intersectsWithLine(crossCheckLine);
        if (intersection) {
            intersections.push(intersection);
        }
    });
    return intersections;
}
function getDistence(p1, p2) {
    return new Line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 */
function createJumps(line, intersections, jumpSize) {
    return intersections.reduce((memo, point, idx) => {
        // skipping points that were merged with the previous line
        // to make bigger arc over multiple lines that are close to each other
        if (skippedPoints.includes(point)) {
            return memo;
        }
        // always grab the last line from buffer and modify it
        const lastLine = memo.pop() || line;
        // calculate start and end of jump by moving by a given size of jump
        const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);
        let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);
        // now try to look at the next intersection point
        const nextPoint = intersections[idx + 1];
        if (nextPoint != null) {
            const distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
                // next point is close enough, move the jump end by this
                // difference and mark the next point to be skipped
                jumpEnd = nextPoint.move(lastLine.start, distance);
                skippedPoints.push(nextPoint);
            }
        }
        else {
            // this block is inside of `else` as an optimization so the distance is
            // not calculated when we know there are no other intersection points
            const endDistance = jumpStart.distance(lastLine.end);
            // if the end is too close to possible jump, draw remaining line instead of a jump
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
                memo.push(lastLine);
                return memo;
            }
        }
        const startDistance = jumpEnd.distance(lastLine.start);
        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            // if the start of line is too close to jump, draw that line instead of a jump
            memo.push(lastLine);
            return memo;
        }
        // finally create a jump line
        const jumpLine = new Line(jumpStart, jumpEnd);
        // it's just simple line but with a `isJump` property
        jumppedLines.push(jumpLine);
        memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));
        return memo;
    }, []);
}
function buildPath(lines, jumpSize, jumpType, radius) {
    const path = new Path$1();
    let segment;
    // first move to the start of a first line
    segment = Path$1.createSegment('M', lines[0].start);
    path.appendSegment(segment);
    lines.forEach((line, index) => {
        if (jumppedLines.includes(line)) {
            let angle;
            let diff;
            let control1;
            let control2;
            if (jumpType === 'arc') {
                // approximates semicircle with 2 curves
                angle = -90;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    angle += 180;
                }
                const center = line.getCenter();
                const centerLine = new Line(center, line.end).rotate(angle, center);
                let halfLine;
                // first half
                halfLine = new Line(line.start, center);
                control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);
                control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
                segment = Path$1.createSegment('C', control1, control2, centerLine.end);
                path.appendSegment(segment);
                // second half
                halfLine = new Line(center, line.end);
                control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
                control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);
                segment = Path$1.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'gap') {
                segment = Path$1.createSegment('M', line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'cubic') {
                // approximates semicircle with 1 curve
                angle = line.start.theta(line.end);
                const xOffset = jumpSize * 0.6;
                let yOffset = jumpSize * 1.35;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    yOffset *= -1;
                }
                control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);
                control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);
                segment = Path$1.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
        }
        else {
            const nextLine = lines[index + 1];
            if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
                segment = Path$1.createSegment('L', line.end);
                path.appendSegment(segment);
            }
            else {
                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
            }
        }
    });
    return path;
}
function buildRoundedSegment(offset, path, curr, prev, next) {
    const prevDistance = curr.distance(prev) / 2;
    const nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(offset, prevDistance);
    const endMove = -Math.min(offset, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
    const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
    let segment;
    segment = Path$1.createSegment('L', roundedStart);
    path.appendSegment(segment);
    segment = Path$1.createSegment('C', control1, control2, roundedEnd);
    path.appendSegment(segment);
}
let jumppedLines;
let skippedPoints;
const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {
    jumppedLines = [];
    skippedPoints = [];
    setupUpdating(this);
    const jumpSize = options.size || 5;
    const jumpType = options.type || 'arc';
    const radius = options.radius || 0;
    // list of connector types not to jump over.
    const ignoreConnectors = options.ignoreConnectors || ['smooth'];
    const graph = this.graph;
    const model = graph.model;
    const allLinks = model.getEdges();
    // there is just one link, draw it directly
    if (allLinks.length === 1) {
        return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
    }
    const edge = this.cell;
    const thisIndex = allLinks.indexOf(edge);
    const defaultConnector = graph.options.connecting.connector || {};
    // not all links are meant to be jumped over.
    const edges = allLinks.filter((link, idx) => {
        const connector = link.getConnector() || defaultConnector;
        // avoid jumping over links with connector type listed in `ignored connectors`.
        if (ignoreConnectors.includes(connector.name)) {
            return false;
        }
        // filter out links that are above this one and  have the same connector type
        // otherwise there would double hoops for each intersection
        if (idx > thisIndex) {
            return connector.name !== 'jumpover';
        }
        return true;
    });
    // find views for all links
    const linkViews = edges.map((edge) => {
        return graph.findViewByCell(edge);
    });
    // create lines for this link
    const thisLines = createLines(sourcePoint, targetPoint, routePoints);
    // create lines for all other links
    const linkLines = linkViews.map((linkView) => {
        if (linkView == null) {
            return [];
        }
        if (linkView === this) {
            return thisLines;
        }
        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
    });
    // transform lines for this link by splitting with jump lines at
    // points of intersection with other links
    const jumpingLines = [];
    thisLines.forEach((line) => {
        // iterate all links and grab the intersections with this line
        // these are then sorted by distance so the line can be split more easily
        const intersections = edges
            .reduce((memo, link, i) => {
            // don't intersection with itself
            if (link !== edge) {
                const lineIntersections = findLineIntersections(line, linkLines[i]);
                memo.push(...lineIntersections);
            }
            return memo;
        }, [])
            .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));
        if (intersections.length > 0) {
            // split the line based on found intersection points
            jumpingLines.push(...createJumps(line, intersections, jumpSize));
        }
        else {
            // without any intersection the line goes uninterrupted
            jumpingLines.push(line);
        }
    });
    const path = buildPath(jumpingLines, jumpSize, jumpType, radius);
    jumppedLines = [];
    skippedPoints = [];
    return options.raw ? path : path.serialize();
};

const connectors = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    jumpover,
    loop,
    normal,
    rounded,
    smooth
}, Symbol.toStringTag, { value: 'Module' }));

var Connector;
(function (Connector) {
    Connector.presets = connectors;
    Connector.registry = Registry.create({
        type: 'connector',
    });
    Connector.registry.register(Connector.presets, true);
})(Connector || (Connector = {}));

var __decorate$g = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Store extends Basecoat {
    constructor(data = {}) {
        super();
        this.pending = false;
        this.changing = false;
        this.data = {};
        this.mutate(cloneDeep(data));
        this.changed = {};
    }
    mutate(data, options = {}) {
        const unset = options.unset === true;
        const silent = options.silent === true;
        const changes = [];
        const changing = this.changing;
        this.changing = true;
        if (!changing) {
            this.previous = cloneDeep(this.data);
            this.changed = {};
        }
        const current = this.data;
        const previous = this.previous;
        const changed = this.changed;
        Object.keys(data).forEach((k) => {
            const key = k;
            const newValue = data[key];
            if (!isEqual(current[key], newValue)) {
                changes.push(key);
            }
            if (!isEqual(previous[key], newValue)) {
                changed[key] = newValue;
            }
            else {
                delete changed[key];
            }
            if (unset) {
                delete current[key];
            }
            else {
                current[key] = newValue;
            }
        });
        if (!silent && changes.length > 0) {
            this.pending = true;
            this.pendingOptions = options;
            changes.forEach((key) => {
                this.emit('change:*', {
                    key,
                    options,
                    store: this,
                    current: current[key],
                    previous: previous[key],
                });
            });
        }
        if (changing) {
            return this;
        }
        if (!silent) {
            // Changes can be recursively nested within `"change"` events.
            while (this.pending) {
                this.pending = false;
                this.emit('changed', {
                    current,
                    previous,
                    store: this,
                    options: this.pendingOptions,
                });
            }
        }
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        return this;
    }
    get(key, defaultValue) {
        if (key == null) {
            return this.data;
        }
        const ret = this.data[key];
        return ret == null ? defaultValue : ret;
    }
    getPrevious(key) {
        if (this.previous) {
            const ret = this.previous[key];
            return ret == null ? undefined : ret;
        }
        return undefined;
    }
    set(key, value, options) {
        if (key != null) {
            if (typeof key === 'object') {
                this.mutate(key, value);
            }
            else {
                this.mutate({ [key]: value }, options);
            }
        }
        return this;
    }
    remove(key, options) {
        const empty = undefined;
        const subset = {};
        let opts;
        if (typeof key === 'string') {
            subset[key] = empty;
            opts = options;
        }
        else if (Array.isArray(key)) {
            key.forEach((k) => (subset[k] = empty));
            opts = options;
        }
        else {
            // eslint-disable-next-line
            for (const key in this.data) {
                subset[key] = empty;
            }
            opts = key;
        }
        this.mutate(subset, Object.assign(Object.assign({}, opts), { unset: true }));
        return this;
    }
    getByPath(path) {
        return getByPath(this.data, path, '/');
    }
    setByPath(path, value, options = {}) {
        const delim = '/';
        const pathArray = Array.isArray(path) ? [...path] : path.split(delim);
        const pathString = Array.isArray(path) ? path.join(delim) : path;
        const property = pathArray[0];
        const pathArrayLength = pathArray.length;
        options.propertyPath = pathString;
        options.propertyValue = value;
        options.propertyPathArray = pathArray;
        if (pathArrayLength === 1) {
            this.set(property, value, options);
        }
        else {
            const update = {};
            let diver = update;
            let nextKey = property;
            // Initialize the nested object. Subobjects are either arrays or objects.
            // An empty array is created if the sub-key is an integer. Otherwise, an
            // empty object is created.
            for (let i = 1; i < pathArrayLength; i += 1) {
                const key = pathArray[i];
                const isArrayIndex = Number.isFinite(Number(key));
                diver = diver[nextKey] = isArrayIndex ? [] : {};
                nextKey = key;
            }
            // Fills update with the `value` on `path`.
            setByPath(update, pathArray, value, delim);
            const data = cloneDeep(this.data);
            // If rewrite mode enabled, we replace value referenced by path with the
            // new one (we don't merge).
            if (options.rewrite) {
                unsetByPath(data, path, delim);
            }
            const merged = merge$1(data, update);
            this.set(property, merged[property], options);
        }
        return this;
    }
    removeByPath(path, options) {
        const keys = Array.isArray(path) ? path : path.split('/');
        const key = keys[0];
        if (keys.length === 1) {
            this.remove(key, options);
        }
        else {
            const paths = keys.slice(1);
            const prop = cloneDeep(this.get(key));
            if (prop) {
                unsetByPath(prop, paths);
            }
            this.set(key, prop, options);
        }
        return this;
    }
    hasChanged(key) {
        if (key == null) {
            return Object.keys(this.changed).length > 0;
        }
        return key in this.changed;
    }
    /**
     * Returns an object containing all the data that have changed,
     * or `null` if there are no changes. Useful for determining what
     * parts of a view need to be updated.
     */
    getChanges(diff) {
        if (diff == null) {
            return this.hasChanged() ? cloneDeep(this.changed) : null;
        }
        const old = this.changing ? this.previous : this.data;
        const changed = {};
        let hasChanged;
        // eslint-disable-next-line
        for (const key in diff) {
            const val = diff[key];
            if (!isEqual(old[key], val)) {
                changed[key] = val;
                hasChanged = true;
            }
        }
        return hasChanged ? cloneDeep(changed) : null;
    }
    /**
     * Returns a copy of the store's `data` object.
     */
    toJSON() {
        return cloneDeep(this.data);
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.data);
    }
    dispose() {
        this.off();
        this.data = {};
        this.previous = {};
        this.changed = {};
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        this.trigger('disposed', { store: this });
    }
}
__decorate$g([
    Basecoat.dispose()
], Store.prototype, "dispose", null);

class Animation {
    constructor(cell) {
        this.cell = cell;
        this.ids = {};
        this.cache = {};
    }
    get() {
        return Object.keys(this.ids);
    }
    start(path, targetValue, options = {}, delim = '/') {
        const startValue = this.cell.getPropByPath(path);
        const localOptions = defaults$4(options, Animation.defaultOptions);
        const timing = this.getTiming(localOptions.timing);
        const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
        let startTime = 0;
        const key = Array.isArray(path) ? path.join(delim) : path;
        const paths = Array.isArray(path) ? path : path.split(delim);
        const iterate = () => {
            const now = new Date().getTime();
            if (startTime === 0) {
                startTime = now;
            }
            const elaspe = now - startTime;
            let progress = elaspe / localOptions.duration;
            if (progress < 1) {
                this.ids[key] = requestAnimationFrame(iterate);
            }
            else {
                progress = 1;
            }
            const currentValue = interpolate(timing(progress));
            this.cell.setPropByPath(paths, currentValue);
            if (options.progress) {
                options.progress(Object.assign({ progress, currentValue }, this.getArgs(key)));
            }
            if (progress === 1) {
                this.cell.notify('transition:complete', this.getArgs(key));
                options.complete && options.complete(this.getArgs(key));
                this.cell.notify('transition:finish', this.getArgs(key));
                options.finish && options.finish(this.getArgs(key));
                this.clean(key);
            }
        };
        setTimeout(() => {
            this.stop(path, undefined, delim);
            this.cache[key] = { startValue, targetValue, options: localOptions };
            this.ids[key] = requestAnimationFrame(iterate);
            this.cell.notify('transition:start', this.getArgs(key));
            options.start && options.start(this.getArgs(key));
        }, options.delay);
        return this.stop.bind(this, path, delim, options);
    }
    stop(path, options = {}, delim = '/') {
        const paths = Array.isArray(path) ? path : path.split(delim);
        Object.keys(this.ids)
            .filter((key) => isEqual(paths, key.split(delim).slice(0, paths.length)))
            .forEach((key) => {
            cancelAnimationFrame(this.ids[key]);
            const data = this.cache[key];
            const commonArgs = this.getArgs(key);
            const localOptions = Object.assign(Object.assign({}, data.options), options);
            const jumpedToEnd = localOptions.jumpedToEnd;
            if (jumpedToEnd && data.targetValue != null) {
                this.cell.setPropByPath(key, data.targetValue);
                this.cell.notify('transition:end', Object.assign({}, commonArgs));
                this.cell.notify('transition:complete', Object.assign({}, commonArgs));
                localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
            }
            const stopArgs = Object.assign({ jumpedToEnd }, commonArgs);
            this.cell.notify('transition:stop', Object.assign({}, stopArgs));
            localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
            this.cell.notify('transition:finish', Object.assign({}, commonArgs));
            localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
            this.clean(key);
        });
        return this;
    }
    clean(key) {
        delete this.ids[key];
        delete this.cache[key];
    }
    getTiming(timing) {
        return typeof timing === 'string' ? Timing[timing] : timing;
    }
    getInterp(interp, startValue, targetValue) {
        if (interp) {
            return interp(startValue, targetValue);
        }
        if (typeof targetValue === 'number') {
            return Interp.number(startValue, targetValue);
        }
        if (typeof targetValue === 'string') {
            if (targetValue[0] === '#') {
                return Interp.color(startValue, targetValue);
            }
            return Interp.unit(startValue, targetValue);
        }
        return Interp.object(startValue, targetValue);
    }
    getArgs(key) {
        const data = this.cache[key];
        return {
            path: key,
            startValue: data.startValue,
            targetValue: data.targetValue,
            cell: this.cell,
        };
    }
}
(function (Animation) {
    Animation.defaultOptions = {
        delay: 10,
        duration: 100,
        timing: 'linear',
    };
})(Animation || (Animation = {}));

/* eslint-disable no-underscore-dangle */
var __decorate$f = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$c = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Cell extends Basecoat {
    static config(presets) {
        const { markup, propHooks, attrHooks } = presets, others = __rest$c(presets, ["markup", "propHooks", "attrHooks"]);
        if (markup != null) {
            this.markup = markup;
        }
        if (propHooks) {
            this.propHooks = this.propHooks.slice();
            if (Array.isArray(propHooks)) {
                this.propHooks.push(...propHooks);
            }
            else if (typeof propHooks === 'function') {
                this.propHooks.push(propHooks);
            }
            else {
                Object.values(propHooks).forEach((hook) => {
                    if (typeof hook === 'function') {
                        this.propHooks.push(hook);
                    }
                });
            }
        }
        if (attrHooks) {
            this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
        }
        this.defaults = merge$1({}, this.defaults, others);
    }
    static getMarkup() {
        return this.markup;
    }
    static getDefaults(raw) {
        return (raw ? this.defaults : cloneDeep(this.defaults));
    }
    static getAttrHooks() {
        return this.attrHooks;
    }
    static applyPropHooks(cell, metadata) {
        return this.propHooks.reduce((memo, hook) => {
            return hook ? call$1(hook, cell, memo) : memo;
        }, metadata);
    }
    // #endregion
    get [Symbol.toStringTag]() {
        return Cell.toStringTag;
    }
    constructor(metadata = {}) {
        super();
        const ctor = this.constructor;
        const defaults = ctor.getDefaults(true);
        const props = merge$1({}, this.preprocess(defaults), this.preprocess(metadata));
        this.id = props.id || uuid();
        this.store = new Store(props);
        this.animation = new Animation(this);
        this.setup();
        this.init();
        this.postprocess(metadata);
    }
    init() { }
    // #region model
    get model() {
        return this._model;
    }
    set model(model) {
        if (this._model !== model) {
            this._model = model;
        }
    }
    // #endregion
    preprocess(metadata, ignoreIdCheck) {
        const id = metadata.id;
        const ctor = this.constructor;
        const props = ctor.applyPropHooks(this, metadata);
        if (id == null && ignoreIdCheck !== true) {
            props.id = uuid();
        }
        return props;
    }
    postprocess(metadata) { } // eslint-disable-line
    setup() {
        this.store.on('change:*', (metadata) => {
            const { key, current, previous, options } = metadata;
            this.notify('change:*', {
                key,
                options,
                current,
                previous,
                cell: this,
            });
            this.notify(`change:${key}`, {
                options,
                current,
                previous,
                cell: this,
            });
            const type = key;
            if (type === 'source' || type === 'target') {
                this.notify(`change:terminal`, {
                    type,
                    current,
                    previous,
                    options,
                    cell: this,
                });
            }
        });
        this.store.on('changed', ({ options }) => this.notify('changed', { options, cell: this }));
    }
    notify(name, args) {
        this.trigger(name, args);
        const model = this.model;
        if (model) {
            model.notify(`cell:${name}`, args);
            if (this.isNode()) {
                model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));
            }
            else if (this.isEdge()) {
                model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));
            }
        }
        return this;
    }
    isNode() {
        return false;
    }
    isEdge() {
        return false;
    }
    isSameStore(cell) {
        return this.store === cell.store;
    }
    get view() {
        return this.store.get('view');
    }
    get shape() {
        return this.store.get('shape', '');
    }
    getProp(key, defaultValue) {
        if (key == null) {
            return this.store.get();
        }
        return this.store.get(key, defaultValue);
    }
    setProp(key, value, options) {
        if (typeof key === 'string') {
            this.store.set(key, value, options);
        }
        else {
            const props = this.preprocess(key, true);
            this.store.set(merge$1({}, this.getProp(), props), value);
            this.postprocess(key);
        }
        return this;
    }
    removeProp(key, options) {
        if (typeof key === 'string' || Array.isArray(key)) {
            this.store.removeByPath(key, options);
        }
        else {
            this.store.remove(options);
        }
        return this;
    }
    hasChanged(key) {
        return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
    }
    getPropByPath(path) {
        return this.store.getByPath(path);
    }
    setPropByPath(path, value, options = {}) {
        if (this.model) {
            // update inner reference
            if (path === 'children') {
                this._children = value
                    ? value
                        .map((id) => this.model.getCell(id))
                        .filter((child) => child != null)
                    : null;
            }
            else if (path === 'parent') {
                this._parent = value ? this.model.getCell(value) : null;
            }
        }
        this.store.setByPath(path, value, options);
        return this;
    }
    removePropByPath(path, options = {}) {
        const paths = Array.isArray(path) ? path : path.split('/');
        // Once a property is removed from the `attrs` the CellView will
        // recognize a `dirty` flag and re-render itself in order to remove
        // the attribute from SVGElement.
        if (paths[0] === 'attrs') {
            options.dirty = true;
        }
        this.store.removeByPath(paths, options);
        return this;
    }
    prop(key, value, options) {
        if (key == null) {
            return this.getProp();
        }
        if (typeof key === 'string' || Array.isArray(key)) {
            if (arguments.length === 1) {
                return this.getPropByPath(key);
            }
            if (value == null) {
                return this.removePropByPath(key, options || {});
            }
            return this.setPropByPath(key, value, options || {});
        }
        return this.setProp(key, value || {});
    }
    previous(name) {
        return this.store.getPrevious(name);
    }
    // #endregion
    // #region zIndex
    get zIndex() {
        return this.getZIndex();
    }
    set zIndex(z) {
        if (z == null) {
            this.removeZIndex();
        }
        else {
            this.setZIndex(z);
        }
    }
    getZIndex() {
        return this.store.get('zIndex');
    }
    setZIndex(z, options = {}) {
        this.store.set('zIndex', z, options);
        return this;
    }
    removeZIndex(options = {}) {
        this.store.remove('zIndex', options);
        return this;
    }
    toFront(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMaxZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            z = z - cells.length + 1;
            const count = model.total();
            let changed = model.indexOf(this) !== count - cells.length;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-front', () => {
                    z += cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    toBack(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMinZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            let changed = model.indexOf(this) !== 0;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-back', () => {
                    z -= cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    // #endregion
    // #region markup
    get markup() {
        return this.getMarkup();
    }
    set markup(value) {
        if (value == null) {
            this.removeMarkup();
        }
        else {
            this.setMarkup(value);
        }
    }
    getMarkup() {
        let markup = this.store.get('markup');
        if (markup == null) {
            const ctor = this.constructor;
            markup = ctor.getMarkup();
        }
        return markup;
    }
    setMarkup(markup, options = {}) {
        this.store.set('markup', markup, options);
        return this;
    }
    removeMarkup(options = {}) {
        this.store.remove('markup', options);
        return this;
    }
    // #endregion
    // #region attrs
    get attrs() {
        return this.getAttrs();
    }
    set attrs(value) {
        if (value == null) {
            this.removeAttrs();
        }
        else {
            this.setAttrs(value);
        }
    }
    getAttrs() {
        const result = this.store.get('attrs');
        return result ? Object.assign({}, result) : {};
    }
    setAttrs(attrs, options = {}) {
        if (attrs == null) {
            this.removeAttrs(options);
        }
        else {
            const set = (attrs) => this.store.set('attrs', attrs, options);
            if (options.overwrite === true) {
                set(attrs);
            }
            else {
                const prev = this.getAttrs();
                if (options.deep === false) {
                    set(Object.assign(Object.assign({}, prev), attrs));
                }
                else {
                    set(merge$1({}, prev, attrs));
                }
            }
        }
        return this;
    }
    replaceAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeAttrs(options = {}) {
        this.store.remove('attrs', options);
        return this;
    }
    getAttrDefinition(attrName) {
        if (!attrName) {
            return null;
        }
        const ctor = this.constructor;
        const hooks = ctor.getAttrHooks() || {};
        let definition = hooks[attrName] || Attr.registry.get(attrName);
        if (!definition) {
            const name = camelCase$1(attrName);
            definition = hooks[name] || Attr.registry.get(name);
        }
        return definition || null;
    }
    getAttrByPath(path) {
        if (path == null || path === '') {
            return this.getAttrs();
        }
        return this.getPropByPath(this.prefixAttrPath(path));
    }
    setAttrByPath(path, value, options = {}) {
        this.setPropByPath(this.prefixAttrPath(path), value, options);
        return this;
    }
    removeAttrByPath(path, options = {}) {
        this.removePropByPath(this.prefixAttrPath(path), options);
        return this;
    }
    prefixAttrPath(path) {
        return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;
    }
    attr(path, value, options) {
        if (path == null) {
            return this.getAttrByPath();
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 1) {
                return this.getAttrByPath(path);
            }
            if (value == null) {
                return this.removeAttrByPath(path, options || {});
            }
            return this.setAttrByPath(path, value, options || {});
        }
        return this.setAttrs(path, (value || {}));
    }
    // #endregion
    // #region visible
    get visible() {
        return this.isVisible();
    }
    set visible(value) {
        this.setVisible(value);
    }
    setVisible(visible, options = {}) {
        this.store.set('visible', visible, options);
        return this;
    }
    isVisible() {
        return this.store.get('visible') !== false;
    }
    show(options = {}) {
        if (!this.isVisible()) {
            this.setVisible(true, options);
        }
        return this;
    }
    hide(options = {}) {
        if (this.isVisible()) {
            this.setVisible(false, options);
        }
        return this;
    }
    toggleVisible(isVisible, options = {}) {
        const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();
        const localOptions = typeof isVisible === 'boolean' ? options : isVisible;
        if (visible) {
            this.show(localOptions);
        }
        else {
            this.hide(localOptions);
        }
        return this;
    }
    // #endregion
    // #region data
    get data() {
        return this.getData();
    }
    set data(val) {
        this.setData(val);
    }
    getData() {
        return this.store.get('data');
    }
    setData(data, options = {}) {
        if (data == null) {
            this.removeData(options);
        }
        else {
            const set = (data) => this.store.set('data', data, options);
            if (options.overwrite === true) {
                set(data);
            }
            else {
                const prev = this.getData();
                if (options.deep === false) {
                    set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);
                }
                else {
                    set(merge$1({}, prev, data));
                }
            }
        }
        return this;
    }
    replaceData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeData(options = {}) {
        this.store.remove('data', options);
        return this;
    }
    // #endregion
    // #region parent children
    get parent() {
        return this.getParent();
    }
    get children() {
        return this.getChildren();
    }
    getParentId() {
        return this.store.get('parent');
    }
    getParent() {
        const parentId = this.getParentId();
        if (parentId && this.model) {
            const parent = this.model.getCell(parentId);
            this._parent = parent;
            return parent;
        }
        return null;
    }
    getChildren() {
        const childrenIds = this.store.get('children');
        if (childrenIds && childrenIds.length && this.model) {
            const children = childrenIds
                .map((id) => { var _a; return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id); })
                .filter((cell) => cell != null);
            this._children = children;
            return [...children];
        }
        return null;
    }
    hasParent() {
        return this.parent != null;
    }
    isParentOf(child) {
        return child != null && child.getParent() === this;
    }
    isChildOf(parent) {
        return parent != null && this.getParent() === parent;
    }
    eachChild(iterator, context) {
        if (this.children) {
            this.children.forEach(iterator, context);
        }
        return this;
    }
    filterChild(filter, context) {
        return this.children ? this.children.filter(filter, context) : [];
    }
    getChildCount() {
        return this.children == null ? 0 : this.children.length;
    }
    getChildIndex(child) {
        return this.children == null ? -1 : this.children.indexOf(child);
    }
    getChildAt(index) {
        return this.children != null && index >= 0 ? this.children[index] : null;
    }
    getAncestors(options = {}) {
        const ancestors = [];
        let parent = this.getParent();
        while (parent) {
            ancestors.push(parent);
            parent = options.deep !== false ? parent.getParent() : null;
        }
        return ancestors;
    }
    getDescendants(options = {}) {
        if (options.deep !== false) {
            // breadth first
            if (options.breadthFirst) {
                const cells = [];
                const queue = this.getChildren() || [];
                while (queue.length > 0) {
                    const parent = queue.shift();
                    const children = parent.getChildren();
                    cells.push(parent);
                    if (children) {
                        queue.push(...children);
                    }
                }
                return cells;
            }
            // depth first
            {
                const cells = this.getChildren() || [];
                cells.forEach((cell) => {
                    cells.push(...cell.getDescendants(options));
                });
                return cells;
            }
        }
        return this.getChildren() || [];
    }
    isDescendantOf(ancestor, options = {}) {
        if (ancestor == null) {
            return false;
        }
        if (options.deep !== false) {
            let current = this.getParent();
            while (current) {
                if (current === ancestor) {
                    return true;
                }
                current = current.getParent();
            }
            return false;
        }
        return this.isChildOf(ancestor);
    }
    isAncestorOf(descendant, options = {}) {
        if (descendant == null) {
            return false;
        }
        return descendant.isDescendantOf(this, options);
    }
    contains(cell) {
        return this.isAncestorOf(cell);
    }
    getCommonAncestor(...cells) {
        return Cell.getCommonAncestor(this, ...cells);
    }
    setParent(parent, options = {}) {
        this._parent = parent;
        if (parent) {
            this.store.set('parent', parent.id, options);
        }
        else {
            this.store.remove('parent', options);
        }
        return this;
    }
    setChildren(children, options = {}) {
        this._children = children;
        if (children != null) {
            this.store.set('children', children.map((child) => child.id), options);
        }
        else {
            this.store.remove('children', options);
        }
        return this;
    }
    unembed(child, options = {}) {
        const children = this.children;
        if (children != null && child != null) {
            const index = this.getChildIndex(child);
            if (index !== -1) {
                children.splice(index, 1);
                child.setParent(null, options);
                this.setChildren(children, options);
            }
        }
        return this;
    }
    embed(child, options = {}) {
        child.addTo(this, options);
        return this;
    }
    addTo(target, options = {}) {
        if (Cell.isCell(target)) {
            target.addChild(this, options);
        }
        else {
            target.addCell(this, options);
        }
        return this;
    }
    insertTo(parent, index, options = {}) {
        parent.insertChild(this, index, options);
        return this;
    }
    addChild(child, options = {}) {
        return this.insertChild(child, undefined, options);
    }
    insertChild(child, index, options = {}) {
        if (child != null && child !== this) {
            const oldParent = child.getParent();
            const changed = this !== oldParent;
            let pos = index;
            if (pos == null) {
                pos = this.getChildCount();
                if (!changed) {
                    pos -= 1;
                }
            }
            // remove from old parent
            if (oldParent) {
                const children = oldParent.getChildren();
                if (children) {
                    const index = children.indexOf(child);
                    if (index >= 0) {
                        child.setParent(null, options);
                        children.splice(index, 1);
                        oldParent.setChildren(children, options);
                    }
                }
            }
            let children = this.children;
            if (children == null) {
                children = [];
                children.push(child);
            }
            else {
                children.splice(pos, 0, child);
            }
            child.setParent(this, options);
            this.setChildren(children, options);
            if (changed && this.model) {
                const incomings = this.model.getIncomingEdges(this);
                const outgoings = this.model.getOutgoingEdges(this);
                if (incomings) {
                    incomings.forEach((edge) => edge.updateParent(options));
                }
                if (outgoings) {
                    outgoings.forEach((edge) => edge.updateParent(options));
                }
            }
            if (this.model) {
                this.model.addCell(child, options);
            }
        }
        return this;
    }
    removeFromParent(options = {}) {
        const parent = this.getParent();
        if (parent != null) {
            const index = parent.getChildIndex(this);
            parent.removeChildAt(index, options);
        }
        return this;
    }
    removeChild(child, options = {}) {
        const index = this.getChildIndex(child);
        return this.removeChildAt(index, options);
    }
    removeChildAt(index, options = {}) {
        const child = this.getChildAt(index);
        const children = this.children;
        if (children != null && child != null) {
            this.unembed(child, options);
            child.remove(options);
        }
        return child;
    }
    remove(options = {}) {
        this.batchUpdate('remove', () => {
            const parent = this.getParent();
            if (parent) {
                parent.removeChild(this, options);
            }
            if (options.deep !== false) {
                this.eachChild((child) => child.remove(options));
            }
            if (this.model) {
                this.model.removeCell(this, options);
            }
        });
        return this;
    }
    transition(path, target, options = {}, delim = '/') {
        return this.animation.start(path, target, options, delim);
    }
    stopTransition(path, options, delim = '/') {
        this.animation.stop(path, options, delim);
        return this;
    }
    getTransitions() {
        return this.animation.get();
    }
    // #endregion
    // #region transform
    // eslint-disable-next-line
    translate(tx, ty, options) {
        return this;
    }
    scale(sx, // eslint-disable-line
    sy, // eslint-disable-line
    origin, // eslint-disable-line
    options) {
        return this;
    }
    addTools(items, obj, options) {
        const toolItems = Array.isArray(items) ? items : [items];
        const name = typeof obj === 'string' ? obj : null;
        const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};
        if (config.reset) {
            return this.setTools({ name, items: toolItems, local: config.local }, config);
        }
        let tools = cloneDeep(this.getTools());
        if (tools == null || name == null || tools.name === name) {
            if (tools == null) {
                tools = {};
            }
            if (!tools.items) {
                tools.items = [];
            }
            tools.name = name;
            tools.items = [...tools.items, ...toolItems];
            return this.setTools(Object.assign({}, tools), config);
        }
    }
    setTools(tools, options = {}) {
        if (tools == null) {
            this.removeTools();
        }
        else {
            this.store.set('tools', Cell.normalizeTools(tools), options);
        }
        return this;
    }
    getTools() {
        return this.store.get('tools');
    }
    removeTools(options = {}) {
        this.store.remove('tools', options);
        return this;
    }
    hasTools(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    hasTool(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        return tools.items.some((item) => typeof item === 'string' ? item === name : item.name === name);
    }
    removeTool(nameOrIndex, options = {}) {
        const tools = cloneDeep(this.getTools());
        if (tools) {
            let updated = false;
            const items = tools.items.slice();
            const remove = (index) => {
                items.splice(index, 1);
                updated = true;
            };
            if (typeof nameOrIndex === 'number') {
                remove(nameOrIndex);
            }
            else {
                for (let i = items.length - 1; i >= 0; i -= 1) {
                    const item = items[i];
                    const exist = typeof item === 'string'
                        ? item === nameOrIndex
                        : item.name === nameOrIndex;
                    if (exist) {
                        remove(i);
                    }
                }
            }
            if (updated) {
                tools.items = items;
                this.setTools(tools, options);
            }
        }
        return this;
    }
    // #endregion
    // #region common
    // eslint-disable-next-line
    getBBox(options) {
        return new Rectangle();
    }
    // eslint-disable-next-line
    getConnectionPoint(edge, type) {
        return new Point();
    }
    toJSON(options = {}) {
        const props = Object.assign({}, this.store.get());
        const toString = Object.prototype.toString;
        const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';
        if (!props.shape) {
            const ctor = this.constructor;
            throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor.name || toString.call(ctor)}"`);
        }
        const ctor = this.constructor;
        const diff = options.diff === true;
        const attrs = props.attrs || {};
        const presets = ctor.getDefaults(true);
        // When `options.diff` is `true`, we should process the custom options,
        // such as `width`, `height` etc. to ensure the comparing work correctly.
        const defaults = diff ? this.preprocess(presets, true) : presets;
        const defaultAttrs = defaults.attrs || {};
        const finalAttrs = {};
        Object.entries(props).forEach(([key, val]) => {
            if (val != null &&
                !Array.isArray(val) &&
                typeof val === 'object' &&
                !isPlainObject(val)) {
                throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
            }
            if (key !== 'attrs' && key !== 'shape' && diff) {
                const preset = defaults[key];
                if (isEqual(val, preset)) {
                    delete props[key];
                }
            }
        });
        Object.keys(attrs).forEach((key) => {
            const attr = attrs[key];
            const defaultAttr = defaultAttrs[key];
            Object.keys(attr).forEach((name) => {
                const value = attr[name];
                const defaultValue = defaultAttr ? defaultAttr[name] : null;
                if (value != null &&
                    typeof value === 'object' &&
                    !Array.isArray(value)) {
                    Object.keys(value).forEach((subName) => {
                        const subValue = value[subName];
                        if (defaultAttr == null ||
                            defaultValue == null ||
                            !isObject(defaultValue) ||
                            !isEqual(defaultValue[subName], subValue)) {
                            if (finalAttrs[key] == null) {
                                finalAttrs[key] = {};
                            }
                            if (finalAttrs[key][name] == null) {
                                finalAttrs[key][name] = {};
                            }
                            const tmp = finalAttrs[key][name];
                            tmp[subName] = subValue;
                        }
                    });
                }
                else if (defaultAttr == null ||
                    !isEqual(defaultValue, value)) {
                    // `value` is not an object, default attribute with `key` does not
                    // exist or it is different than the attribute value set on the cell.
                    if (finalAttrs[key] == null) {
                        finalAttrs[key] = {};
                    }
                    finalAttrs[key][name] = value;
                }
            });
        });
        const finalProps = Object.assign(Object.assign({}, props), { attrs: isEmpty(finalAttrs) ? undefined : finalAttrs });
        if (finalProps.attrs == null) {
            delete finalProps.attrs;
        }
        const ret = finalProps;
        if (ret.angle === 0) {
            delete ret.angle;
        }
        return cloneDeep(ret);
    }
    clone(options = {}) {
        if (!options.deep) {
            const data = Object.assign({}, this.store.get());
            if (!options.keepId) {
                delete data.id;
            }
            delete data.parent;
            delete data.children;
            const ctor = this.constructor;
            return new ctor(data); // eslint-disable-line new-cap
        }
        // Deep cloning. Clone the cell itself and all its children.
        const map = Cell.deepClone(this);
        return map[this.id];
    }
    findView(graph) {
        return graph.findViewByCell(this);
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}, model = this.model) {
        this.notify('batch:start', { name, data, cell: this });
        if (model) {
            model.startBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        return this;
    }
    stopBatch(name, data = {}, model = this.model) {
        if (model) {
            model.stopBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        this.notify('batch:stop', { name, data, cell: this });
        return this;
    }
    batchUpdate(name, execute, data) {
        // The model is null after cell was removed(remove batch).
        // So we should temp save model to trigger pairing batch event.
        const model = this.model;
        this.startBatch(name, data, model);
        const result = execute();
        this.stopBatch(name, data, model);
        return result;
    }
    // #endregion
    // #region IDisposable
    dispose() {
        this.removeFromParent();
        this.store.dispose();
    }
}
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];
__decorate$f([
    Basecoat.dispose()
], Cell.prototype, "dispose", null);
(function (Cell) {
    function normalizeTools(raw) {
        if (typeof raw === 'string') {
            return { items: [raw] };
        }
        if (Array.isArray(raw)) {
            return { items: raw };
        }
        if (raw.items) {
            return raw;
        }
        return {
            items: [raw],
        };
    }
    Cell.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.toStringTag = `X6.${Cell.name}`;
    function isCell(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Cell) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const cell = instance;
        if ((tag == null || tag === Cell.toStringTag) &&
            typeof cell.isNode === 'function' &&
            typeof cell.isEdge === 'function' &&
            typeof cell.prop === 'function' &&
            typeof cell.attr === 'function') {
            return true;
        }
        return false;
    }
    Cell.isCell = isCell;
})(Cell || (Cell = {}));
(function (Cell) {
    function getCommonAncestor(...cells) {
        const ancestors = cells
            .filter((cell) => cell != null)
            .map((cell) => cell.getAncestors())
            .sort((a, b) => {
            return a.length - b.length;
        });
        const first = ancestors.shift();
        return (first.find((cell) => ancestors.every((item) => item.includes(cell))) ||
            null);
    }
    Cell.getCommonAncestor = getCommonAncestor;
    function getCellsBBox(cells, options = {}) {
        let bbox = null;
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const cell = cells[i];
            let rect = cell.getBBox(options);
            if (rect) {
                if (cell.isNode()) {
                    const angle = cell.getAngle();
                    if (angle != null && angle !== 0) {
                        rect = rect.bbox(angle);
                    }
                }
                bbox = bbox == null ? rect : bbox.union(rect);
            }
        }
        return bbox;
    }
    Cell.getCellsBBox = getCellsBBox;
    function deepClone(cell) {
        const cells = [cell, ...cell.getDescendants({ deep: true })];
        return Cell.cloneCells(cells);
    }
    Cell.deepClone = deepClone;
    function cloneCells(cells) {
        const inputs = uniq(cells);
        const cloneMap = inputs.reduce((map, cell) => {
            map[cell.id] = cell.clone();
            return map;
        }, {});
        inputs.forEach((cell) => {
            const clone = cloneMap[cell.id];
            if (clone.isEdge()) {
                const sourceId = clone.getSourceCellId();
                const targetId = clone.getTargetCellId();
                if (sourceId && cloneMap[sourceId]) {
                    // Source is a node and the node is among the clones.
                    // Then update the source of the cloned edge.
                    clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));
                }
                if (targetId && cloneMap[targetId]) {
                    // Target is a node and the node is among the clones.
                    // Then update the target of the cloned edge.
                    clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));
                }
            }
            // Find the parent of the original cell
            const parent = cell.getParent();
            if (parent && cloneMap[parent.id]) {
                clone.setParent(cloneMap[parent.id]);
            }
            // Find the children of the original cell
            const children = cell.getChildren();
            if (children && children.length) {
                const embeds = children.reduce((memo, child) => {
                    // Embedded cells that are not being cloned can not be carried
                    // over with other embedded cells.
                    if (cloneMap[child.id]) {
                        memo.push(cloneMap[child.id]);
                    }
                    return memo;
                }, []);
                if (embeds.length > 0) {
                    clone.setChildren(embeds);
                }
            }
        });
        return cloneMap;
    }
    Cell.cloneCells = cloneCells;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.config({
        propHooks(_a) {
            var { tools } = _a, metadata = __rest$c(_a, ["tools"]);
            if (tools) {
                metadata.tools = Cell.normalizeTools(tools);
            }
            return metadata;
        },
    });
})(Cell || (Cell = {}));

var ShareRegistry;
(function (ShareRegistry) {
    let edgeRegistry;
    let nodeRegistry;
    function exist(name, isNode) {
        return isNode
            ? edgeRegistry != null && edgeRegistry.exist(name)
            : nodeRegistry != null && nodeRegistry.exist(name);
    }
    ShareRegistry.exist = exist;
    function setEdgeRegistry(registry) {
        edgeRegistry = registry;
    }
    ShareRegistry.setEdgeRegistry = setEdgeRegistry;
    function setNodeRegistry(registry) {
        nodeRegistry = registry;
    }
    ShareRegistry.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));

class PortManager {
    constructor(data) {
        this.ports = [];
        this.groups = {};
        this.init(cloneDeep(data));
    }
    getPorts() {
        return this.ports;
    }
    getGroup(groupName) {
        return groupName != null ? this.groups[groupName] : null;
    }
    getPortsByGroup(groupName) {
        return this.ports.filter((p) => p.group === groupName || (p.group == null && groupName == null));
    }
    getPortsLayoutByGroup(groupName, elemBBox) {
        const ports = this.getPortsByGroup(groupName);
        const group = groupName ? this.getGroup(groupName) : null;
        const groupPosition = group ? group.position : null;
        const groupPositionName = groupPosition ? groupPosition.name : null;
        let layoutFn;
        if (groupPositionName != null) {
            const fn = PortLayout.registry.get(groupPositionName);
            if (fn == null) {
                return PortLayout.registry.onNotFound(groupPositionName);
            }
            layoutFn = fn;
        }
        else {
            layoutFn = PortLayout.presets.left;
        }
        const portsArgs = ports.map((port) => (port && port.position && port.position.args) || {});
        const groupArgs = (groupPosition && groupPosition.args) || {};
        const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
        return layouts.map((portLayout, index) => {
            const port = ports[index];
            return {
                portLayout,
                portId: port.id,
                portSize: port.size,
                portAttrs: port.attrs,
                labelSize: port.label.size,
                labelLayout: this.getPortLabelLayout(port, Point.create(portLayout.position), elemBBox),
            };
        });
    }
    init(data) {
        const { groups, items } = data;
        if (groups != null) {
            Object.keys(groups).forEach((key) => {
                this.groups[key] = this.parseGroup(groups[key]);
            });
        }
        if (Array.isArray(items)) {
            items.forEach((item) => {
                this.ports.push(this.parsePort(item));
            });
        }
    }
    parseGroup(group) {
        return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });
    }
    parsePort(port) {
        const result = Object.assign({}, port);
        const group = this.getGroup(port.group) || {};
        result.markup = result.markup || group.markup;
        result.attrs = merge$1({}, group.attrs, result.attrs);
        result.position = this.createPosition(group, result);
        result.label = merge$1({}, group.label, this.getLabel(result));
        result.zIndex = this.getZIndex(group, result);
        result.size = Object.assign(Object.assign({}, group.size), result.size);
        return result;
    }
    getZIndex(group, port) {
        if (typeof port.zIndex === 'number') {
            return port.zIndex;
        }
        if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {
            return group.zIndex;
        }
        return 'auto';
    }
    createPosition(group, port) {
        return merge$1({
            name: 'left',
            args: {},
        }, group.position, { args: port.args });
    }
    getPortPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (Array.isArray(position)) {
                return {
                    name: 'absolute',
                    args: { x: position[0], y: position[1] },
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getPortLabelPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getLabel(item, setDefaults = false) {
        const label = item.label || {};
        label.position = this.getPortLabelPosition(label.position, setDefaults);
        return label;
    }
    getPortLabelLayout(port, portPosition, elemBBox) {
        const name = port.label.position.name || 'left';
        const args = port.label.position.args || {};
        const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;
        if (layoutFn) {
            return layoutFn(portPosition, elemBBox, args);
        }
        return null;
    }
}

var __rest$b = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Node$1 = class Node extends Cell {
    get [Symbol.toStringTag]() {
        return Node.toStringTag;
    }
    constructor(metadata = {}) {
        super(metadata);
        this.initPorts();
    }
    preprocess(metadata, ignoreIdCheck) {
        const { x, y, width, height } = metadata, others = __rest$b(metadata, ["x", "y", "width", "height"]);
        if (x != null || y != null) {
            const position = others.position;
            others.position = Object.assign(Object.assign({}, position), { x: x != null ? x : position ? position.x : 0, y: y != null ? y : position ? position.y : 0 });
        }
        if (width != null || height != null) {
            const size = others.size;
            others.size = Object.assign(Object.assign({}, size), { width: width != null ? width : size ? size.width : 0, height: height != null ? height : size ? size.height : 0 });
        }
        return super.preprocess(others, ignoreIdCheck);
    }
    isNode() {
        return true;
    }
    size(width, height, options) {
        if (width === undefined) {
            return this.getSize();
        }
        if (typeof width === 'number') {
            return this.setSize(width, height, options);
        }
        return this.setSize(width, height);
    }
    getSize() {
        const size = this.store.get('size');
        return size ? Object.assign({}, size) : { width: 1, height: 1 };
    }
    setSize(width, height, options) {
        if (typeof width === 'object') {
            this.resize(width.width, width.height, height);
        }
        else {
            this.resize(width, height, options);
        }
        return this;
    }
    resize(width, height, options = {}) {
        this.startBatch('resize', options);
        const direction = options.direction;
        if (direction) {
            const currentSize = this.getSize();
            switch (direction) {
                case 'left':
                case 'right':
                    // Don't change height when resizing horizontally.
                    height = currentSize.height; // eslint-disable-line
                    break;
                case 'top':
                case 'bottom':
                    // Don't change width when resizing vertically.
                    width = currentSize.width; // eslint-disable-line
                    break;
            }
            const map = {
                right: 0,
                'top-right': 0,
                top: 1,
                'top-left': 1,
                left: 2,
                'bottom-left': 2,
                bottom: 3,
                'bottom-right': 3,
            };
            let quadrant = map[direction];
            const angle = Angle.normalize(this.getAngle() || 0);
            if (options.absolute) {
                // We are taking the node's rotation into account
                quadrant += Math.floor((angle + 45) / 90);
                quadrant %= 4;
            }
            // This is a rectangle in size of the un-rotated node.
            const bbox = this.getBBox();
            // Pick the corner point on the node, which meant to stay on its
            // place before and after the rotation.
            let fixedPoint;
            if (quadrant === 0) {
                fixedPoint = bbox.getBottomLeft();
            }
            else if (quadrant === 1) {
                fixedPoint = bbox.getCorner();
            }
            else if (quadrant === 2) {
                fixedPoint = bbox.getTopRight();
            }
            else {
                fixedPoint = bbox.getOrigin();
            }
            // Find an image of the previous indent point. This is the position,
            // where is the point actually located on the screen.
            const imageFixedPoint = fixedPoint
                .clone()
                .rotate(-angle, bbox.getCenter());
            // Every point on the element rotates around a circle with the centre of
            // rotation in the middle of the element while the whole element is being
            // rotated. That means that the distance from a point in the corner of
            // the element (supposed its always rect) to the center of the element
            // doesn't change during the rotation and therefore it equals to a
            // distance on un-rotated element.
            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
            const radius = Math.sqrt(width * width + height * height) / 2;
            // Now we are looking for an angle between x-axis and the line starting
            // at image of fixed point and ending at the center of the element.
            // We call this angle `alpha`.
            // The image of a fixed point is located in n-th quadrant. For each
            // quadrant passed going anti-clockwise we have to add 90 degrees.
            // Note that the first quadrant has index 0.
            //
            // 3 | 2
            // --c-- Quadrant positions around the element's center `c`
            // 0 | 1
            //
            let alpha = (quadrant * Math.PI) / 2;
            // Add an angle between the beginning of the current quadrant (line
            // parallel with x-axis or y-axis going through the center of the
            // element) and line crossing the indent of the fixed point and the
            // center of the element. This is the angle we need but on the
            // un-rotated element.
            alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);
            // Lastly we have to deduct the original angle the element was rotated
            // by and that's it.
            alpha -= Angle.toRad(angle);
            // With this angle and distance we can easily calculate the centre of
            // the un-rotated element.
            // Note that fromPolar constructor accepts an angle in radians.
            const center = Point.fromPolar(radius, alpha, imageFixedPoint);
            // The top left corner on the un-rotated element has to be half a width
            // on the left and half a height to the top from the center. This will
            // be the origin of rectangle we were looking for.
            const origin = center.clone().translate(width / -2, height / -2);
            this.store.set('size', { width, height }, options);
            this.setPosition(origin.x, origin.y, options);
        }
        else {
            this.store.set('size', { width, height }, options);
        }
        this.stopBatch('resize', options);
        return this;
    }
    scale(sx, sy, origin, options = {}) {
        const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);
        this.startBatch('scale', options);
        this.setPosition(scaledBBox.x, scaledBBox.y, options);
        this.resize(scaledBBox.width, scaledBBox.height, options);
        this.stopBatch('scale');
        return this;
    }
    position(arg0, arg1, arg2) {
        if (typeof arg0 === 'number') {
            return this.setPosition(arg0, arg1, arg2);
        }
        return this.getPosition(arg0);
    }
    getPosition(options = {}) {
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const currentPosition = this.getPosition();
                const parentPosition = parent.getPosition();
                return {
                    x: currentPosition.x - parentPosition.x,
                    y: currentPosition.y - parentPosition.y,
                };
            }
        }
        const pos = this.store.get('position');
        return pos ? Object.assign({}, pos) : { x: 0, y: 0 };
    }
    setPosition(arg0, arg1, arg2 = {}) {
        let x;
        let y;
        let options;
        if (typeof arg0 === 'object') {
            x = arg0.x;
            y = arg0.y;
            options = arg1 || {};
        }
        else {
            x = arg0;
            y = arg1;
            options = arg2 || {};
        }
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const parentPosition = parent.getPosition();
                x += parentPosition.x;
                y += parentPosition.y;
            }
        }
        if (options.deep) {
            const currentPosition = this.getPosition();
            this.translate(x - currentPosition.x, y - currentPosition.y, options);
        }
        else {
            this.store.set('position', { x, y }, options);
        }
        return this;
    }
    translate(tx = 0, ty = 0, options = {}) {
        if (tx === 0 && ty === 0) {
            return this;
        }
        // Pass the initiator of the translation.
        options.translateBy = options.translateBy || this.id;
        const position = this.getPosition();
        if (options.restrict != null && options.translateBy === this.id) {
            // We are restricting the translation for the element itself only. We get
            // the bounding box of the element including all its embeds.
            // All embeds have to be translated the exact same way as the element.
            const bbox = this.getBBox({ deep: true });
            const ra = options.restrict;
            // - - - - - - - - - - - - -> ra.x + ra.width
            // - - - -> position.x      |
            // -> bbox.x
            //                   |
            //         
            //                 |
            //   
            //                  |
            //   <-dx->                     | restricted area right border
            //         <-width->        |    translated element
            //   <- - bbox.width - ->        embedded element
            const dx = position.x - bbox.x;
            const dy = position.y - bbox.y;
            // Find the maximal/minimal coordinates that the element can be translated
            // while complies the restrictions.
            const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
            const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
            // recalculate the translation taking the restrictions into account.
            tx = x - position.x; // eslint-disable-line
            ty = y - position.y; // eslint-disable-line
        }
        const translatedPosition = {
            x: position.x + tx,
            y: position.y + ty,
        };
        // To find out by how much an element was translated in event
        // 'change:position' handlers.
        options.tx = tx;
        options.ty = ty;
        if (options.transition) {
            if (typeof options.transition !== 'object') {
                options.transition = {};
            }
            this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
        }
        else {
            this.startBatch('translate', options);
            this.store.set('position', translatedPosition, options);
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
            this.stopBatch('translate', options);
        }
        return this;
    }
    angle(val, options) {
        if (val == null) {
            return this.getAngle();
        }
        return this.rotate(val, options);
    }
    getAngle() {
        return this.store.get('angle', 0);
    }
    rotate(angle, options = {}) {
        const currentAngle = this.getAngle();
        if (options.center) {
            const size = this.getSize();
            const position = this.getPosition();
            const center = this.getBBox().getCenter();
            center.rotate(currentAngle - angle, options.center);
            const dx = center.x - size.width / 2 - position.x;
            const dy = center.y - size.height / 2 - position.y;
            this.startBatch('rotate', { angle, options });
            this.setPosition(position.x + dx, position.y + dy, options);
            this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));
            this.stopBatch('rotate');
        }
        else {
            this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);
        }
        return this;
    }
    // #endregion
    // #region common
    getBBox(options = {}) {
        if (options.deep) {
            const cells = this.getDescendants({ deep: true, breadthFirst: true });
            cells.push(this);
            return Cell.getCellsBBox(cells);
        }
        return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
    }
    getConnectionPoint(edge, type) {
        const bbox = this.getBBox();
        const center = bbox.getCenter();
        const terminal = edge.getTerminal(type);
        if (terminal == null) {
            return center;
        }
        const portId = terminal.port;
        if (!portId || !this.hasPort(portId)) {
            return center;
        }
        const port = this.getPort(portId);
        if (!port || !port.group) {
            return center;
        }
        const layouts = this.getPortsPosition(port.group);
        const position = layouts[portId].position;
        const portCenter = Point.create(position).translate(bbox.getOrigin());
        const angle = this.getAngle();
        if (angle) {
            portCenter.rotate(-angle, center);
        }
        return portCenter;
    }
    /**
     * Sets cell's size and position based on the children bbox and given padding.
     */
    fit(options = {}) {
        const children = this.getChildren() || [];
        const embeds = children.filter((cell) => cell.isNode());
        if (embeds.length === 0) {
            return this;
        }
        this.startBatch('fit-embeds', options);
        if (options.deep) {
            embeds.forEach((cell) => cell.fit(options));
        }
        let { x, y, width, height } = Cell.getCellsBBox(embeds);
        const padding = normalizeSides(options.padding);
        x -= padding.left;
        y -= padding.top;
        width += padding.left + padding.right;
        height += padding.bottom + padding.top;
        this.store.set({
            position: { x, y },
            size: { width, height },
        }, options);
        this.stopBatch('fit-embeds');
        return this;
    }
    // #endregion
    // #region ports
    get portContainerMarkup() {
        return this.getPortContainerMarkup();
    }
    set portContainerMarkup(markup) {
        this.setPortContainerMarkup(markup);
    }
    getDefaultPortContainerMarkup() {
        return (this.store.get('defaultPortContainerMarkup') ||
            Markup.getPortContainerMarkup());
    }
    getPortContainerMarkup() {
        return (this.store.get('portContainerMarkup') ||
            this.getDefaultPortContainerMarkup());
    }
    setPortContainerMarkup(markup, options = {}) {
        this.store.set('portContainerMarkup', Markup.clone(markup), options);
        return this;
    }
    get portMarkup() {
        return this.getPortMarkup();
    }
    set portMarkup(markup) {
        this.setPortMarkup(markup);
    }
    getDefaultPortMarkup() {
        return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();
    }
    getPortMarkup() {
        return this.store.get('portMarkup') || this.getDefaultPortMarkup();
    }
    setPortMarkup(markup, options = {}) {
        this.store.set('portMarkup', Markup.clone(markup), options);
        return this;
    }
    get portLabelMarkup() {
        return this.getPortLabelMarkup();
    }
    set portLabelMarkup(markup) {
        this.setPortLabelMarkup(markup);
    }
    getDefaultPortLabelMarkup() {
        return (this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup());
    }
    getPortLabelMarkup() {
        return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();
    }
    setPortLabelMarkup(markup, options = {}) {
        this.store.set('portLabelMarkup', Markup.clone(markup), options);
        return this;
    }
    get ports() {
        const res = this.store.get('ports', { items: [] });
        if (res.items == null) {
            res.items = [];
        }
        return res;
    }
    getPorts() {
        return cloneDeep(this.ports.items);
    }
    getPortsByGroup(groupName) {
        return this.getPorts().filter((port) => port.group === groupName);
    }
    getPort(portId) {
        return cloneDeep(this.ports.items.find((port) => port.id && port.id === portId));
    }
    getPortAt(index) {
        return this.ports.items[index] || null;
    }
    hasPorts() {
        return this.ports.items.length > 0;
    }
    hasPort(portId) {
        return this.getPortIndex(portId) !== -1;
    }
    getPortIndex(port) {
        const portId = typeof port === 'string' ? port : port.id;
        return portId != null
            ? this.ports.items.findIndex((item) => item.id === portId)
            : -1;
    }
    getPortsPosition(groupName) {
        const size = this.getSize();
        const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));
        return layouts.reduce((memo, item) => {
            const layout = item.portLayout;
            memo[item.portId] = {
                position: Object.assign({}, layout.position),
                angle: layout.angle || 0,
            };
            return memo;
        }, {});
    }
    getPortProp(portId, path) {
        return this.getPropByPath(this.prefixPortPath(portId, path));
    }
    setPortProp(portId, arg1, arg2, arg3) {
        if (typeof arg1 === 'string' || Array.isArray(arg1)) {
            const path = this.prefixPortPath(portId, arg1);
            const value = arg2;
            return this.setPropByPath(path, value, arg3);
        }
        const path = this.prefixPortPath(portId);
        const value = arg1;
        return this.setPropByPath(path, value, arg2);
    }
    removePortProp(portId, path, options) {
        if (typeof path === 'string' || Array.isArray(path)) {
            return this.removePropByPath(this.prefixPortPath(portId, path), options);
        }
        return this.removePropByPath(this.prefixPortPath(portId), path);
    }
    portProp(portId, path, value, options) {
        if (path == null) {
            return this.getPortProp(portId);
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 2) {
                return this.getPortProp(portId, path);
            }
            if (value == null) {
                return this.removePortProp(portId, path, options);
            }
            return this.setPortProp(portId, path, value, options);
        }
        return this.setPortProp(portId, path, value);
    }
    prefixPortPath(portId, path) {
        const index = this.getPortIndex(portId);
        if (index === -1) {
            throw new Error(`Unable to find port with id: "${portId}"`);
        }
        if (path == null || path === '') {
            return ['ports', 'items', `${index}`];
        }
        if (Array.isArray(path)) {
            return ['ports', 'items', `${index}`, ...path];
        }
        return `ports/items/${index}/${path}`;
    }
    addPort(port, options) {
        const ports = [...this.ports.items];
        ports.push(port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    addPorts(ports, options) {
        this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);
        return this;
    }
    insertPort(index, port, options) {
        const ports = [...this.ports.items];
        ports.splice(index, 0, port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    removePort(port, options = {}) {
        return this.removePortAt(this.getPortIndex(port), options);
    }
    removePortAt(index, options = {}) {
        if (index >= 0) {
            const ports = [...this.ports.items];
            ports.splice(index, 1);
            options.rewrite = true;
            this.setPropByPath('ports/items', ports, options);
        }
        return this;
    }
    removePorts(portsForRemoval, opt) {
        let options;
        if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length) {
                options.rewrite = true;
                const currentPorts = [...this.ports.items];
                const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {
                    const id = typeof p === 'string' ? p : p.id;
                    return cp.id === id;
                }));
                this.setPropByPath('ports/items', remainingPorts, options);
            }
        }
        else {
            options = portsForRemoval || {};
            options.rewrite = true;
            this.setPropByPath('ports/items', [], options);
        }
        return this;
    }
    getParsedPorts() {
        return this.port.getPorts();
    }
    getParsedGroups() {
        return this.port.groups;
    }
    getPortsLayoutByGroup(groupName, bbox) {
        return this.port.getPortsLayoutByGroup(groupName, bbox);
    }
    initPorts() {
        this.updatePortData();
        this.on('change:ports', () => {
            this.processRemovedPort();
            this.updatePortData();
        });
    }
    processRemovedPort() {
        const current = this.ports;
        const currentItemsMap = {};
        current.items.forEach((item) => {
            if (item.id) {
                currentItemsMap[item.id] = true;
            }
        });
        const removed = {};
        const previous = this.store.getPrevious('ports') || {
            items: [],
        };
        previous.items.forEach((item) => {
            if (item.id && !currentItemsMap[item.id]) {
                removed[item.id] = true;
            }
        });
        const model = this.model;
        if (model && !isEmpty(removed)) {
            const incomings = model.getConnectedEdges(this, { incoming: true });
            incomings.forEach((edge) => {
                const portId = edge.getTargetPortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
            const outgoings = model.getConnectedEdges(this, { outgoing: true });
            outgoings.forEach((edge) => {
                const portId = edge.getSourcePortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
        }
    }
    validatePorts() {
        const ids = {};
        const errors = [];
        this.ports.items.forEach((p) => {
            if (typeof p !== 'object') {
                errors.push(`Invalid port ${p}.`);
            }
            if (p.id == null) {
                p.id = this.generatePortId();
            }
            if (ids[p.id]) {
                errors.push('Duplicitied port id.');
            }
            ids[p.id] = true;
        });
        return errors;
    }
    generatePortId() {
        return uuid();
    }
    updatePortData() {
        const err = this.validatePorts();
        if (err.length > 0) {
            this.store.set('ports', this.store.getPrevious('ports'));
            throw new Error(err.join(' '));
        }
        const prev = this.port ? this.port.getPorts() : null;
        this.port = new PortManager(this.ports);
        const curr = this.port.getPorts();
        const added = prev
            ? curr.filter((item) => {
                if (!prev.find((prevPort) => prevPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [...curr];
        const removed = prev
            ? prev.filter((item) => {
                if (!curr.find((curPort) => curPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [];
        if (added.length > 0) {
            this.notify('ports:added', { added, cell: this, node: this });
        }
        if (removed.length > 0) {
            this.notify('ports:removed', { removed, cell: this, node: this });
        }
    }
};
Node$1.defaults = {
    angle: 0,
    position: { x: 0, y: 0 },
    size: { width: 1, height: 1 },
};
(function (Node) {
    Node.toStringTag = `X6.${Node.name}`;
    function isNode(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Node) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const node = instance;
        if ((tag == null || tag === Node.toStringTag) &&
            typeof node.isNode === 'function' &&
            typeof node.isEdge === 'function' &&
            typeof node.prop === 'function' &&
            typeof node.attr === 'function' &&
            typeof node.size === 'function' &&
            typeof node.position === 'function') {
            return true;
        }
        return false;
    }
    Node.isNode = isNode;
})(Node$1 || (Node$1 = {}));
(function (Node) {
    Node.config({
        propHooks(_a) {
            var { ports } = _a, metadata = __rest$b(_a, ["ports"]);
            if (ports) {
                metadata.ports = Array.isArray(ports) ? { items: ports } : ports;
            }
            return metadata;
        },
    });
})(Node$1 || (Node$1 = {}));
(function (Node) {
    Node.registry = Registry.create({
        type: 'node',
        process(shape, options) {
            if (ShareRegistry.exist(shape, true)) {
                throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Node;
            const { inherit } = options, config = __rest$b(options, ["inherit"]);
            if (inherit) {
                if (typeof inherit === 'string') {
                    const base = this.get(inherit);
                    if (base == null) {
                        this.onNotFound(inherit, 'inherited');
                    }
                    else {
                        parent = base;
                    }
                }
                else {
                    parent = inherit;
                }
            }
            if (config.constructorName == null) {
                config.constructorName = shape;
            }
            const ctor = parent.define.call(parent, config);
            ctor.config({ shape });
            return ctor;
        },
    });
    ShareRegistry.setNodeRegistry(Node.registry);
})(Node$1 || (Node$1 = {}));
(function (Node) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return pascalCase(name);
        }
        counter += 1;
        return `CustomNode${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest$b(config, ["constructorName", "overwrite"]);
        const ctor = createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Node.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Node.define = define;
    function create(options) {
        const shape = options.shape || 'rect';
        const Ctor = Node.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Node.registry.onNotFound(shape);
    }
    Node.create = create;
})(Node$1 || (Node$1 = {}));

var __rest$a = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Edge$1 = class Edge extends Cell {
    get [Symbol.toStringTag]() {
        return Edge.toStringTag;
    }
    constructor(metadata = {}) {
        super(metadata);
    }
    preprocess(metadata, ignoreIdCheck) {
        const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest$a(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);
        const data = others;
        const isValidId = (val) => typeof val === 'string' || typeof val === 'number';
        if (source != null) {
            if (Cell.isCell(source)) {
                data.source = { cell: source.id };
            }
            else if (isValidId(source)) {
                data.source = { cell: source };
            }
            else if (Point.isPoint(source)) {
                data.source = source.toJSON();
            }
            else if (Array.isArray(source)) {
                data.source = { x: source[0], y: source[1] };
            }
            else {
                const cell = source.cell;
                if (Cell.isCell(cell)) {
                    data.source = Object.assign(Object.assign({}, source), { cell: cell.id });
                }
                else {
                    data.source = source;
                }
            }
        }
        if (sourceCell != null || sourcePort != null) {
            let terminal = data.source;
            if (sourceCell != null) {
                const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.source = { cell: id };
                }
            }
            if (sourcePort != null && terminal) {
                terminal.port = sourcePort;
            }
        }
        else if (sourcePoint != null) {
            data.source = Point.create(sourcePoint).toJSON();
        }
        if (target != null) {
            if (Cell.isCell(target)) {
                data.target = { cell: target.id };
            }
            else if (isValidId(target)) {
                data.target = { cell: target };
            }
            else if (Point.isPoint(target)) {
                data.target = target.toJSON();
            }
            else if (Array.isArray(target)) {
                data.target = { x: target[0], y: target[1] };
            }
            else {
                const cell = target.cell;
                if (Cell.isCell(cell)) {
                    data.target = Object.assign(Object.assign({}, target), { cell: cell.id });
                }
                else {
                    data.target = target;
                }
            }
        }
        if (targetCell != null || targetPort != null) {
            let terminal = data.target;
            if (targetCell != null) {
                const id = isValidId(targetCell) ? targetCell : targetCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.target = { cell: id };
                }
            }
            if (targetPort != null && terminal) {
                terminal.port = targetPort;
            }
        }
        else if (targetPoint != null) {
            data.target = Point.create(targetPoint).toJSON();
        }
        return super.preprocess(data, ignoreIdCheck);
    }
    setup() {
        super.setup();
        this.on('change:labels', (args) => this.onLabelsChanged(args));
        this.on('change:vertices', (args) => this.onVertexsChanged(args));
    }
    isEdge() {
        return true;
    }
    // #region terminal
    disconnect(options = {}) {
        this.store.set({
            source: { x: 0, y: 0 },
            target: { x: 0, y: 0 },
        }, options);
        return this;
    }
    get source() {
        return this.getSource();
    }
    set source(data) {
        this.setSource(data);
    }
    getSource() {
        return this.getTerminal('source');
    }
    getSourceCellId() {
        return this.source.cell;
    }
    getSourcePortId() {
        return this.source.port;
    }
    setSource(source, args, options = {}) {
        return this.setTerminal('source', source, args, options);
    }
    get target() {
        return this.getTarget();
    }
    set target(data) {
        this.setTarget(data);
    }
    getTarget() {
        return this.getTerminal('target');
    }
    getTargetCellId() {
        return this.target.cell;
    }
    getTargetPortId() {
        return this.target.port;
    }
    setTarget(target, args, options = {}) {
        return this.setTerminal('target', target, args, options);
    }
    getTerminal(type) {
        return Object.assign({}, this.store.get(type));
    }
    setTerminal(type, terminal, args, options = {}) {
        // `terminal` is a cell
        if (Cell.isCell(terminal)) {
            this.store.set(type, merge$1({}, args, { cell: terminal.id }), options);
            return this;
        }
        // `terminal` is a point-like object
        const p = terminal;
        if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {
            this.store.set(type, merge$1({}, args, { x: p.x, y: p.y }), options);
            return this;
        }
        // `terminal` is an object
        this.store.set(type, cloneDeep(terminal), options);
        return this;
    }
    getSourcePoint() {
        return this.getTerminalPoint('source');
    }
    getTargetPoint() {
        return this.getTerminalPoint('target');
    }
    getTerminalPoint(type) {
        const terminal = this[type];
        if (Point.isPointLike(terminal)) {
            return Point.create(terminal);
        }
        const cell = this.getTerminalCell(type);
        if (cell) {
            return cell.getConnectionPoint(this, type);
        }
        return new Point();
    }
    getSourceCell() {
        return this.getTerminalCell('source');
    }
    getTargetCell() {
        return this.getTerminalCell('target');
    }
    getTerminalCell(type) {
        if (this.model) {
            const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();
            if (cellId) {
                return this.model.getCell(cellId);
            }
        }
        return null;
    }
    getSourceNode() {
        return this.getTerminalNode('source');
    }
    getTargetNode() {
        return this.getTerminalNode('target');
    }
    getTerminalNode(type) {
        let cell = this; // eslint-disable-line
        const visited = {};
        while (cell && cell.isEdge()) {
            if (visited[cell.id]) {
                return null;
            }
            visited[cell.id] = true;
            cell = cell.getTerminalCell(type);
        }
        return cell && cell.isNode() ? cell : null;
    }
    // #endregion
    // #region router
    get router() {
        return this.getRouter();
    }
    set router(data) {
        if (data == null) {
            this.removeRouter();
        }
        else {
            this.setRouter(data);
        }
    }
    getRouter() {
        return this.store.get('router');
    }
    setRouter(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('router', name, args);
        }
        else {
            this.store.set('router', { name, args }, options);
        }
        return this;
    }
    removeRouter(options = {}) {
        this.store.remove('router', options);
        return this;
    }
    // #endregion
    // #region connector
    get connector() {
        return this.getConnector();
    }
    set connector(data) {
        if (data == null) {
            this.removeConnector();
        }
        else {
            this.setConnector(data);
        }
    }
    getConnector() {
        return this.store.get('connector');
    }
    setConnector(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('connector', name, args);
        }
        else {
            this.store.set('connector', { name, args }, options);
        }
        return this;
    }
    removeConnector(options = {}) {
        return this.store.remove('connector', options);
    }
    // #endregion
    // #region labels
    getDefaultLabel() {
        const ctor = this.constructor;
        const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};
        return cloneDeep(defaults);
    }
    get labels() {
        return this.getLabels();
    }
    set labels(labels) {
        this.setLabels(labels);
    }
    getLabels() {
        return [...this.store.get('labels', [])].map((item) => this.parseLabel(item));
    }
    setLabels(labels, options = {}) {
        this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);
        return this;
    }
    insertLabel(label, index, options = {}) {
        const labels = this.getLabels();
        const len = labels.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        labels.splice(idx, 0, this.parseLabel(label));
        return this.setLabels(labels, options);
    }
    appendLabel(label, options = {}) {
        return this.insertLabel(label, -1, options);
    }
    getLabelAt(index) {
        const labels = this.getLabels();
        if (index != null && Number.isFinite(index)) {
            return this.parseLabel(labels[index]);
        }
        return null;
    }
    setLabelAt(index, label, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const labels = this.getLabels();
            labels[index] = this.parseLabel(label);
            this.setLabels(labels, options);
        }
        return this;
    }
    removeLabelAt(index, options = {}) {
        const labels = this.getLabels();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        const removed = labels.splice(idx, 1);
        this.setLabels(labels, options);
        return removed.length ? removed[0] : null;
    }
    parseLabel(label) {
        if (typeof label === 'string') {
            const ctor = this.constructor;
            return ctor.parseStringLabel(label);
        }
        return label;
    }
    onLabelsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((label1) => {
                if (!previous.find((label2) => label1 === label2 || isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((label1) => {
                if (!current.find((label2) => label1 === label2 || isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('labels:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('labels:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region vertices
    get vertices() {
        return this.getVertices();
    }
    set vertices(vertices) {
        this.setVertices(vertices);
    }
    getVertices() {
        return [...this.store.get('vertices', [])];
    }
    setVertices(vertices, options = {}) {
        const points = Array.isArray(vertices) ? vertices : [vertices];
        this.store.set('vertices', points.map((p) => Point.toJSON(p)), options);
        return this;
    }
    insertVertex(vertice, index, options = {}) {
        const vertices = this.getVertices();
        const len = vertices.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        vertices.splice(idx, 0, Point.toJSON(vertice));
        return this.setVertices(vertices, options);
    }
    appendVertex(vertex, options = {}) {
        return this.insertVertex(vertex, -1, options);
    }
    getVertexAt(index) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            return vertices[index];
        }
        return null;
    }
    setVertexAt(index, vertice, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            vertices[index] = vertice;
            this.setVertices(vertices, options);
        }
        return this;
    }
    removeVertexAt(index, options = {}) {
        const vertices = this.getVertices();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        vertices.splice(idx, 1);
        return this.setVertices(vertices, options);
    }
    onVertexsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((p1) => {
                if (!previous.find((p2) => Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((p1) => {
                if (!current.find((p2) => Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('vertexs:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('vertexs:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region markup
    getDefaultMarkup() {
        return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();
    }
    getMarkup() {
        return super.getMarkup() || this.getDefaultMarkup();
    }
    // #endregion
    // #region transform
    /**
     * Translate the edge vertices (and source and target if they are points)
     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
     */
    translate(tx, ty, options = {}) {
        options.translateBy = options.translateBy || this.id;
        options.tx = tx;
        options.ty = ty;
        return this.applyToPoints((p) => ({
            x: (p.x || 0) + tx,
            y: (p.y || 0) + ty,
        }), options);
    }
    /**
     * Scales the edge's points (vertices) relative to the given origin.
     */
    scale(sx, sy, origin, options = {}) {
        return this.applyToPoints((p) => {
            return Point.create(p).scale(sx, sy, origin).toJSON();
        }, options);
    }
    applyToPoints(worker, options = {}) {
        const attrs = {};
        const source = this.getSource();
        const target = this.getTarget();
        if (Point.isPointLike(source)) {
            attrs.source = worker(source);
        }
        if (Point.isPointLike(target)) {
            attrs.target = worker(target);
        }
        const vertices = this.getVertices();
        if (vertices.length > 0) {
            attrs.vertices = vertices.map(worker);
        }
        this.store.set(attrs, options);
        return this;
    }
    // #endregion
    // #region common
    getBBox() {
        return this.getPolyline().bbox();
    }
    getConnectionPoint() {
        return this.getPolyline().pointAt(0.5);
    }
    getPolyline() {
        const points = [
            this.getSourcePoint(),
            ...this.getVertices().map((vertice) => Point.create(vertice)),
            this.getTargetPoint(),
        ];
        return new Polyline(points);
    }
    updateParent(options) {
        let newParent = null;
        const source = this.getSourceCell();
        const target = this.getTargetCell();
        const prevParent = this.getParent();
        if (source && target) {
            if (source === target || source.isDescendantOf(target)) {
                newParent = target;
            }
            else if (target.isDescendantOf(source)) {
                newParent = source;
            }
            else {
                newParent = Cell.getCommonAncestor(source, target);
            }
        }
        // Unembeds the edge if source and target has no common
        // ancestor or common ancestor changed
        if (prevParent && newParent && newParent.id !== prevParent.id) {
            prevParent.unembed(this, options);
        }
        // Embeds the edge if source and target are not same
        if (newParent && (!prevParent || prevParent.id !== newParent.id)) {
            newParent.embed(this, options);
        }
        return newParent;
    }
    hasLoop(options = {}) {
        const source = this.getSource();
        const target = this.getTarget();
        const sourceId = source.cell;
        const targetId = target.cell;
        if (!sourceId || !targetId) {
            return false;
        }
        let loop = sourceId === targetId;
        // Note that there in the deep mode a edge can have a loop,
        // even if it connects only a parent and its embed.
        // A loop "target equals source" is valid in both shallow and deep mode.
        // eslint-disable-next-line
        if (!loop && options.deep && this._model) {
            const sourceCell = this.getSourceCell();
            const targetCell = this.getTargetCell();
            if (sourceCell && targetCell) {
                loop =
                    sourceCell.isAncestorOf(targetCell, options) ||
                        targetCell.isAncestorOf(sourceCell, options);
            }
        }
        return loop;
    }
    getFragmentAncestor() {
        const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);
        return this.getCommonAncestor(...cells);
    }
    isFragmentDescendantOf(cell) {
        const ancestor = this.getFragmentAncestor();
        return (!!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell)));
    }
};
Edge$1.defaults = {};
(function (Edge) {
    function equalTerminals(a, b) {
        const a1 = a;
        const b1 = b;
        if (a1.cell === b1.cell) {
            return a1.port === b1.port || (a1.port == null && b1.port == null);
        }
        return false;
    }
    Edge.equalTerminals = equalTerminals;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.defaultLabel = {
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            text: {
                fill: '#000',
                fontSize: 14,
                textAnchor: 'middle',
                textVerticalAnchor: 'middle',
                pointerEvents: 'none',
            },
            rect: {
                ref: 'label',
                fill: '#fff',
                rx: 3,
                ry: 3,
                refWidth: 1,
                refHeight: 1,
                refX: 0,
                refY: 0,
            },
        },
        position: {
            distance: 0.5,
        },
    };
    function parseStringLabel(text) {
        return {
            attrs: { label: { text } },
        };
    }
    Edge.parseStringLabel = parseStringLabel;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.toStringTag = `X6.${Edge.name}`;
    function isEdge(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Edge) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const edge = instance;
        if ((tag == null || tag === Edge.toStringTag) &&
            typeof edge.isNode === 'function' &&
            typeof edge.isEdge === 'function' &&
            typeof edge.prop === 'function' &&
            typeof edge.attr === 'function' &&
            typeof edge.disconnect === 'function' &&
            typeof edge.getSource === 'function' &&
            typeof edge.getTarget === 'function') {
            return true;
        }
        return false;
    }
    Edge.isEdge = isEdge;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.registry = Registry.create({
        type: 'edge',
        process(shape, options) {
            if (ShareRegistry.exist(shape, false)) {
                throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Edge;
            // default inherit from 'dege'
            const { inherit = 'edge' } = options, others = __rest$a(options, ["inherit"]);
            if (typeof inherit === 'string') {
                const base = this.get(inherit || 'edge');
                if (base == null && inherit) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            else {
                parent = inherit;
            }
            if (others.constructorName == null) {
                others.constructorName = shape;
            }
            const ctor = parent.define.call(parent, others);
            ctor.config({ shape });
            return ctor;
        },
    });
    ShareRegistry.setEdgeRegistry(Edge.registry);
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return pascalCase(name);
        }
        counter += 1;
        return `CustomEdge${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest$a(config, ["constructorName", "overwrite"]);
        const ctor = createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Edge.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Edge.define = define;
    function create(options) {
        const shape = options.shape || 'edge';
        const Ctor = Edge.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Edge.registry.onNotFound(shape);
    }
    Edge.create = create;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    const shape = 'basic.edge';
    Edge.config({
        shape,
        propHooks(metadata) {
            const { label, vertices } = metadata, others = __rest$a(metadata, ["label", "vertices"]);
            if (label) {
                if (others.labels == null) {
                    others.labels = [];
                }
                const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;
                others.labels.push(formated);
            }
            if (vertices) {
                if (Array.isArray(vertices)) {
                    others.vertices = vertices.map((item) => Point.create(item).toJSON());
                }
            }
            return others;
        },
    });
    Edge.registry.register(shape, Edge);
})(Edge$1 || (Edge$1 = {}));

var __decorate$e = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Collection extends Basecoat {
    constructor(cells, options = {}) {
        super();
        this.length = 0;
        this.comparator = options.comparator || 'zIndex';
        this.clean();
        if (cells) {
            this.reset(cells, { silent: true });
        }
    }
    toJSON() {
        return this.cells.map((cell) => cell.toJSON());
    }
    add(cells, index, options) {
        let localIndex;
        let localOptions;
        if (typeof index === 'number') {
            localIndex = index;
            localOptions = Object.assign({ merge: false }, options);
        }
        else {
            localIndex = this.length;
            localOptions = Object.assign({ merge: false }, index);
        }
        if (localIndex > this.length) {
            localIndex = this.length;
        }
        if (localIndex < 0) {
            localIndex += this.length + 1;
        }
        const entities = Array.isArray(cells) ? cells : [cells];
        const sortable = this.comparator &&
            typeof index !== 'number' &&
            localOptions.sort !== false;
        const sortAttr = this.comparator || null;
        let sort = false;
        const added = [];
        const merged = [];
        entities.forEach((cell) => {
            const existing = this.get(cell);
            if (existing) {
                if (localOptions.merge && !cell.isSameStore(existing)) {
                    existing.setProp(cell.getProp(), options); // merge
                    merged.push(existing);
                    if (sortable && !sort) {
                        if (sortAttr == null || typeof sortAttr === 'function') {
                            sort = existing.hasChanged();
                        }
                        else if (typeof sortAttr === 'string') {
                            sort = existing.hasChanged(sortAttr);
                        }
                        else {
                            sort = sortAttr.some((key) => existing.hasChanged(key));
                        }
                    }
                }
            }
            else {
                added.push(cell);
                this.reference(cell);
            }
        });
        if (added.length) {
            if (sortable) {
                sort = true;
            }
            this.cells.splice(localIndex, 0, ...added);
            this.length = this.cells.length;
        }
        if (sort) {
            this.sort({ silent: true });
        }
        if (!localOptions.silent) {
            added.forEach((cell, i) => {
                const args = {
                    cell,
                    index: localIndex + i,
                    options: localOptions,
                };
                this.trigger('added', args);
                if (!localOptions.dryrun) {
                    cell.notify('added', Object.assign({}, args));
                }
            });
            if (sort) {
                this.trigger('sorted');
            }
            if (added.length || merged.length) {
                this.trigger('updated', {
                    added,
                    merged,
                    removed: [],
                    options: localOptions,
                });
            }
        }
        return this;
    }
    remove(cells, options = {}) {
        const arr = Array.isArray(cells) ? cells : [cells];
        const removed = this.removeCells(arr, options);
        if (!options.silent && removed.length > 0) {
            this.trigger('updated', {
                options,
                removed,
                added: [],
                merged: [],
            });
        }
        return Array.isArray(cells) ? removed : removed[0];
    }
    removeCells(cells, options) {
        const removed = [];
        for (let i = 0; i < cells.length; i += 1) {
            const cell = this.get(cells[i]);
            if (cell == null) {
                continue;
            }
            const index = this.cells.indexOf(cell);
            this.cells.splice(index, 1);
            this.length -= 1;
            delete this.map[cell.id];
            removed.push(cell);
            this.unreference(cell);
            if (!options.dryrun) {
                cell.remove();
            }
            if (!options.silent) {
                this.trigger('removed', { cell, index, options });
                if (!options.dryrun) {
                    cell.notify('removed', { cell, index, options });
                }
            }
        }
        return removed;
    }
    reset(cells, options = {}) {
        const previous = this.cells.slice();
        previous.forEach((cell) => this.unreference(cell));
        this.clean();
        this.add(cells, Object.assign({ silent: true }, options));
        if (!options.silent) {
            const current = this.cells.slice();
            this.trigger('reseted', {
                options,
                previous,
                current,
            });
            const added = [];
            const removed = [];
            current.forEach((a) => {
                const exist = previous.some((b) => b.id === a.id);
                if (!exist) {
                    added.push(a);
                }
            });
            previous.forEach((a) => {
                const exist = current.some((b) => b.id === a.id);
                if (!exist) {
                    removed.push(a);
                }
            });
            this.trigger('updated', { options, added, removed, merged: [] });
        }
        return this;
    }
    push(cell, options) {
        return this.add(cell, this.length, options);
    }
    pop(options) {
        const cell = this.at(this.length - 1);
        return this.remove(cell, options);
    }
    unshift(cell, options) {
        return this.add(cell, 0, options);
    }
    shift(options) {
        const cell = this.at(0);
        return this.remove(cell, options);
    }
    get(cell) {
        if (cell == null) {
            return null;
        }
        const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;
        return this.map[id] || null;
    }
    has(cell) {
        return this.get(cell) != null;
    }
    at(index) {
        if (index < 0) {
            index += this.length; // eslint-disable-line
        }
        return this.cells[index] || null;
    }
    first() {
        return this.at(0);
    }
    last() {
        return this.at(-1);
    }
    indexOf(cell) {
        return this.cells.indexOf(cell);
    }
    toArray() {
        return this.cells.slice();
    }
    sort(options = {}) {
        if (this.comparator != null) {
            this.cells = sortBy$1(this.cells, this.comparator);
            if (!options.silent) {
                this.trigger('sorted');
            }
        }
        return this;
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.cells.slice(), {
            comparator: this.comparator,
        });
    }
    reference(cell) {
        this.map[cell.id] = cell;
        cell.on('*', this.notifyCellEvent, this);
    }
    unreference(cell) {
        cell.off('*', this.notifyCellEvent, this);
        delete this.map[cell.id];
    }
    notifyCellEvent(name, args) {
        const cell = args.cell;
        this.trigger(`cell:${name}`, args);
        if (cell) {
            if (cell.isNode()) {
                this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));
            }
        }
    }
    clean() {
        this.length = 0;
        this.cells = [];
        this.map = {};
    }
    dispose() {
        this.reset([]);
    }
}
__decorate$e([
    Collection.dispose()
], Collection.prototype, "dispose", null);

var __decorate$d = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Model extends Basecoat {
    get [Symbol.toStringTag]() {
        return Model.toStringTag;
    }
    constructor(cells = []) {
        super();
        this.batches = {};
        this.addings = new WeakMap();
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        this.collection = new Collection(cells);
        this.setup();
    }
    notify(name, args) {
        this.trigger(name, args);
        const graph = this.graph;
        if (graph) {
            if (name === 'sorted' || name === 'reseted' || name === 'updated') {
                graph.trigger(`model:${name}`, args);
            }
            else {
                graph.trigger(name, args);
            }
        }
        return this;
    }
    setup() {
        const collection = this.collection;
        collection.on('sorted', () => this.notify('sorted', null));
        collection.on('updated', (args) => this.notify('updated', args));
        collection.on('cell:change:zIndex', () => this.sortOnChangeZ());
        collection.on('added', ({ cell }) => {
            this.onCellAdded(cell);
        });
        collection.on('removed', (args) => {
            const cell = args.cell;
            this.onCellRemoved(cell, args.options);
            // Should trigger remove-event manually after cell was removed.
            this.notify('cell:removed', args);
            if (cell.isNode()) {
                this.notify('node:removed', Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.notify('edge:removed', Object.assign(Object.assign({}, args), { edge: cell }));
            }
        });
        collection.on('reseted', (args) => {
            this.onReset(args.current);
            this.notify('reseted', args);
        });
        collection.on('edge:change:source', ({ edge }) => this.onEdgeTerminalChanged(edge, 'source'));
        collection.on('edge:change:target', ({ edge }) => {
            this.onEdgeTerminalChanged(edge, 'target');
        });
    }
    sortOnChangeZ() {
        this.collection.sort();
    }
    onCellAdded(cell) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            // Auto update edge's parent
            cell.updateParent();
            this.edges[cellId] = true;
            this.onEdgeTerminalChanged(cell, 'source');
            this.onEdgeTerminalChanged(cell, 'target');
        }
        else {
            this.nodes[cellId] = true;
        }
    }
    onCellRemoved(cell, options) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            delete this.edges[cellId];
            const source = cell.getSource();
            const target = cell.getTarget();
            if (source && source.cell) {
                const cache = this.outgoings[source.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.outgoings[source.cell];
                    }
                }
            }
            if (target && target.cell) {
                const cache = this.incomings[target.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.incomings[target.cell];
                    }
                }
            }
        }
        else {
            delete this.nodes[cellId];
        }
        if (!options.clear) {
            if (options.disconnectEdges) {
                this.disconnectConnectedEdges(cell, options);
            }
            else {
                this.removeConnectedEdges(cell, options);
            }
        }
        if (cell.model === this) {
            cell.model = null;
        }
    }
    onReset(cells) {
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        cells.forEach((cell) => this.onCellAdded(cell));
    }
    onEdgeTerminalChanged(edge, type) {
        const ref = type === 'source' ? this.outgoings : this.incomings;
        const prev = edge.previous(type);
        if (prev && prev.cell) {
            const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
            const cache = ref[cellId];
            const index = cache ? cache.indexOf(edge.id) : -1;
            if (index >= 0) {
                cache.splice(index, 1);
                if (cache.length === 0) {
                    delete ref[cellId];
                }
            }
        }
        const terminal = edge.getTerminal(type);
        if (terminal && terminal.cell) {
            const terminalId = Cell.isCell(terminal.cell)
                ? terminal.cell.id
                : terminal.cell;
            const cache = ref[terminalId] || [];
            const index = cache.indexOf(edge.id);
            if (index === -1) {
                cache.push(edge.id);
            }
            ref[terminalId] = cache;
        }
    }
    prepareCell(cell, options) {
        if (!cell.model && (!options || !options.dryrun)) {
            cell.model = this;
        }
        if (cell.zIndex == null) {
            cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });
        }
        return cell;
    }
    resetCells(cells, options = {}) {
        // Do not update model at this time. Because if we just update the graph
        // with the same json-data, the edge will reference to the old nodes.
        cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));
        this.collection.reset(cells, options);
        // Update model and trigger edge update it's references
        cells.map((cell) => this.prepareCell(cell, { options }));
        return this;
    }
    clear(options = {}) {
        const raw = this.getCells();
        if (raw.length === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { clear: true });
        this.batchUpdate('clear', () => {
            // The nodes come after the edges.
            const cells = raw.sort((a, b) => {
                const v1 = a.isEdge() ? 1 : 2;
                const v2 = b.isEdge() ? 1 : 2;
                return v1 - v2;
            });
            while (cells.length > 0) {
                // Note that all the edges are removed first, so it's safe to
                // remove the nodes without removing the connected edges first.
                const cell = cells.shift();
                if (cell) {
                    cell.remove(localOptions);
                }
            }
        }, localOptions);
        return this;
    }
    addNode(metadata, options = {}) {
        const node = Node$1.isNode(metadata) ? metadata : this.createNode(metadata);
        this.addCell(node, options);
        return node;
    }
    updateNode(metadata, options = {}) {
        const node = this.createNode(metadata);
        const prop = node.getProp();
        node.dispose();
        return this.updateCell(prop, options);
    }
    createNode(metadata) {
        return Node$1.create(metadata);
    }
    addEdge(metadata, options = {}) {
        const edge = Edge$1.isEdge(metadata) ? metadata : this.createEdge(metadata);
        this.addCell(edge, options);
        return edge;
    }
    createEdge(metadata) {
        return Edge$1.create(metadata);
    }
    updateEdge(metadata, options = {}) {
        const edge = this.createEdge(metadata);
        const prop = edge.getProp();
        edge.dispose();
        return this.updateCell(prop, options);
    }
    addCell(cell, options = {}) {
        if (Array.isArray(cell)) {
            return this.addCells(cell, options);
        }
        if (!this.collection.has(cell) && !this.addings.has(cell)) {
            this.addings.set(cell, true);
            this.collection.add(this.prepareCell(cell, options), options);
            cell.eachChild((child) => this.addCell(child, options));
            this.addings.delete(cell);
        }
        return this;
    }
    addCells(cells, options = {}) {
        const count = cells.length;
        if (count === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });
        this.startBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        cells.forEach((cell) => {
            this.addCell(cell, localOptions);
            localOptions.position -= 1;
        });
        this.stopBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        return this;
    }
    updateCell(prop, options = {}) {
        const existing = prop.id && this.getCell(prop.id);
        if (existing) {
            return this.batchUpdate('update', () => {
                Object.entries(prop).forEach(([key, val]) => existing.setProp(key, val, options));
                return true;
            }, prop);
        }
        return false;
    }
    removeCell(obj, options = {}) {
        const cell = typeof obj === 'string' ? this.getCell(obj) : obj;
        if (cell && this.has(cell)) {
            return this.collection.remove(cell, options);
        }
        return null;
    }
    updateCellId(cell, newId) {
        if (cell.id === newId)
            return;
        this.startBatch('update', { id: newId });
        cell.prop('id', newId);
        const newCell = cell.clone({ keepId: true });
        this.addCell(newCell);
        // update connected edge terminal
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell === cell) {
                edge.setSource(Object.assign(Object.assign({}, edge.getSource()), { cell: newId }));
            }
            if (targetCell === cell) {
                edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { cell: newId }));
            }
        });
        this.removeCell(cell);
        this.stopBatch('update', { id: newId });
        return newCell;
    }
    removeCells(cells, options = {}) {
        if (cells.length) {
            return this.batchUpdate('remove', () => {
                return cells.map((cell) => this.removeCell(cell, options));
            });
        }
        return [];
    }
    removeConnectedEdges(cell, options = {}) {
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            edge.remove(options);
        });
        return edges;
    }
    disconnectConnectedEdges(cell, options = {}) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        this.getConnectedEdges(cell).forEach((edge) => {
            const sourceCellId = edge.getSourceCellId();
            const targetCellId = edge.getTargetCellId();
            if (sourceCellId === cellId) {
                edge.setSource({ x: 0, y: 0 }, options);
            }
            if (targetCellId === cellId) {
                edge.setTarget({ x: 0, y: 0 }, options);
            }
        });
    }
    has(obj) {
        return this.collection.has(obj);
    }
    total() {
        return this.collection.length;
    }
    indexOf(cell) {
        return this.collection.indexOf(cell);
    }
    /**
     * Returns a cell from the graph by its id.
     */
    getCell(id) {
        return this.collection.get(id);
    }
    /**
     * Returns all the nodes and edges in the graph.
     */
    getCells() {
        return this.collection.toArray();
    }
    /**
     * Returns the first cell (node or edge) in the graph. The first cell is
     * defined as the cell with the lowest `zIndex`.
     */
    getFirstCell() {
        return this.collection.first();
    }
    /**
     * Returns the last cell (node or edge) in the graph. The last cell is
     * defined as the cell with the highest `zIndex`.
     */
    getLastCell() {
        return this.collection.last();
    }
    /**
     * Returns the lowest `zIndex` value in the graph.
     */
    getMinZIndex() {
        const first = this.collection.first();
        return first ? first.getZIndex() || 0 : 0;
    }
    /**
     * Returns the highest `zIndex` value in the graph.
     */
    getMaxZIndex() {
        const last = this.collection.last();
        return last ? last.getZIndex() || 0 : 0;
    }
    getCellsFromCache(cache) {
        return cache
            ? Object.keys(cache)
                .map((id) => this.getCell(id))
                .filter((cell) => cell != null)
            : [];
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.getCellsFromCache(this.nodes);
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.getCellsFromCache(this.edges);
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.outgoings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.incomings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        const result = [];
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        if (node == null) {
            return result;
        }
        const cache = {};
        const indirect = options.indirect;
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const collect = (cell, isOutgoing) => {
            const edges = isOutgoing
                ? this.getOutgoingEdges(cell)
                : this.getIncomingEdges(cell);
            if (edges != null) {
                edges.forEach((edge) => {
                    if (cache[edge.id]) {
                        return;
                    }
                    result.push(edge);
                    cache[edge.id] = true;
                    if (indirect) {
                        if (incoming) {
                            collect(edge, false);
                        }
                        if (outgoing) {
                            collect(edge, true);
                        }
                    }
                });
            }
            if (indirect && cell.isEdge()) {
                const terminal = isOutgoing
                    ? cell.getTargetCell()
                    : cell.getSourceCell();
                if (terminal && terminal.isEdge()) {
                    if (!cache[terminal.id]) {
                        result.push(terminal);
                        collect(terminal, isOutgoing);
                    }
                }
            }
        };
        if (outgoing) {
            collect(node, true);
        }
        if (incoming) {
            collect(node, false);
        }
        if (options.deep) {
            const descendants = node.getDescendants({ deep: true });
            const embedsCache = {};
            descendants.forEach((cell) => {
                if (cell.isNode()) {
                    embedsCache[cell.id] = true;
                }
            });
            const collectSub = (cell, isOutgoing) => {
                const edges = isOutgoing
                    ? this.getOutgoingEdges(cell.id)
                    : this.getIncomingEdges(cell.id);
                if (edges != null) {
                    edges.forEach((edge) => {
                        if (!cache[edge.id]) {
                            const sourceCell = edge.getSourceCell();
                            const targetCell = edge.getTargetCell();
                            if (!options.enclosed &&
                                sourceCell &&
                                embedsCache[sourceCell.id] &&
                                targetCell &&
                                embedsCache[targetCell.id]) {
                                return;
                            }
                            result.push(edge);
                            cache[edge.id] = true;
                        }
                    });
                }
            };
            descendants.forEach((cell) => {
                if (cell.isEdge()) {
                    return;
                }
                if (outgoing) {
                    collectSub(cell, true);
                }
                if (incoming) {
                    collectSub(cell, false);
                }
            });
        }
        return result;
    }
    isBoundary(cell, isOrigin) {
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        const arr = isOrigin
            ? this.getIncomingEdges(node)
            : this.getOutgoingEdges(node);
        return arr == null || arr.length === 0;
    }
    getBoundaryNodes(isOrigin) {
        const result = [];
        Object.keys(this.nodes).forEach((nodeId) => {
            if (this.isBoundary(nodeId, isOrigin)) {
                const node = this.getCell(nodeId);
                if (node) {
                    result.push(node);
                }
            }
        });
        return result;
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRoots() {
        return this.getBoundaryNodes(true);
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafs() {
        return this.getBoundaryNodes(false);
    }
    /**
     * Returns `true` if the node is a root node, i.e. there is no edges
     * coming to the node.
     */
    isRoot(cell) {
        return this.isBoundary(cell, true);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e. there is no edges
     * going out from the node.
     */
    isLeaf(cell) {
        return this.isBoundary(cell, false);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const edges = this.getConnectedEdges(cell, options);
        const map = edges.reduce((memo, edge) => {
            const hasLoop = edge.hasLoop(options);
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming &&
                sourceCell &&
                sourceCell.isNode() &&
                !memo[sourceCell.id]) {
                if (hasLoop ||
                    (sourceCell !== cell &&
                        (!options.deep || !sourceCell.isDescendantOf(cell)))) {
                    memo[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing &&
                targetCell &&
                targetCell.isNode() &&
                !memo[targetCell.id]) {
                if (hasLoop ||
                    (targetCell !== cell &&
                        (!options.deep || !targetCell.isDescendantOf(cell)))) {
                    memo[targetCell.id] = targetCell;
                }
            }
            return memo;
        }, {});
        if (cell.isEdge()) {
            if (incoming) {
                const sourceCell = cell.getSourceCell();
                if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
                    map[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing) {
                const targetCell = cell.getTargetCell();
                if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
                    map[targetCell.id] = targetCell;
                }
            }
        }
        return Object.keys(map).map((id) => map[id]);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        return this.getConnectedEdges(cell1, options).some((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming && sourceCell && sourceCell.id === cell2.id) {
                return true;
            }
            if (outgoing && targetCell && targetCell.id === cell2.id) {
                return true;
            }
            return false;
        });
    }
    getSuccessors(cell, options = {}) {
        const successors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                successors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return successors;
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return result;
    }
    getPredecessors(cell, options = {}) {
        const predecessors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                predecessors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return predecessors;
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return result;
    }
    matchDistance(distance, preset) {
        if (preset == null) {
            return true;
        }
        if (typeof preset === 'function') {
            return preset(distance);
        }
        if (Array.isArray(preset) && preset.includes(distance)) {
            return true;
        }
        return distance === preset;
    }
    /**
     * Returns the common ancestor of the passed cells.
     */
    getCommonAncestor(...cells) {
        const arr = [];
        cells.forEach((item) => {
            if (item) {
                if (Array.isArray(item)) {
                    arr.push(...item);
                }
                else {
                    arr.push(item);
                }
            }
        });
        return Cell.getCommonAncestor(...arr);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        const subgraph = [];
        const cache = {};
        const nodes = [];
        const edges = [];
        const collect = (cell) => {
            if (!cache[cell.id]) {
                subgraph.push(cell);
                cache[cell.id] = cell;
                if (cell.isEdge()) {
                    edges.push(cell);
                }
                if (cell.isNode()) {
                    nodes.push(cell);
                }
            }
        };
        cells.forEach((cell) => {
            collect(cell);
            if (options.deep) {
                const descendants = cell.getDescendants({ deep: true });
                descendants.forEach((descendant) => collect(descendant));
            }
        });
        edges.forEach((edge) => {
            // For edges, include their source & target
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell && !cache[sourceCell.id]) {
                subgraph.push(sourceCell);
                cache[sourceCell.id] = sourceCell;
                if (sourceCell.isNode()) {
                    nodes.push(sourceCell);
                }
            }
            if (targetCell && !cache[targetCell.id]) {
                subgraph.push(targetCell);
                cache[targetCell.id] = targetCell;
                if (targetCell.isNode()) {
                    nodes.push(targetCell);
                }
            }
        });
        nodes.forEach((node) => {
            // For nodes, include their connected edges if their source/target
            // is in the subgraph.
            const edges = this.getConnectedEdges(node, options);
            edges.forEach((edge) => {
                const sourceCell = edge.getSourceCell();
                const targetCell = edge.getTargetCell();
                if (!cache[edge.id] &&
                    sourceCell &&
                    cache[sourceCell.id] &&
                    targetCell &&
                    cache[targetCell.id]) {
                    subgraph.push(edge);
                    cache[edge.id] = edge;
                }
            });
        });
        return subgraph;
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        const subgraph = this.getSubGraph(cells, options);
        return this.cloneCells(subgraph);
    }
    cloneCells(cells) {
        return Cell.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y || 0 } : x;
        return this.getNodes().filter((node) => {
            return node.getBBox().containsPoint(p);
        });
    }
    getNodesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new Rectangle(x, y, w, h)
            : Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getNodes().filter((node) => {
            const bbox = node.getBBox();
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getEdgesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new Rectangle(x, y, w, h)
            : Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getEdges().filter((edge) => {
            const bbox = edge.getBBox();
            if (bbox.width === 0) {
                bbox.inflate(1, 0);
            }
            else if (bbox.height === 0) {
                bbox.inflate(0, 1);
            }
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getNodesUnderNode(node, options = {}) {
        const bbox = node.getBBox();
        const nodes = options.by == null || options.by === 'bbox'
            ? this.getNodesInArea(bbox)
            : this.getNodesFromPoint(bbox[options.by]);
        return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.getCellsBBox(this.getCells());
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return Cell.getCellsBBox(cells, options);
    }
    // #region search
    search(cell, iterator, options = {}) {
        if (options.breadthFirst) {
            this.breadthFirstSearch(cell, iterator, options);
        }
        else {
            this.depthFirstSearch(cell, iterator, options);
        }
    }
    breadthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.shift();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (call$1(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.push(neighbor);
            });
        }
    }
    depthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.pop();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (call$1(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            const lastIndex = queue.length;
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.splice(lastIndex, 0, neighbor);
            });
        }
    }
    // #endregion
    // #region shortest path
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        const adjacencyList = {};
        this.getEdges().forEach((edge) => {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (sourceId && targetId) {
                if (!adjacencyList[sourceId]) {
                    adjacencyList[sourceId] = [];
                }
                if (!adjacencyList[targetId]) {
                    adjacencyList[targetId] = [];
                }
                adjacencyList[sourceId].push(targetId);
                if (!options.directed) {
                    adjacencyList[targetId].push(sourceId);
                }
            }
        });
        const sourceId = typeof source === 'string' ? source : source.id;
        const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);
        const path = [];
        let targetId = typeof target === 'string' ? target : target.id;
        if (previous[targetId]) {
            path.push(targetId);
        }
        while ((targetId = previous[targetId])) {
            path.unshift(targetId);
        }
        return path;
    }
    // #endregion
    // #region transform
    /**
     * Translate all cells in the graph by `tx` and `ty` pixels.
     */
    translate(tx, ty, options) {
        this.getCells()
            .filter((cell) => !cell.hasParent())
            .forEach((cell) => cell.translate(tx, ty, options));
        return this;
    }
    resize(width, height, options) {
        return this.resizeCells(width, height, this.getCells(), options);
    }
    resizeCells(width, height, cells, options = {}) {
        const bbox = this.getCellsBBox(cells);
        if (bbox) {
            const sx = Math.max(width / bbox.width, 0);
            const sy = Math.max(height / bbox.height, 0);
            const origin = bbox.getOrigin();
            cells.forEach((cell) => cell.scale(sx, sy, origin, options));
        }
        return this;
    }
    // #endregion
    // #region serialize/deserialize
    toJSON(options = {}) {
        return Model.toJSON(this.getCells(), options);
    }
    parseJSON(data) {
        return Model.fromJSON(data);
    }
    fromJSON(data, options = {}) {
        const cells = this.parseJSON(data);
        this.resetCells(cells, options);
        return this;
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) + 1;
        this.notify('batch:start', { name, data });
        return this;
    }
    stopBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) - 1;
        this.notify('batch:stop', { name, data });
        return this;
    }
    batchUpdate(name, execute, data = {}) {
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    hasActiveBatch(name = Object.keys(this.batches)) {
        const names = Array.isArray(name) ? name : [name];
        return names.some((batch) => this.batches[batch] > 0);
    }
    // #endregion
    dispose() {
        this.collection.dispose();
    }
}
__decorate$d([
    Model.dispose()
], Model.prototype, "dispose", null);
(function (Model) {
    Model.toStringTag = `X6.${Model.name}`;
    function isModel(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Model) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const model = instance;
        if ((tag == null || tag === Model.toStringTag) &&
            typeof model.addNode === 'function' &&
            typeof model.addEdge === 'function' &&
            model.collection != null) {
            return true;
        }
        return false;
    }
    Model.isModel = isModel;
})(Model || (Model = {}));
(function (Model) {
    function toJSON(cells, options = {}) {
        return {
            cells: cells.map((cell) => cell.toJSON(options)),
        };
    }
    Model.toJSON = toJSON;
    function fromJSON(data) {
        const cells = [];
        if (Array.isArray(data)) {
            cells.push(...data);
        }
        else {
            if (data.cells) {
                cells.push(...data.cells);
            }
            if (data.nodes) {
                data.nodes.forEach((node) => {
                    if (node.shape == null) {
                        node.shape = 'rect';
                    }
                    cells.push(node);
                });
            }
            if (data.edges) {
                data.edges.forEach((edge) => {
                    if (edge.shape == null) {
                        edge.shape = 'edge';
                    }
                    cells.push(edge);
                });
            }
        }
        return cells.map((cell) => {
            const type = cell.shape;
            if (type) {
                if (Node$1.registry.exist(type)) {
                    return Node$1.create(cell);
                }
                if (Edge$1.registry.exist(type)) {
                    return Edge$1.create(cell);
                }
            }
            throw new Error('The `shape` should be specified when creating a node/edge instance');
        });
    }
    Model.fromJSON = fromJSON;
})(Model || (Model = {}));

var __rest$9 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Base$1 = class Base extends Node$1 {
    get label() {
        return this.getLabel();
    }
    set label(val) {
        this.setLabel(val);
    }
    getLabel() {
        return this.getAttrByPath('text/text');
    }
    setLabel(label, options) {
        if (label == null) {
            this.removeLabel();
        }
        else {
            this.setAttrByPath('text/text', label, options);
        }
        return this;
    }
    removeLabel() {
        this.removeAttrByPath('text/text');
        return this;
    }
};
(function (Base) {
    Base.bodyAttr = {
        fill: '#ffffff',
        stroke: '#333333',
        strokeWidth: 2,
    };
    Base.labelAttr = {
        fontSize: 14,
        fill: '#000000',
        refX: 0.5,
        refY: 0.5,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        fontFamily: 'Arial, helvetica, sans-serif',
    };
    Base.config({
        attrs: { text: Object.assign({}, Base.labelAttr) },
        propHooks(metadata) {
            const { label } = metadata, others = __rest$9(metadata, ["label"]);
            if (label) {
                setByPath(others, 'attrs/text/text', label);
            }
            return others;
        },
        visible: true,
    });
})(Base$1 || (Base$1 = {}));

var __rest$8 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function getMarkup(tagName, selector = 'body') {
    return [
        {
            tagName,
            selector,
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ];
}
function getImageUrlHook(attrName = 'xlink:href') {
    const hook = (metadata) => {
        const { imageUrl, imageWidth, imageHeight } = metadata, others = __rest$8(metadata, ["imageUrl", "imageWidth", "imageHeight"]);
        if (imageUrl != null || imageWidth != null || imageHeight != null) {
            const apply = () => {
                if (others.attrs) {
                    const image = others.attrs.image;
                    if (imageUrl != null) {
                        image[attrName] = imageUrl;
                    }
                    if (imageWidth != null) {
                        image.width = imageWidth;
                    }
                    if (imageHeight != null) {
                        image.height = imageHeight;
                    }
                    others.attrs.image = image;
                }
            };
            if (others.attrs) {
                if (others.attrs.image == null) {
                    others.attrs.image = {};
                }
                apply();
            }
            else {
                others.attrs = {
                    image: {},
                };
                apply();
            }
        }
        return others;
    };
    return hook;
}
function createShape(shape, config, options = {}) {
    const defaults = {
        constructorName: shape,
        markup: getMarkup(shape, options.selector),
        attrs: {
            [shape]: Object.assign({}, Base$1.bodyAttr),
        },
    };
    const base = options.parent || Base$1;
    return base.define(merge$1(defaults, config, { shape }));
}

createShape('rect', {
    attrs: {
        body: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
});

const Edge = Edge$1.define({
    shape: 'edge',
    markup: [
        {
            tagName: 'path',
            selector: 'wrap',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                cursor: 'pointer',
                stroke: 'transparent',
                strokeLinecap: 'round',
            },
        },
        {
            tagName: 'path',
            selector: 'line',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                pointerEvents: 'none',
            },
        },
    ],
    attrs: {
        lines: {
            connection: true,
            strokeLinejoin: 'round',
        },
        wrap: {
            strokeWidth: 10,
        },
        line: {
            stroke: '#333',
            strokeWidth: 2,
            targetMarker: 'classic',
        },
    },
});

createShape('ellipse', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refRx: '50%',
            refRy: '50%',
        },
    },
});

var __rest$7 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Poly extends Base$1 {
    get points() {
        return this.getPoints();
    }
    set points(pts) {
        this.setPoints(pts);
    }
    getPoints() {
        return this.getAttrByPath('body/refPoints');
    }
    setPoints(points, options) {
        if (points == null) {
            this.removePoints();
        }
        else {
            this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options);
        }
        return this;
    }
    removePoints() {
        this.removeAttrByPath('body/refPoints');
        return this;
    }
}
(function (Poly) {
    function pointsToString(points) {
        return typeof points === 'string'
            ? points
            : points
                .map((p) => {
                if (Array.isArray(p)) {
                    return p.join(',');
                }
                if (Point.isPointLike(p)) {
                    return `${p.x}, ${p.y}`;
                }
                return '';
            })
                .join(' ');
    }
    Poly.pointsToString = pointsToString;
    Poly.config({
        propHooks(metadata) {
            const { points } = metadata, others = __rest$7(metadata, ["points"]);
            if (points) {
                const data = pointsToString(points);
                if (data) {
                    setByPath(others, 'attrs/body/refPoints', data);
                }
            }
            return others;
        },
    });
})(Poly || (Poly = {}));

createShape('polygon', {}, { parent: Poly });

createShape('polyline', {}, { parent: Poly });

var __rest$6 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Base$1.define({
    shape: 'path',
    markup: [
        {
            tagName: 'rect',
            selector: 'bg',
        },
        {
            tagName: 'path',
            selector: 'body',
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        bg: {
            refWidth: '100%',
            refHeight: '100%',
            fill: 'none',
            stroke: 'none',
            pointerEvents: 'all',
        },
        body: {
            fill: 'none',
            stroke: '#000',
            strokeWidth: 2,
        },
    },
    propHooks(metadata) {
        const { path } = metadata, others = __rest$6(metadata, ["path"]);
        if (path) {
            setByPath(others, 'attrs/body/refD', path);
        }
        return others;
    },
});

var __rest$5 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Base$1.define({
    shape: 'text-block',
    markup: [
        {
            tagName: 'rect',
            selector: 'body',
        },
        Platform.SUPPORT_FOREIGNOBJECT
            ? {
                tagName: 'foreignObject',
                selector: 'foreignObject',
                children: [
                    {
                        tagName: 'div',
                        ns: ns.xhtml,
                        selector: 'label',
                        style: {
                            width: '100%',
                            height: '100%',
                            position: 'static',
                            backgroundColor: 'transparent',
                            textAlign: 'center',
                            margin: 0,
                            padding: '0px 5px',
                            boxSizing: 'border-box',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                        },
                    },
                ],
            }
            : {
                tagName: 'text',
                selector: 'label',
                attrs: {
                    textAnchor: 'middle',
                },
            },
    ],
    attrs: {
        body: Object.assign(Object.assign({}, Base$1.bodyAttr), { refWidth: '100%', refHeight: '100%' }),
        foreignObject: {
            refWidth: '100%',
            refHeight: '100%',
        },
        label: {
            style: {
                fontSize: 14,
            },
        },
    },
    propHooks(metadata) {
        const { text } = metadata, others = __rest$5(metadata, ["text"]);
        if (text) {
            setByPath(others, 'attrs/label/text', text);
        }
        return others;
    },
    attrHooks: {
        text: {
            set(text, { cell, view, refBBox, elem, attrs }) {
                if (elem instanceof HTMLElement) {
                    elem.textContent = text;
                }
                else {
                    // No foreign object
                    const style = attrs.style || {};
                    const wrapValue = { text, width: -5, height: '100%' };
                    const wrapAttrs = Object.assign({ textVerticalAnchor: 'middle' }, style);
                    const textWrap = Attr.presets.textWrap;
                    call$1(textWrap.set, this, wrapValue, {
                        cell,
                        view,
                        elem,
                        refBBox,
                        attrs: wrapAttrs,
                    });
                    return { fill: style.color || null };
                }
            },
            position(text, { refBBox, elem }) {
                if (elem instanceof SVGElement) {
                    return refBBox.getCenter();
                }
            },
        },
    },
});

createShape('image', {
    attrs: {
        image: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
    propHooks: getImageUrlHook(),
}, {
    selector: 'image',
});

createShape('circle', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refR: '50%',
        },
    },
});

class NodeView extends CellView {
    constructor() {
        super(...arguments);
        this.portsCache = {};
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return NodeView.toStringTag;
    }
    getContainerClassName() {
        const classList = [
            super.getContainerClassName(),
            this.prefixClassName('node'),
        ];
        if (!this.can('nodeMovable')) {
            classList.push(this.prefixClassName('node-immovable'));
        }
        return classList.join(' ');
    }
    updateClassName(e) {
        const target = e.target;
        if (target.hasAttribute('magnet')) {
            // port
            const className = this.prefixClassName('port-unconnectable');
            if (this.can('magnetConnectable')) {
                removeClass(target, className);
            }
            else {
                addClass(target, className);
            }
        }
        else {
            // node
            const className = this.prefixClassName('node-immovable');
            if (this.can('nodeMovable')) {
                this.removeClass(className);
            }
            else {
                this.addClass(className);
            }
        }
    }
    isNodeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ret = flag;
        if (this.hasAction(ret, 'ports')) {
            this.removePorts();
            this.cleanPortsCache();
        }
        if (this.hasAction(ret, 'render')) {
            this.render();
            ret = this.removeAction(ret, [
                'render',
                'update',
                'resize',
                'translate',
                'rotate',
                'ports',
                'tools',
            ]);
        }
        else {
            ret = this.handleAction(ret, 'resize', () => this.resize(), 'update');
            ret = this.handleAction(ret, 'update', () => this.update(), 
            // `update()` will render ports when useCSSSelectors are enabled
            'ports' );
            ret = this.handleAction(ret, 'translate', () => this.translate());
            ret = this.handleAction(ret, 'rotate', () => this.rotate());
            ret = this.handleAction(ret, 'ports', () => this.renderPorts());
            ret = this.handleAction(ret, 'tools', () => {
                if (this.getFlag('tools') === flag) {
                    this.renderTools();
                }
                else {
                    this.updateTools(options);
                }
            });
        }
        return ret;
    }
    update(partialAttrs) {
        this.cleanCache();
        // When CSS selector strings are used, make sure no rule matches port nodes.
        {
            this.removePorts();
        }
        const node = this.cell;
        const size = node.getSize();
        const attrs = node.getAttrs();
        this.updateAttrs(this.container, attrs, {
            attrs: partialAttrs === attrs ? null : partialAttrs,
            rootBBox: new Rectangle(0, 0, size.width, size.height),
            selectors: this.selectors,
        });
        {
            this.renderPorts();
        }
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                throw new TypeError('Not support string markup.');
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid node markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        this.selectors = ret.selectors;
        this.container.appendChild(ret.fragment);
    }
    render() {
        this.empty();
        this.renderMarkup();
        this.resize();
        this.updateTransform();
        this.renderTools();
        return this;
    }
    resize() {
        if (this.cell.getAngle()) {
            this.rotate();
        }
        this.update();
    }
    translate() {
        this.updateTransform();
    }
    rotate() {
        this.updateTransform();
    }
    getTranslationString() {
        const position = this.cell.getPosition();
        return `translate(${position.x},${position.y})`;
    }
    getRotationString() {
        const angle = this.cell.getAngle();
        if (angle) {
            const size = this.cell.getSize();
            return `rotate(${angle},${size.width / 2},${size.height / 2})`;
        }
    }
    updateTransform() {
        let transform = this.getTranslationString();
        const rot = this.getRotationString();
        if (rot) {
            transform += ` ${rot}`;
        }
        this.container.setAttribute('transform', transform);
    }
    // #region ports
    findPortElem(portId, selector) {
        const cache = portId ? this.portsCache[portId] : null;
        if (!cache) {
            return null;
        }
        const portRoot = cache.portContentElement;
        const portSelectors = cache.portContentSelectors || {};
        return this.findOne(selector, portRoot, portSelectors);
    }
    cleanPortsCache() {
        this.portsCache = {};
    }
    removePorts() {
        Object.values(this.portsCache).forEach((cached) => {
            remove(cached.portElement);
        });
    }
    renderPorts() {
        const container = this.container;
        // References to rendered elements without z-index
        const references = [];
        container.childNodes.forEach((child) => {
            references.push(child);
        });
        const parsedPorts = this.cell.getParsedPorts();
        const portsGropsByZ = groupBy$1(parsedPorts, 'zIndex');
        const autoZIndexKey = 'auto';
        // render non-z first
        if (portsGropsByZ[autoZIndexKey]) {
            portsGropsByZ[autoZIndexKey].forEach((port) => {
                const portElement = this.getPortElement(port);
                container.append(portElement);
                references.push(portElement);
            });
        }
        Object.keys(portsGropsByZ).forEach((key) => {
            if (key !== autoZIndexKey) {
                const zIndex = parseInt(key, 10);
                this.appendPorts(portsGropsByZ[key], zIndex, references);
            }
        });
        this.updatePorts();
    }
    appendPorts(ports, zIndex, refs) {
        const elems = ports.map((p) => this.getPortElement(p));
        if (refs[zIndex] || zIndex < 0) {
            before(refs[Math.max(zIndex, 0)], elems);
        }
        else {
            append(this.container, elems);
        }
    }
    getPortElement(port) {
        const cached = this.portsCache[port.id];
        if (cached) {
            return cached.portElement;
        }
        return this.createPortElement(port);
    }
    createPortElement(port) {
        let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup());
        const portElement = renderResult.elem;
        if (portElement == null) {
            throw new Error('Invalid port container markup.');
        }
        renderResult = Markup.renderMarkup(this.getPortMarkup(port));
        const portContentElement = renderResult.elem;
        const portContentSelectors = renderResult.selectors;
        if (portContentElement == null) {
            throw new Error('Invalid port markup.');
        }
        this.setAttrs({
            port: port.id,
            'port-group': port.group,
        }, portContentElement);
        let portClass = 'x6-port';
        if (port.group) {
            portClass += ` x6-port-${port.group}`;
        }
        addClass(portElement, portClass);
        addClass(portElement, 'x6-port');
        addClass(portContentElement, 'x6-port-body');
        portElement.appendChild(portContentElement);
        let portSelectors = portContentSelectors;
        let portLabelElement;
        let portLabelSelectors;
        const existLabel = this.existPortLabel(port);
        if (existLabel) {
            renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));
            portLabelElement = renderResult.elem;
            portLabelSelectors = renderResult.selectors;
            if (portLabelElement == null) {
                throw new Error('Invalid port label markup.');
            }
            if (portContentSelectors && portLabelSelectors) {
                // eslint-disable-next-line
                for (const key in portLabelSelectors) {
                    if (portContentSelectors[key] && key !== this.rootSelector) {
                        throw new Error('Selectors within port must be unique.');
                    }
                }
                portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
            }
            addClass(portLabelElement, 'x6-port-label');
            portElement.appendChild(portLabelElement);
        }
        this.portsCache[port.id] = {
            portElement,
            portSelectors,
            portLabelElement,
            portLabelSelectors,
            portContentElement,
            portContentSelectors,
        };
        if (this.graph.options.onPortRendered) {
            this.graph.options.onPortRendered({
                port,
                node: this.cell,
                container: portElement,
                selectors: portSelectors,
                labelContainer: portLabelElement,
                labelSelectors: portLabelSelectors,
                contentContainer: portContentElement,
                contentSelectors: portContentSelectors,
            });
        }
        return portElement;
    }
    updatePorts() {
        const groups = this.cell.getParsedGroups();
        const groupList = Object.keys(groups);
        if (groupList.length === 0) {
            this.updatePortGroup();
        }
        else {
            groupList.forEach((groupName) => this.updatePortGroup(groupName));
        }
    }
    updatePortGroup(groupName) {
        const bbox = Rectangle.fromSize(this.cell.getSize());
        const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);
        for (let i = 0, n = metrics.length; i < n; i += 1) {
            const metric = metrics[i];
            const portId = metric.portId;
            const cached = this.portsCache[portId] || {};
            const portLayout = metric.portLayout;
            this.applyPortTransform(cached.portElement, portLayout);
            if (metric.portAttrs != null) {
                const options = {
                    selectors: cached.portSelectors || {},
                };
                if (metric.portSize) {
                    options.rootBBox = Rectangle.fromSize(metric.portSize);
                }
                this.updateAttrs(cached.portElement, metric.portAttrs, options);
            }
            const labelLayout = metric.labelLayout;
            if (labelLayout && cached.portLabelElement) {
                this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));
                if (labelLayout.attrs) {
                    const options = {
                        selectors: cached.portLabelSelectors || {},
                    };
                    if (metric.labelSize) {
                        options.rootBBox = Rectangle.fromSize(metric.labelSize);
                    }
                    this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
                }
            }
        }
    }
    applyPortTransform(element, layout, initialAngle = 0) {
        const angle = layout.angle;
        const position = layout.position;
        const matrix = createSVGMatrix()
            .rotate(initialAngle)
            .translate(position.x || 0, position.y || 0)
            .rotate(angle || 0);
        transform(element, matrix, { absolute: true });
    }
    getPortMarkup(port) {
        return port.markup || this.cell.portMarkup;
    }
    getPortLabelMarkup(label) {
        return label.markup || this.cell.portLabelMarkup;
    }
    existPortLabel(port) {
        return port.attrs && port.attrs.text;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const node = view.cell;
        const cell = node;
        if (x == null || y == null) {
            return { e, view, node, cell };
        }
        return { e, x, y, view, node, cell };
    }
    getPortEventArgs(e, port, pos) {
        const view = this; // eslint-disable-line
        const node = view.cell;
        const cell = node;
        if (pos) {
            return {
                e,
                x: pos.x,
                y: pos.y,
                view,
                node,
                cell,
                port,
            };
        }
        return { e, view, node, cell, port };
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('node:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('node:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        super.onMouseUp(e, x, y);
        this.notify('node:mouseup', this.getEventArgs(e, x, y));
    }
    notifyPortEvent(name, e, pos) {
        const port = this.findAttr('port', e.target);
        if (port) {
            const originType = e.type;
            if (name === 'node:port:mouseenter') {
                e.type = 'mouseenter';
            }
            else if (name === 'node:port:mouseleave') {
                e.type = 'mouseleave';
            }
            this.notify(name, this.getPortEventArgs(e, port, pos));
            e.type = originType;
        }
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('node:click', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:click', e, { x, y });
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('node:dblclick', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:dblclick', e, { x, y });
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('node:contextmenu', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:contextmenu', e, { x, y });
    }
    onMouseDown(e, x, y) {
        if (this.isPropagationStopped(e)) {
            return;
        }
        this.notifyMouseDown(e, x, y);
        this.notifyPortEvent('node:port:mousedown', e, { x, y });
        this.startNodeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.dragMagnet(e, x, y);
        }
        else {
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.dragNode(e, x, y);
                view.notify('node:moving', {
                    e,
                    x,
                    y,
                    view,
                    cell: view.cell,
                    node: view.cell,
                });
            }
            this.notifyMouseMove(e, x, y);
            this.notifyPortEvent('node:port:mousemove', e, { x, y });
        }
        this.setEventData(e, data);
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.stopMagnetDragging(e, x, y);
        }
        else {
            this.notifyMouseUp(e, x, y);
            this.notifyPortEvent('node:port:mouseup', e, { x, y });
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.stopNodeDragging(e, x, y);
            }
        }
        const magnet = data.targetMagnet;
        if (magnet) {
            this.onMagnetClick(e, magnet, x, y);
        }
        this.checkMouseleave(e);
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('node:mouseover', this.getEventArgs(e));
        // mock mouseenter event,so we can get correct trigger time when move mouse from node to port
        // wo also need to change e.type for use get correct event args
        this.notifyPortEvent('node:port:mouseenter', e);
        this.notifyPortEvent('node:port:mouseover', e);
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('node:mouseout', this.getEventArgs(e));
        // mock mouseleave event,so we can get correct trigger time when move mouse from port to node
        // wo also need to change e.type for use get correct event args
        this.notifyPortEvent('node:port:mouseleave', e);
        this.notifyPortEvent('node:port:mouseout', e);
    }
    onMouseEnter(e) {
        this.updateClassName(e);
        super.onMouseEnter(e);
        this.notify('node:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('node:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('node:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onMagnetClick(e, magnet, x, y) {
        const graph = this.graph;
        const count = graph.view.getMouseMovedCount(e);
        if (count > graph.options.clickThreshold) {
            return;
        }
        this.notify('node:magnet:click', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetDblClick(e, magnet, x, y) {
        this.notify('node:magnet:dblclick', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetContextMenu(e, magnet, x, y) {
        this.notify('node:magnet:contextmenu', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) {
        this.startMagnetDragging(e, x, y);
    }
    onCustomEvent(e, name, x, y) {
        this.notify('node:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        super.onCustomEvent(e, name, x, y);
    }
    prepareEmbedding(e) {
        const graph = this.graph;
        const data = this.getEventData(e);
        const node = data.cell || this.cell;
        const view = graph.findViewByCell(node);
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embed', {
            e,
            node,
            view,
            cell: node,
            x: localPoint.x,
            y: localPoint.y,
            currentParent: node.getParent(),
        });
    }
    processEmbedding(e, data) {
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const options = graph.options.embedding;
        const findParent = options.findParent;
        let candidates = typeof findParent === 'function'
            ? call$1(findParent, graph, {
                view: this,
                node: this.cell,
            }).filter((c) => {
                return (Cell.isCell(c) &&
                    this.cell.id !== c.id &&
                    !c.isDescendantOf(this.cell));
            })
            : graph.model.getNodesUnderNode(cell, {
                by: findParent,
            });
        // Picks the node with the highest `z` index
        if (options.frontOnly) {
            if (candidates.length > 0) {
                const zIndexMap = groupBy$1(candidates, 'zIndex');
                const maxZIndex = max(Object.keys(zIndexMap).map((z) => parseInt(z, 10)));
                if (maxZIndex) {
                    candidates = zIndexMap[maxZIndex];
                }
            }
        }
        // Filter the nodes which is invisiable
        candidates = candidates.filter((candidate) => candidate.visible);
        let newCandidateView = null;
        const prevCandidateView = data.candidateEmbedView;
        const validateEmbeding = options.validate;
        for (let i = candidates.length - 1; i >= 0; i -= 1) {
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
                // candidate remains the same
                newCandidateView = prevCandidateView;
                break;
            }
            else {
                const view = candidate.findView(graph);
                if (validateEmbeding &&
                    call$1(validateEmbeding, graph, {
                        child: this.cell,
                        parent: view.cell,
                        childView: this,
                        parentView: view,
                    })) {
                    // flip to the new candidate
                    newCandidateView = view;
                    break;
                }
            }
        }
        this.clearEmbedding(data);
        if (newCandidateView) {
            newCandidateView.highlight(null, { type: 'embedding' });
        }
        data.candidateEmbedView = newCandidateView;
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embedding', {
            e,
            cell,
            node: cell,
            view: graph.findViewByCell(cell),
            x: localPoint.x,
            y: localPoint.y,
            currentParent: cell.getParent(),
            candidateParent: newCandidateView ? newCandidateView.cell : null,
        });
    }
    clearEmbedding(data) {
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
        }
    }
    finalizeEmbedding(e, data) {
        this.graph.startBatch('embedding');
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const view = graph.findViewByCell(cell);
        const parent = cell.getParent();
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            // Candidate view is chosen to become the parent of the node.
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
            if (parent == null || parent.id !== candidateView.cell.id) {
                candidateView.cell.insertChild(cell, undefined, { ui: true });
            }
        }
        else if (parent) {
            parent.unembed(cell, { ui: true });
        }
        graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {
            edge.updateParent({ ui: true });
        });
        if (view && candidateView) {
            const localPoint = graph.snapToGrid(e.clientX, e.clientY);
            view.notify('node:embedded', {
                e,
                cell,
                x: localPoint.x,
                y: localPoint.y,
                node: cell,
                view: graph.findViewByCell(cell),
                previousParent: parent,
                currentParent: cell.getParent(),
            });
        }
        this.graph.stopBatch('embedding');
    }
    getDelegatedView() {
        let cell = this.cell;
        let view = this; // eslint-disable-line
        while (view) {
            if (cell.isEdge()) {
                break;
            }
            if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {
                return view;
            }
            cell = cell.getParent();
            view = this.graph.findViewByCell(cell);
        }
        return null;
    }
    validateMagnet(cellView, magnet, e) {
        if (magnet.getAttribute('magnet') !== 'passive') {
            const validate = this.graph.options.connecting.validateMagnet;
            if (validate) {
                return call$1(validate, this.graph, {
                    e,
                    magnet,
                    view: cellView,
                    cell: cellView.cell,
                });
            }
            return true;
        }
        return false;
    }
    startMagnetDragging(e, x, y) {
        if (!this.can('magnetConnectable')) {
            return;
        }
        e.stopPropagation();
        const magnet = e.currentTarget;
        const graph = this.graph;
        this.setEventData(e, {
            targetMagnet: magnet,
        });
        if (this.validateMagnet(this, magnet, e)) {
            if (graph.options.magnetThreshold <= 0) {
                this.startConnectting(e, magnet, x, y);
            }
            this.setEventData(e, {
                action: 'magnet',
            });
            this.stopPropagation(e);
        }
        else {
            this.onMouseDown(e, x, y);
        }
        graph.view.delegateDragEvents(e, this);
    }
    startConnectting(e, magnet, x, y) {
        this.graph.model.startBatch('add-edge');
        const edgeView = this.createEdgeFromMagnet(magnet, x, y);
        edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {
            x,
            y,
            isNewEdge: true,
            fallbackAction: 'remove',
        }));
        this.setEventData(e, { edgeView });
        edgeView.notifyMouseDown(e, x, y);
    }
    getDefaultEdge(sourceView, sourceMagnet) {
        let edge;
        const create = this.graph.options.connecting.createEdge;
        if (create) {
            edge = call$1(create, this.graph, {
                sourceMagnet,
                sourceView,
                sourceCell: sourceView.cell,
            });
        }
        return edge;
    }
    createEdgeFromMagnet(magnet, x, y) {
        const graph = this.graph;
        const model = graph.model;
        const edge = this.getDefaultEdge(this, magnet);
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));
        edge.addTo(model, { async: false, ui: true });
        return edge.findView(graph);
    }
    dragMagnet(e, x, y) {
        const data = this.getEventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseMove(e, x, y);
            this.autoScrollGraph(e.clientX, e.clientY);
        }
        else {
            const graph = this.graph;
            const magnetThreshold = graph.options.magnetThreshold;
            const currentTarget = this.getEventTarget(e);
            const targetMagnet = data.targetMagnet;
            // magnetThreshold when the pointer leaves the magnet
            if (magnetThreshold === 'onleave') {
                if (targetMagnet === currentTarget ||
                    targetMagnet.contains(currentTarget)) {
                    return;
                }
                // eslint-disable-next-line no-lonely-if
            }
            else {
                // magnetThreshold defined as a number of movements
                if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
                    return;
                }
            }
            this.startConnectting(e, targetMagnet, x, y);
        }
    }
    stopMagnetDragging(e, x, y) {
        const data = this.eventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseUp(e, x, y);
            this.graph.model.stopBatch('add-edge');
        }
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('node:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            node: this.cell,
        });
    }
    notifyNodeMove(name, e, x, y, cell) {
        let cells = [cell];
        const selection = this.graph.getPlugin('selection');
        if (selection && selection.isSelectionMovable()) {
            const selectedCells = selection.getSelectedCells();
            if (selectedCells.includes(cell)) {
                cells = selectedCells.filter((c) => c.isNode());
            }
        }
        cells.forEach((c) => {
            this.notify(name, {
                e,
                x,
                y,
                cell: c,
                node: c,
                view: c.findView(this.graph),
            });
        });
    }
    getRestrictArea(view) {
        const restrict = this.graph.options.translating.restrict;
        const area = typeof restrict === 'function'
            ? call$1(restrict, this.graph, view)
            : restrict;
        if (typeof area === 'number') {
            return this.graph.transform.getGraphArea().inflate(area);
        }
        if (area === true) {
            return this.graph.transform.getGraphArea();
        }
        return area || null;
    }
    startNodeDragging(e, x, y) {
        const targetView = this.getDelegatedView();
        if (targetView == null || !targetView.can('nodeMovable')) {
            return this.notifyUnhandledMouseDown(e, x, y);
        }
        this.setEventData(e, {
            targetView,
            action: 'move',
        });
        const position = Point.create(targetView.cell.getPosition());
        targetView.setEventData(e, {
            moving: false,
            offset: position.diff(x, y),
            restrict: this.getRestrictArea(targetView),
        });
    }
    dragNode(e, x, y) {
        const node = this.cell;
        const graph = this.graph;
        const gridSize = graph.getGridSize();
        const data = this.getEventData(e);
        const offset = data.offset;
        const restrict = data.restrict;
        if (!data.moving) {
            data.moving = true;
            this.addClass('node-moving');
            this.notifyNodeMove('node:move', e, x, y, this.cell);
        }
        this.autoScrollGraph(e.clientX, e.clientY);
        const posX = GeometryUtil.snapToGrid(x + offset.x, gridSize);
        const posY = GeometryUtil.snapToGrid(y + offset.y, gridSize);
        node.setPosition(posX, posY, {
            restrict,
            deep: true,
            ui: true,
        });
        if (graph.options.embedding.enabled) {
            if (!data.embedding) {
                this.prepareEmbedding(e);
                data.embedding = true;
            }
            this.processEmbedding(e, data);
        }
    }
    stopNodeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.embedding) {
            this.finalizeEmbedding(e, data);
        }
        if (data.moving) {
            this.removeClass('node-moving');
            this.notifyNodeMove('node:moved', e, x, y, this.cell);
        }
        data.moving = false;
        data.embedding = false;
    }
    // eslint-disable-next-line
    autoScrollGraph(x, y) {
        const scroller = this.graph.getPlugin('scroller');
        if (scroller) {
            scroller.autoScroll(x, y);
        }
    }
}
(function (NodeView) {
    NodeView.toStringTag = `X6.${NodeView.name}`;
    function isNodeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof NodeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === NodeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.findPortElem === 'function' &&
            typeof view.resize === 'function' &&
            typeof view.rotate === 'function' &&
            typeof view.translate === 'function') {
            return true;
        }
        return false;
    }
    NodeView.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));
NodeView.config({
    isSvgElement: true,
    priority: 0,
    bootstrap: ['render'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        size: ['resize', 'ports', 'tools'],
        angle: ['rotate', 'tools'],
        position: ['translate', 'tools'],
        ports: ['ports'],
        tools: ['tools'],
    },
});
NodeView.registry.register('node', NodeView, true);

var __rest$4 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class EdgeView extends CellView {
    constructor() {
        super(...arguments);
        this.POINT_ROUNDING = 2;
        this.labelDestroyFn = {};
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return EdgeView.toStringTag;
    }
    getContainerClassName() {
        return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');
    }
    get sourceBBox() {
        const sourceView = this.sourceView;
        if (!sourceView) {
            const sourceDef = this.cell.getSource();
            return new Rectangle(sourceDef.x, sourceDef.y);
        }
        const sourceMagnet = this.sourceMagnet;
        if (sourceView.isEdgeElement(sourceMagnet)) {
            return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
        }
        return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
    }
    get targetBBox() {
        const targetView = this.targetView;
        if (!targetView) {
            const targetDef = this.cell.getTarget();
            return new Rectangle(targetDef.x, targetDef.y);
        }
        const targetMagnet = this.targetMagnet;
        if (targetView.isEdgeElement(targetMagnet)) {
            return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);
        }
        return targetView.getBBoxOfElement(targetMagnet || targetView.container);
    }
    isEdgeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ref = flag;
        if (this.hasAction(ref, 'source')) {
            if (!this.updateTerminalProperties('source')) {
                return ref;
            }
            ref = this.removeAction(ref, 'source');
        }
        if (this.hasAction(ref, 'target')) {
            if (!this.updateTerminalProperties('target')) {
                return ref;
            }
            ref = this.removeAction(ref, 'target');
        }
        if (this.hasAction(ref, 'render')) {
            this.render();
            ref = this.removeAction(ref, ['render', 'update', 'labels', 'tools']);
            return ref;
        }
        ref = this.handleAction(ref, 'update', () => this.update(options));
        ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));
        ref = this.handleAction(ref, 'tools', () => this.renderTools());
        return ref;
    }
    // #region render
    render() {
        this.empty();
        this.renderMarkup();
        this.labelContainer = null;
        this.renderLabels();
        this.update();
        this.renderTools();
        return this;
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                throw new TypeError('Not support string markup.');
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid edge markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        this.selectors = ret.selectors;
        this.container.append(ret.fragment);
    }
    customizeLabels() {
        if (this.labelContainer) {
            const edge = this.cell;
            const labels = edge.labels;
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const label = labels[i];
                const container = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered;
                if (onEdgeLabelRendered) {
                    const fn = onEdgeLabelRendered({
                        edge,
                        label,
                        container,
                        selectors,
                    });
                    if (fn) {
                        this.labelDestroyFn[i] = fn;
                    }
                }
            }
        }
    }
    destroyCustomizeLabels() {
        const labels = this.cell.labels;
        if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const fn = this.labelDestroyFn[i];
                const container = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                if (fn && container && selectors) {
                    fn({
                        edge: this.cell,
                        label: labels[i],
                        container,
                        selectors,
                    });
                }
            }
        }
        this.labelDestroyFn = {};
    }
    renderLabels() {
        const edge = this.cell;
        const labels = edge.getLabels();
        const count = labels.length;
        let container = this.labelContainer;
        this.labelCache = {};
        this.labelSelectors = {};
        if (count <= 0) {
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            }
            return this;
        }
        if (container) {
            this.empty(container);
        }
        else {
            container = createSvgElement('g');
            this.addClass(this.prefixClassName('edge-labels'), container);
            this.labelContainer = container;
        }
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
            let labelNode;
            let selectors;
            if (normalized) {
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            else {
                const defaultLabel = edge.getDefaultLabel();
                const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            labelNode.setAttribute('data-index', `${i}`);
            container.appendChild(labelNode);
            const rootSelector = this.rootSelector;
            if (selectors[rootSelector]) {
                throw new Error('Ambiguous label root selector.');
            }
            selectors[rootSelector] = labelNode;
            this.labelCache[i] = labelNode;
            this.labelSelectors[i] = selectors;
        }
        if (container.parentNode == null) {
            this.container.appendChild(container);
        }
        this.updateLabels();
        this.customizeLabels();
        return this;
    }
    onLabelsChange(options = {}) {
        this.destroyCustomizeLabels();
        if (this.shouldRerenderLabels(options)) {
            this.renderLabels();
        }
        else {
            this.updateLabels();
        }
        this.updateLabelPositions();
    }
    shouldRerenderLabels(options = {}) {
        const previousLabels = this.cell.previous('labels');
        if (previousLabels == null) {
            return true;
        }
        // Here is an optimization for cases when we know, that change does
        // not require re-rendering of all labels.
        if ('propertyPathArray' in options && 'propertyValue' in options) {
            // The label is setting by `prop()` method
            const pathArray = options.propertyPathArray || [];
            const pathLength = pathArray.length;
            if (pathLength > 1) {
                // We are changing a single label here e.g. 'labels/0/position'
                const index = pathArray[1];
                if (previousLabels[index]) {
                    if (pathLength === 2) {
                        // We are changing the entire label. Need to check if the
                        // markup is also being changed.
                        return (typeof options.propertyValue === 'object' &&
                            has(options.propertyValue, 'markup'));
                    }
                    // We are changing a label property but not the markup
                    if (pathArray[2] !== 'markup') {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    parseLabelMarkup(markup) {
        if (markup) {
            if (typeof markup === 'string') {
                return this.parseLabelStringMarkup(markup);
            }
            return this.parseJSONMarkup(markup);
        }
        return null;
    }
    parseLabelStringMarkup(labelMarkup) {
        const children = Vector.createVectors(labelMarkup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    normalizeLabelMarkup(markup) {
        if (markup == null) {
            return;
        }
        const fragment = markup.fragment;
        if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
            throw new Error('Invalid label markup.');
        }
        let vel;
        const childNodes = fragment.childNodes;
        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
            vel = Vector.create('g').append(fragment);
        }
        else {
            vel = Vector.create(childNodes[0]);
        }
        vel.addClass(this.prefixClassName('edge-label'));
        return {
            node: vel.node,
            selectors: markup.selectors,
        };
    }
    updateLabels() {
        if (this.labelContainer) {
            const edge = this.cell;
            const labels = edge.labels;
            const canLabelMove = this.can('edgeLabelMovable');
            const defaultLabel = edge.getDefaultLabel();
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const elem = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');
                const label = labels[i];
                const attrs = merge$1({}, defaultLabel.attrs, label.attrs);
                this.updateAttrs(elem, attrs, {
                    selectors,
                    rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,
                });
            }
        }
    }
    renderTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    // #endregion
    // #region updating
    update(options = {}) {
        this.cleanCache();
        this.updateConnection(options);
        const _a = this.cell.getAttrs(), attrs = __rest$4(_a, ["text"]);
        if (attrs != null) {
            this.updateAttrs(this.container, attrs, {
                selectors: this.selectors,
            });
        }
        this.updateLabelPositions();
        this.updateTools(options);
        return this;
    }
    removeRedundantLinearVertices(options = {}) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
        const rawCount = routePoints.length;
        // Puts the route points into a polyline and try to simplify.
        const polyline = new Polyline(routePoints);
        polyline.simplify({ threshold: 0.01 });
        const simplifiedPoints = polyline.points.map((point) => point.toJSON());
        const simplifiedCount = simplifiedPoints.length;
        // If simplification did not remove any redundant vertices.
        if (rawCount === simplifiedCount) {
            return 0;
        }
        // Sets simplified polyline points as edge vertices.
        // Removes first and last polyline points again (source/target anchors).
        edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
        return rawCount - simplifiedCount;
    }
    getTerminalView(type) {
        switch (type) {
            case 'source':
                return this.sourceView || null;
            case 'target':
                return this.targetView || null;
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalAnchor(type) {
        switch (type) {
            case 'source':
                return Point.create(this.sourceAnchor);
            case 'target':
                return Point.create(this.targetAnchor);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalConnectionPoint(type) {
        switch (type) {
            case 'source':
                return Point.create(this.sourcePoint);
            case 'target':
                return Point.create(this.targetPoint);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalMagnet(type, options = {}) {
        switch (type) {
            case 'source': {
                if (options.raw) {
                    return this.sourceMagnet;
                }
                const sourceView = this.sourceView;
                if (!sourceView) {
                    return null;
                }
                return this.sourceMagnet || sourceView.container;
            }
            case 'target': {
                if (options.raw) {
                    return this.targetMagnet;
                }
                const targetView = this.targetView;
                if (!targetView) {
                    return null;
                }
                return this.targetMagnet || targetView.container;
            }
            default: {
                throw new Error(`Unknown terminal type '${type}'`);
            }
        }
    }
    updateConnection(options = {}) {
        const edge = this.cell;
        // The edge is being translated by an ancestor that will shift
        // source, target and vertices by an equal distance.
        // todo isFragmentDescendantOf is invalid
        if (options.translateBy &&
            edge.isFragmentDescendantOf(options.translateBy)) {
            const tx = options.tx || 0;
            const ty = options.ty || 0;
            this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;
            this.translateConnectionPoints(tx, ty);
            this.path.translate(tx, ty);
        }
        else {
            const vertices = edge.getVertices();
            // 1. Find anchor points
            const anchors = this.findAnchors(vertices);
            this.sourceAnchor = anchors.source;
            this.targetAnchor = anchors.target;
            // 2. Find route points
            this.routePoints = this.findRoutePoints(vertices);
            // 3. Find connection points
            const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
            this.sourcePoint = connectionPoints.source;
            this.targetPoint = connectionPoints.target;
            // 4. Find Marker Connection Point
            const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
            // 5. Make path
            this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
        }
        this.cleanCache();
    }
    findAnchors(vertices) {
        const edge = this.cell;
        const source = edge.source;
        const target = edge.target;
        const firstVertex = vertices[0];
        const lastVertex = vertices[vertices.length - 1];
        if (target.priority && !source.priority) {
            // Reversed order
            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
        }
        // Usual order
        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
    }
    findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
        let firstAnchor;
        let secondAnchor;
        const edge = this.cell;
        const firstTerminal = edge[firstType];
        const secondTerminal = edge[secondType];
        const firstView = this.getTerminalView(firstType);
        const secondView = this.getTerminalView(secondType);
        const firstMagnet = this.getTerminalMagnet(firstType);
        const secondMagnet = this.getTerminalMagnet(secondType);
        if (firstView) {
            let firstRef;
            if (firstPoint) {
                firstRef = Point.create(firstPoint);
            }
            else if (secondView) {
                firstRef = secondMagnet;
            }
            else {
                firstRef = Point.create(secondTerminal);
            }
            firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
        }
        else {
            firstAnchor = Point.create(firstTerminal);
        }
        if (secondView) {
            const secondRef = Point.create(secondPoint || firstAnchor);
            secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
        }
        else {
            secondAnchor = Point.isPointLike(secondTerminal)
                ? Point.create(secondTerminal)
                : new Point();
        }
        return {
            [firstType]: firstAnchor,
            [secondType]: secondAnchor,
        };
    }
    getAnchor(def, cellView, magnet, ref, terminalType) {
        const isEdge = cellView.isEdgeElement(magnet);
        const connecting = this.graph.options.connecting;
        let config = typeof def === 'string' ? { name: def } : def;
        if (!config) {
            const defaults = isEdge
                ? (terminalType === 'source'
                    ? connecting.sourceEdgeAnchor
                    : connecting.targetEdgeAnchor) || connecting.edgeAnchor
                : (terminalType === 'source'
                    ? connecting.sourceAnchor
                    : connecting.targetAnchor) || connecting.anchor;
            config = typeof defaults === 'string' ? { name: defaults } : defaults;
        }
        if (!config) {
            throw new Error(`Anchor should be specified.`);
        }
        let anchor;
        const name = config.name;
        if (isEdge) {
            const fn = EdgeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return EdgeAnchor.registry.onNotFound(name);
            }
            anchor = call$1(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        else {
            const fn = NodeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return NodeAnchor.registry.onNotFound(name);
            }
            anchor = call$1(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();
    }
    findRoutePoints(vertices = []) {
        const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;
        const router = this.cell.getRouter() || defaultRouter;
        let routePoints;
        if (typeof router === 'function') {
            routePoints = call$1(router, this, vertices, {}, this);
        }
        else {
            const name = typeof router === 'string' ? router : router.name;
            const args = typeof router === 'string' ? {} : router.args || {};
            const fn = name ? Router.registry.get(name) : Router.presets.normal;
            if (typeof fn !== 'function') {
                return Router.registry.onNotFound(name);
            }
            routePoints = call$1(fn, this, vertices, args, this);
        }
        return routePoints == null
            ? vertices.map((p) => Point.create(p))
            : routePoints.map((p) => Point.create(p));
    }
    findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
        const edge = this.cell;
        const connecting = this.graph.options.connecting;
        const sourceTerminal = edge.getSource();
        const targetTerminal = edge.getTarget();
        const sourceView = this.sourceView;
        const targetView = this.targetView;
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        // source
        let sourcePoint;
        if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
            const sourceMagnet = this.sourceMagnet || sourceView.container;
            const sourcePointRef = firstRoutePoint || targetAnchor;
            const sourceLine = new Line(sourcePointRef, sourceAnchor);
            const connectionPointDef = sourceTerminal.connectionPoint ||
                connecting.sourceConnectionPoint ||
                connecting.connectionPoint;
            sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
        }
        else {
            sourcePoint = sourceAnchor;
        }
        // target
        let targetPoint;
        if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
            const targetMagnet = this.targetMagnet || targetView.container;
            const targetConnectionPointDef = targetTerminal.connectionPoint ||
                connecting.targetConnectionPoint ||
                connecting.connectionPoint;
            const targetPointRef = lastRoutePoint || sourceAnchor;
            const targetLine = new Line(targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
        }
        else {
            targetPoint = targetAnchor;
        }
        return {
            source: sourcePoint,
            target: targetPoint,
        };
    }
    getConnectionPoint(def, view, magnet, line, endType) {
        const anchor = line.end;
        if (def == null) {
            return anchor;
        }
        const name = typeof def === 'string' ? def : def.name;
        const args = typeof def === 'string' ? {} : def.args;
        const fn = ConnectionPoint.registry.get(name);
        if (typeof fn !== 'function') {
            return ConnectionPoint.registry.onNotFound(name);
        }
        const connectionPoint = call$1(fn, this, line, view, magnet, args || {}, endType);
        return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;
    }
    findMarkerPoints(routePoints, sourcePoint, targetPoint) {
        const getLineWidth = (type) => {
            const attrs = this.cell.getAttrs();
            const keys = Object.keys(attrs);
            for (let i = 0, l = keys.length; i < l; i += 1) {
                const attr = attrs[keys[i]];
                if (attr[`${type}Marker`] || attr[`${type}-marker`]) {
                    const strokeWidth = attr.strokeWidth || attr['stroke-width'];
                    if (strokeWidth) {
                        return parseFloat(strokeWidth);
                    }
                    break;
                }
            }
            return null;
        };
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        let sourceMarkerPoint;
        let targetMarkerPoint;
        const sourceStrokeWidth = getLineWidth('source');
        if (sourceStrokeWidth) {
            sourceMarkerPoint = sourcePoint
                .clone()
                .move(firstRoutePoint || targetPoint, -sourceStrokeWidth);
        }
        const targetStrokeWidth = getLineWidth('target');
        if (targetStrokeWidth) {
            targetMarkerPoint = targetPoint
                .clone()
                .move(lastRoutePoint || sourcePoint, -targetStrokeWidth);
        }
        this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone();
        this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone();
        return {
            source: sourceMarkerPoint,
            target: targetMarkerPoint,
        };
    }
    findPath(routePoints, sourcePoint, targetPoint) {
        const def = this.cell.getConnector() || this.graph.options.connecting.connector;
        let name;
        let args;
        let fn;
        if (typeof def === 'string') {
            name = def;
        }
        else {
            name = def.name;
            args = def.args;
        }
        if (name) {
            const method = Connector.registry.get(name);
            if (typeof method !== 'function') {
                return Connector.registry.onNotFound(name);
            }
            fn = method;
        }
        else {
            fn = Connector.presets.normal;
        }
        const path = call$1(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);
        return typeof path === 'string' ? Path$1.parse(path) : path;
    }
    translateConnectionPoints(tx, ty) {
        this.sourcePoint.translate(tx, ty);
        this.targetPoint.translate(tx, ty);
        this.sourceAnchor.translate(tx, ty);
        this.targetAnchor.translate(tx, ty);
        this.sourceMarkerPoint.translate(tx, ty);
        this.targetMarkerPoint.translate(tx, ty);
    }
    updateLabelPositions() {
        if (this.labelContainer == null) {
            return this;
        }
        const path = this.path;
        if (!path) {
            return this;
        }
        const edge = this.cell;
        const labels = edge.getLabels();
        if (labels.length === 0) {
            return this;
        }
        const defaultLabel = edge.getDefaultLabel();
        const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const labelNode = this.labelCache[i];
            if (!labelNode) {
                continue;
            }
            const labelPosition = this.normalizeLabelPosition(label.position);
            const pos = merge$1({}, defaultPosition, labelPosition);
            const matrix = this.getLabelTransformationMatrix(pos);
            labelNode.setAttribute('transform', matrixToTransformString(matrix));
        }
        return this;
    }
    updateTerminalProperties(type) {
        const edge = this.cell;
        const graph = this.graph;
        const terminal = edge[type];
        const nodeId = terminal && terminal.cell;
        const viewKey = `${type}View`;
        // terminal is a point
        if (!nodeId) {
            this[viewKey] = null;
            this.updateTerminalMagnet(type);
            return true;
        }
        const terminalCell = graph.getCellById(nodeId);
        if (!terminalCell) {
            throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
        }
        const endView = terminalCell.findView(graph);
        if (!endView) {
            return false;
        }
        this[viewKey] = endView;
        this.updateTerminalMagnet(type);
        return true;
    }
    updateTerminalMagnet(type) {
        const propName = `${type}Magnet`;
        const terminalView = this.getTerminalView(type);
        if (terminalView) {
            let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);
            if (magnet === terminalView.container) {
                magnet = null;
            }
            this[propName] = magnet;
        }
        else {
            this[propName] = null;
        }
    }
    getLabelPositionAngle(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.angle || 0;
        }
        return 0;
    }
    getLabelPositionArgs(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.options;
        }
    }
    getDefaultLabelPositionArgs() {
        const defaultLabel = this.cell.getDefaultLabel();
        if (defaultLabel &&
            defaultLabel.position &&
            typeof defaultLabel.position === 'object') {
            return defaultLabel.position.options;
        }
    }
    mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
        if (labelPositionArgs === null) {
            return null;
        }
        if (labelPositionArgs === undefined) {
            if (defaultLabelPositionArgs === null) {
                return null;
            }
            return defaultLabelPositionArgs;
        }
        return merge$1({}, defaultLabelPositionArgs, labelPositionArgs);
    }
    // #endregion
    getConnection() {
        return this.path != null ? this.path.clone() : null;
    }
    getConnectionPathData() {
        if (this.path == null) {
            return '';
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'data')) {
            cache.data = this.path.serialize();
        }
        return cache.data || '';
    }
    getConnectionSubdivisions() {
        if (this.path == null) {
            return null;
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'segmentSubdivisions')) {
            cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
        }
        return cache.segmentSubdivisions;
    }
    getConnectionLength() {
        if (this.path == null) {
            return 0;
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'length')) {
            cache.length = this.path.length({
                segmentSubdivisions: this.getConnectionSubdivisions(),
            });
        }
        return cache.length;
    }
    getPointAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.pointAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getPointAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        if (isPercentage(ratio)) {
            // eslint-disable-next-line
            ratio = parseFloat(ratio) / 100;
        }
        return this.path.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPoint(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPoint(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointLength(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointRatio(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointNormalizedLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getLabelPosition(x, y, p3, p4) {
        const pos = { distance: 0 };
        // normalize data from the two possible signatures
        let angle = 0;
        let options;
        if (typeof p3 === 'number') {
            angle = p3;
            options = p4;
        }
        else {
            options = p3;
        }
        if (options != null) {
            pos.options = options;
        }
        // identify distance/offset settings
        const isOffsetAbsolute = options && options.absoluteOffset;
        const isDistanceRelative = !(options && options.absoluteDistance);
        const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;
        // find closest point t
        const path = this.path;
        const pathOptions = {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        };
        const labelPoint = new Point(x, y);
        const t = path.closestPointT(labelPoint, pathOptions);
        // distance
        const totalLength = this.getConnectionLength() || 0;
        let labelDistance = path.lengthAtT(t, pathOptions);
        if (isDistanceRelative) {
            labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
        }
        if (isDistanceAbsoluteReverse) {
            // fix for end point (-0 => 1)
            labelDistance = -1 * (totalLength - labelDistance) || 1;
        }
        pos.distance = labelDistance;
        // offset
        // use absolute offset if:
        // - options.absoluteOffset is true,
        // - options.absoluteOffset is not true but there is no tangent
        let tangent;
        if (!isOffsetAbsolute)
            tangent = path.tangentAtT(t);
        let labelOffset;
        if (tangent) {
            labelOffset = tangent.pointOffset(labelPoint);
        }
        else {
            const closestPoint = path.pointAtT(t);
            const labelOffsetDiff = labelPoint.diff(closestPoint);
            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };
        }
        pos.offset = labelOffset;
        pos.angle = angle;
        return pos;
    }
    normalizeLabelPosition(pos) {
        if (typeof pos === 'number') {
            return { distance: pos };
        }
        return pos;
    }
    getLabelTransformationMatrix(labelPosition) {
        const pos = this.normalizeLabelPosition(labelPosition);
        const options = pos.options || {};
        const labelAngle = pos.angle || 0;
        const labelDistance = pos.distance;
        const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
        let labelOffset = 0;
        const offsetCoord = { x: 0, y: 0 };
        const offset = pos.offset;
        if (offset) {
            if (typeof offset === 'number') {
                labelOffset = offset;
            }
            else {
                if (offset.x != null) {
                    offsetCoord.x = offset.x;
                }
                if (offset.y != null) {
                    offsetCoord.y = offset.y;
                }
            }
        }
        const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
        const isKeepGradient = options.keepGradient;
        const isEnsureLegibility = options.ensureLegibility;
        const path = this.path;
        const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };
        const distance = isDistanceRelative
            ? labelDistance * this.getConnectionLength()
            : labelDistance;
        const tangent = path.tangentAtLength(distance, pathOpt);
        let translation;
        let angle = labelAngle;
        if (tangent) {
            if (isOffsetAbsolute) {
                translation = tangent.start;
                translation.translate(offsetCoord);
            }
            else {
                const normal = tangent.clone();
                normal.rotate(-90, tangent.start);
                normal.setLength(labelOffset);
                translation = normal.end;
            }
            if (isKeepGradient) {
                angle = tangent.angle() + labelAngle;
                if (isEnsureLegibility) {
                    angle = Angle.normalize(((angle + 90) % 180) - 90);
                }
            }
        }
        else {
            // fallback - the connection has zero length
            translation = path.start;
            if (isOffsetAbsolute) {
                translation.translate(offsetCoord);
            }
        }
        return createSVGMatrix()
            .translate(translation.x, translation.y)
            .rotate(angle);
    }
    getVertexIndex(x, y) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const vertexLength = this.getClosestPointLength(new Point(x, y));
        let index = 0;
        if (vertexLength != null) {
            for (const ii = vertices.length; index < ii; index += 1) {
                const currentVertex = vertices[index];
                const currentLength = this.getClosestPointLength(currentVertex);
                if (currentLength != null && vertexLength < currentLength) {
                    break;
                }
            }
        }
        return index;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const edge = view.cell;
        const cell = edge;
        if (x == null || y == null) {
            return { e, view, edge, cell };
        }
        return { e, x, y, view, edge, cell };
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('edge:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('edge:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('edge:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        super.onMouseUp(e, x, y);
        this.notify('edge:mouseup', this.getEventArgs(e, x, y));
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('edge:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('edge:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('edge:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        this.startEdgeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-label': {
                this.dragLabel(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.dragArrowhead(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.dragEdge(e, x, y);
                break;
            }
        }
        this.notifyMouseMove(e, x, y);
        return data;
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-label': {
                this.stopLabelDragging(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.stopArrowheadDragging(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.stopEdgeDragging(e, x, y);
                break;
            }
        }
        this.notifyMouseUp(e, x, y);
        this.checkMouseleave(e);
        return data;
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('edge:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('edge:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        super.onMouseEnter(e);
        this.notify('edge:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('edge:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('edge:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        // For default edge tool
        const tool = findParentByClass(e.target, 'edge-tool', this.container);
        if (tool) {
            e.stopPropagation(); // no further action to be executed
            if (this.can('useEdgeTools')) {
                if (name === 'edge:remove') {
                    this.cell.remove({ ui: true });
                    return;
                }
                this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            }
            this.notifyMouseDown(e, x, y);
        }
        else {
            this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            super.onCustomEvent(e, name, x, y);
        }
    }
    onLabelMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        this.startLabelDragging(e, x, y);
        const stopPropagation = this.getEventData(e).stopPropagation;
        if (stopPropagation) {
            e.stopPropagation();
        }
    }
    // #region drag edge
    startEdgeDragging(e, x, y) {
        if (!this.can('edgeMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        this.setEventData(e, {
            x,
            y,
            moving: false,
            action: 'drag-edge',
        });
    }
    dragEdge(e, x, y) {
        const data = this.getEventData(e);
        if (!data.moving) {
            data.moving = true;
            this.addClass('edge-moving');
            this.notify('edge:move', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        this.cell.translate(x - data.x, y - data.y, { ui: true });
        this.setEventData(e, { x, y });
        this.notify('edge:moving', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    stopEdgeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.moving) {
            this.removeClass('edge-moving');
            this.notify('edge:moved', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        data.moving = false;
    }
    // #endregion
    // #region drag arrowhead
    prepareArrowheadDragging(type, options) {
        const magnet = this.getTerminalMagnet(type);
        const data = {
            action: 'drag-arrowhead',
            x: options.x,
            y: options.y,
            isNewEdge: options.isNewEdge === true,
            terminalType: type,
            initialMagnet: magnet,
            initialTerminal: clone(this.cell[type]),
            fallbackAction: options.fallbackAction || 'revert',
            getValidateConnectionArgs: this.createValidateConnectionArgs(type),
            options: options.options,
        };
        this.beforeArrowheadDragging(data);
        return data;
    }
    createValidateConnectionArgs(type) {
        const args = [];
        args[4] = type;
        args[5] = this;
        let opposite;
        let i = 0;
        let j = 0;
        if (type === 'source') {
            i = 2;
            opposite = 'target';
        }
        else {
            j = 2;
            opposite = 'source';
        }
        const terminal = this.cell[opposite];
        const cellId = terminal.cell;
        if (cellId) {
            let magnet;
            const view = (args[i] = this.graph.findViewByCell(cellId));
            if (view) {
                magnet = view.getMagnetFromEdgeTerminal(terminal);
                if (magnet === view.container) {
                    magnet = undefined;
                }
            }
            args[i + 1] = magnet;
        }
        return (cellView, magnet) => {
            args[j] = cellView;
            args[j + 1] = cellView.container === magnet ? undefined : magnet;
            return args;
        };
    }
    beforeArrowheadDragging(data) {
        data.zIndex = this.cell.zIndex;
        this.cell.toFront();
        const style = this.container.style;
        data.pointerEvents = style.pointerEvents;
        style.pointerEvents = 'none';
        if (this.graph.options.connecting.highlight) {
            this.highlightAvailableMagnets(data);
        }
    }
    afterArrowheadDragging(data) {
        if (data.zIndex != null) {
            this.cell.setZIndex(data.zIndex, { ui: true });
            data.zIndex = null;
        }
        const container = this.container;
        container.style.pointerEvents = data.pointerEvents || '';
        if (this.graph.options.connecting.highlight) {
            this.unhighlightAvailableMagnets(data);
        }
    }
    validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
        const options = this.graph.options.connecting;
        const allowLoop = options.allowLoop;
        const allowNode = options.allowNode;
        const allowEdge = options.allowEdge;
        const allowPort = options.allowPort;
        const allowMulti = options.allowMulti;
        const validate = options.validateConnection;
        const edge = edgeView ? edgeView.cell : null;
        const terminalView = terminalType === 'target' ? targetView : sourceView;
        const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;
        let valid = true;
        const doValidate = (validate) => {
            const sourcePort = terminalType === 'source'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getSourcePortId()
                    : null;
            const targetPort = terminalType === 'target'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getTargetPortId()
                    : null;
            return call$1(validate, this.graph, {
                edge,
                edgeView,
                sourceView,
                targetView,
                sourcePort,
                targetPort,
                sourceMagnet,
                targetMagnet,
                sourceCell: sourceView ? sourceView.cell : null,
                targetCell: targetView ? targetView.cell : null,
                type: terminalType,
            });
        };
        if (allowLoop != null) {
            if (typeof allowLoop === 'boolean') {
                if (!allowLoop && sourceView === targetView) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowLoop);
            }
        }
        if (valid && allowPort != null) {
            if (typeof allowPort === 'boolean') {
                if (!allowPort && terminalMagnet) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowPort);
            }
        }
        if (valid && allowEdge != null) {
            if (typeof allowEdge === 'boolean') {
                if (!allowEdge && EdgeView.isEdgeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowEdge);
            }
        }
        // When judging nodes, the influence of the ports should be excluded,
        // because the ports and nodes have the same terminalView
        if (valid && allowNode != null && terminalMagnet == null) {
            if (typeof allowNode === 'boolean') {
                if (!allowNode && NodeView.isNodeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowNode);
            }
        }
        if (valid && allowMulti != null && edgeView) {
            const edge = edgeView.cell;
            const source = terminalType === 'source'
                ? candidateTerminal
                : edge.getSource();
            const target = terminalType === 'target'
                ? candidateTerminal
                : edge.getTarget();
            const terminalCell = candidateTerminal
                ? this.graph.getCellById(candidateTerminal.cell)
                : null;
            if (source && target && source.cell && target.cell && terminalCell) {
                if (typeof allowMulti === 'function') {
                    valid = doValidate(allowMulti);
                }
                else {
                    const connectedEdges = this.graph.model.getConnectedEdges(terminalCell, {
                        outgoing: terminalType === 'source',
                        incoming: terminalType === 'target',
                    });
                    if (connectedEdges.length) {
                        if (allowMulti === 'withPort') {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s &&
                                    t &&
                                    s.cell === source.cell &&
                                    t.cell === target.cell &&
                                    s.port != null &&
                                    s.port === source.port &&
                                    t.port != null &&
                                    t.port === target.port);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                        else if (!allowMulti) {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s && t && s.cell === source.cell && t.cell === target.cell);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                    }
                }
            }
        }
        if (valid && validate != null) {
            valid = doValidate(validate);
        }
        return valid;
    }
    allowConnectToBlank(edge) {
        const graph = this.graph;
        const options = graph.options.connecting;
        const allowBlank = options.allowBlank;
        if (typeof allowBlank !== 'function') {
            return !!allowBlank;
        }
        const edgeView = graph.findViewByCell(edge);
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();
        const sourceView = graph.findViewByCell(sourceCell);
        const targetView = graph.findViewByCell(targetCell);
        return call$1(allowBlank, graph, {
            edge,
            edgeView,
            sourceCell,
            targetCell,
            sourceView,
            targetView,
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
            sourceMagnet: edgeView.sourceMagnet,
            targetMagnet: edgeView.targetMagnet,
        });
    }
    validateEdge(edge, type, initialTerminal) {
        const graph = this.graph;
        if (!this.allowConnectToBlank(edge)) {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (!(sourceId && targetId)) {
                return false;
            }
        }
        const validate = graph.options.connecting.validateEdge;
        if (validate) {
            return call$1(validate, graph, {
                edge,
                type,
                previous: initialTerminal,
            });
        }
        return true;
    }
    arrowheadDragging(target, x, y, data) {
        data.x = x;
        data.y = y;
        // Checking views right under the pointer
        if (data.currentTarget !== target) {
            // Unhighlight the previous view under pointer if there was one.
            if (data.currentMagnet && data.currentView) {
                data.currentView.unhighlight(data.currentMagnet, {
                    type: 'magnetAdsorbed',
                });
            }
            data.currentView = this.graph.findViewByElem(target);
            if (data.currentView) {
                // If we found a view that is under the pointer, we need to find
                // the closest magnet based on the real target element of the event.
                data.currentMagnet = data.currentView.findMagnet(target);
                if (data.currentMagnet &&
                    this.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {
                    data.currentView.highlight(data.currentMagnet, {
                        type: 'magnetAdsorbed',
                    });
                }
                else {
                    // This type of connection is not valid. Disregard this magnet.
                    data.currentMagnet = null;
                }
            }
            else {
                // Make sure we'll unset previous magnet.
                data.currentMagnet = null;
            }
        }
        data.currentTarget = target;
        this.cell.prop(data.terminalType, { x, y }, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    arrowheadDragged(data, x, y) {
        const view = data.currentView;
        const magnet = data.currentMagnet;
        if (!magnet || !view) {
            return;
        }
        view.unhighlight(magnet, { type: 'magnetAdsorbed' });
        const type = data.terminalType;
        const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
        this.cell.setTerminal(type, terminal, { ui: true });
    }
    snapArrowhead(x, y, data) {
        const graph = this.graph;
        const { snap, allowEdge } = graph.options.connecting;
        const radius = (typeof snap === 'object' && snap.radius) || 50;
        const anchor = (typeof snap === 'object' && snap.anchor) || 'center';
        const views = graph.renderer.findViewsInArea({
            x: x - radius,
            y: y - radius,
            width: 2 * radius,
            height: 2 * radius,
        }, { nodeOnly: true });
        if (allowEdge) {
            const edgeViews = graph.renderer
                .findEdgeViewsFromPoint({ x, y }, radius)
                .filter((view) => {
                return view !== this;
            });
            views.push(...edgeViews);
        }
        const prevView = data.closestView || null;
        const prevMagnet = data.closestMagnet || null;
        data.closestView = null;
        data.closestMagnet = null;
        let distance;
        let minDistance = Number.MAX_SAFE_INTEGER;
        const pos = new Point(x, y);
        views.forEach((view) => {
            if (view.container.getAttribute('magnet') !== 'false') {
                if (view.isNodeView()) {
                    distance =
                        anchor === 'center'
                            ? view.cell.getBBox().getCenter().distance(pos)
                            : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos);
                }
                else if (view.isEdgeView()) {
                    const point = view.getClosestPoint(pos);
                    if (point) {
                        distance = point.distance(pos);
                    }
                    else {
                        distance = Number.MAX_SAFE_INTEGER;
                    }
                }
                if (distance < radius && distance < minDistance) {
                    if (prevMagnet === view.container ||
                        this.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {
                        minDistance = distance;
                        data.closestView = view;
                        data.closestMagnet = view.container;
                    }
                }
            }
            view.container.querySelectorAll('[magnet]').forEach((magnet) => {
                if (magnet.getAttribute('magnet') !== 'false') {
                    const bbox = view.getBBoxOfElement(magnet);
                    distance = pos.distance(bbox.getCenter());
                    if (distance < radius && distance < minDistance) {
                        if (prevMagnet === magnet ||
                            this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {
                            minDistance = distance;
                            data.closestView = view;
                            data.closestMagnet = magnet;
                        }
                    }
                }
            });
        });
        let terminal;
        const type = data.terminalType;
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        const changed = prevMagnet !== closestMagnet;
        if (prevView && changed) {
            prevView.unhighlight(prevMagnet, {
                type: 'magnetAdsorbed',
            });
        }
        if (closestView) {
            if (!changed) {
                return;
            }
            closestView.highlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
        }
        else {
            terminal = { x, y };
        }
        this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    snapArrowheadEnd(data) {
        // Finish off link snapping.
        // Everything except view unhighlighting was already done on pointermove.
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        if (closestView && closestMagnet) {
            closestView.unhighlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            data.currentMagnet = closestView.findMagnet(closestMagnet);
        }
        data.closestView = null;
        data.closestMagnet = null;
    }
    finishEmbedding(data) {
        // Resets parent of the edge if embedding is enabled
        if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
            // Make sure we don't reverse to the original 'z' index
            data.zIndex = null;
        }
    }
    fallbackConnection(data) {
        switch (data.fallbackAction) {
            case 'remove':
                this.cell.remove({ ui: true });
                break;
            case 'revert':
            default:
                this.cell.prop(data.terminalType, data.initialTerminal, {
                    ui: true,
                });
                break;
        }
    }
    notifyConnectionEvent(data, e) {
        const terminalType = data.terminalType;
        const initialTerminal = data.initialTerminal;
        const currentTerminal = this.cell[terminalType];
        const changed = currentTerminal && !Edge$1.equalTerminals(initialTerminal, currentTerminal);
        if (changed) {
            const graph = this.graph;
            const previous = initialTerminal;
            const previousCell = previous.cell
                ? graph.getCellById(previous.cell)
                : null;
            const previousPort = previous.port;
            const previousView = previousCell
                ? graph.findViewByCell(previousCell)
                : null;
            const previousPoint = previousCell || data.isNewEdge
                ? null
                : Point.create(initialTerminal).toJSON();
            const current = currentTerminal;
            const currentCell = current.cell ? graph.getCellById(current.cell) : null;
            const currentPort = current.port;
            const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
            const currentPoint = currentCell
                ? null
                : Point.create(currentTerminal).toJSON();
            this.notify('edge:connected', {
                e,
                previousCell,
                previousPort,
                previousView,
                previousPoint,
                currentCell,
                currentView,
                currentPort,
                currentPoint,
                previousMagnet: data.initialMagnet,
                currentMagnet: data.currentMagnet,
                edge: this.cell,
                view: this,
                type: terminalType,
                isNew: data.isNewEdge,
            });
        }
    }
    highlightAvailableMagnets(data) {
        const graph = this.graph;
        const cells = graph.model.getCells();
        data.marked = {};
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const view = graph.findViewByCell(cells[i]);
            // Prevent highlighting new edge
            // Close https://github.com/antvis/X6/issues/2853
            if (!view || view.cell.id === this.cell.id) {
                continue;
            }
            const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));
            if (view.container.getAttribute('magnet') !== 'false') {
                magnets.push(view.container);
            }
            const availableMagnets = magnets.filter((magnet) => this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));
            if (availableMagnets.length > 0) {
                // highlight all available magnets
                for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
                    view.highlight(availableMagnets[j], { type: 'magnetAvailable' });
                }
                // highlight the entire view
                view.highlight(null, { type: 'nodeAvailable' });
                data.marked[view.cell.id] = availableMagnets;
            }
        }
    }
    unhighlightAvailableMagnets(data) {
        const marked = data.marked || {};
        Object.keys(marked).forEach((id) => {
            const view = this.graph.findViewByCell(id);
            if (view) {
                const magnets = marked[id];
                magnets.forEach((magnet) => {
                    view.unhighlight(magnet, { type: 'magnetAvailable' });
                });
                view.unhighlight(null, { type: 'nodeAvailable' });
            }
        });
        data.marked = null;
    }
    startArrowheadDragging(e, x, y) {
        if (!this.can('arrowheadMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        const elem = e.target;
        const type = elem.getAttribute('data-terminal');
        const data = this.prepareArrowheadDragging(type, { x, y });
        this.setEventData(e, data);
    }
    dragArrowhead(e, x, y) {
        const data = this.getEventData(e);
        if (this.graph.options.connecting.snap) {
            this.snapArrowhead(x, y, data);
        }
        else {
            this.arrowheadDragging(this.getEventTarget(e), x, y, data);
        }
    }
    stopArrowheadDragging(e, x, y) {
        const graph = this.graph;
        const data = this.getEventData(e);
        if (graph.options.connecting.snap) {
            this.snapArrowheadEnd(data);
        }
        else {
            this.arrowheadDragged(data, x, y);
        }
        const valid = this.validateEdge(this.cell, data.terminalType, data.initialTerminal);
        if (valid) {
            this.finishEmbedding(data);
            this.notifyConnectionEvent(data, e);
        }
        else {
            // If the changed edge is not allowed, revert to its previous state.
            this.fallbackConnection(data);
        }
        this.afterArrowheadDragging(data);
    }
    // #endregion
    // #region drag lable
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startLabelDragging(e, x, y) {
        if (this.can('edgeLabelMovable')) {
            const target = e.currentTarget;
            const index = parseInt(target.getAttribute('data-index'), 10);
            const positionAngle = this.getLabelPositionAngle(index);
            const labelPositionArgs = this.getLabelPositionArgs(index);
            const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
            const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.setEventData(e, {
                index,
                positionAngle,
                positionArgs,
                stopPropagation: true,
                action: 'drag-label',
            });
        }
        else {
            // If labels can't be dragged no default action is triggered.
            this.setEventData(e, { stopPropagation: true });
        }
        this.graph.view.delegateDragEvents(e, this);
    }
    dragLabel(e, x, y) {
        const data = this.getEventData(e);
        const originLabel = this.cell.getLabelAt(data.index);
        const label = merge$1({}, originLabel, {
            position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs),
        });
        this.cell.setLabelAt(data.index, label);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stopLabelDragging(e, x, y) { }
}
(function (EdgeView) {
    EdgeView.toStringTag = `X6.${EdgeView.name}`;
    function isEdgeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof EdgeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === EdgeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.getConnection === 'function') {
            return true;
        }
        return false;
    }
    EdgeView.isEdgeView = isEdgeView;
})(EdgeView || (EdgeView = {}));
EdgeView.config({
    isSvgElement: true,
    priority: 1,
    bootstrap: ['render', 'source', 'target'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        source: ['source', 'update'],
        target: ['target', 'update'],
        router: ['update'],
        connector: ['update'],
        labels: ['labels'],
        defaultLabel: ['labels'],
        tools: ['tools'],
        vertices: ['vertices', 'update'],
    },
});
EdgeView.registry.register('edge', EdgeView, true);

var __decorate$c = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GraphView extends View {
    /** Graph's `this.container` is from outer, should not dispose */
    get disposeContainer() {
        return false;
    }
    get options() {
        return this.graph.options;
    }
    constructor(graph) {
        super();
        this.graph = graph;
        const { selectors, fragment } = Markup.parseJSONMarkup(GraphView.markup);
        this.background = selectors.background;
        this.grid = selectors.grid;
        this.svg = selectors.svg;
        this.defs = selectors.defs;
        this.viewport = selectors.viewport;
        this.primer = selectors.primer;
        this.stage = selectors.stage;
        this.decorator = selectors.decorator;
        this.overlay = selectors.overlay;
        this.container = this.options.container;
        this.restore = GraphView.snapshoot(this.container);
        addClass(this.container, this.prefixClassName('graph'));
        append(this.container, fragment);
        this.delegateEvents();
    }
    delegateEvents() {
        const ctor = this.constructor;
        super.delegateEvents(ctor.events);
        return this;
    }
    /**
     * Guard the specified event. If the event is not interesting, it
     * returns `true`, otherwise returns `false`.
     */
    guard(e, view) {
        // handled as `contextmenu` type
        if (e.type === 'mousedown' && e.button === 2) {
            return true;
        }
        if (this.options.guard && this.options.guard(e, view)) {
            return true;
        }
        if (e.data && e.data.guarded !== undefined) {
            return e.data.guarded;
        }
        if (view && view.cell && Cell.isCell(view.cell)) {
            return false;
        }
        if (this.svg === e.target ||
            this.container === e.target ||
            this.svg.contains(e.target)) {
            return false;
        }
        return true;
    }
    findView(elem) {
        return this.graph.findViewByElem(elem);
    }
    onDblClick(evt) {
        if (this.options.preventDefaultDblClick) {
            evt.preventDefault();
        }
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onDblClick(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:dblclick', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onClick(evt) {
        if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
            const e = this.normalizeEvent(evt);
            const view = this.findView(e.target);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            if (view) {
                view.onClick(e, localPoint.x, localPoint.y);
            }
            else {
                this.graph.trigger('blank:click', {
                    e,
                    x: localPoint.x,
                    y: localPoint.y,
                });
            }
        }
    }
    isPreventDefaultContextMenu(view) {
        let preventDefaultContextMenu = this.options.preventDefaultContextMenu;
        if (typeof preventDefaultContextMenu === 'function') {
            preventDefaultContextMenu = call$1(preventDefaultContextMenu, this.graph, { view });
        }
        return preventDefaultContextMenu;
    }
    onContextMenu(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(view)) {
            evt.preventDefault();
        }
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onContextMenu(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:contextmenu', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    delegateDragEvents(e, view) {
        if (e.data == null) {
            e.data = {};
        }
        this.setEventData(e, {
            currentView: view || null,
            mouseMovedCount: 0,
            startPosition: {
                x: e.clientX,
                y: e.clientY,
            },
        });
        const ctor = this.constructor;
        this.delegateDocumentEvents(ctor.documentEvents, e.data);
        this.undelegateEvents();
    }
    getMouseMovedCount(e) {
        const data = this.getEventData(e);
        return data.mouseMovedCount || 0;
    }
    onMouseDown(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (this.options.preventDefaultMouseDown) {
            evt.preventDefault();
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onMouseDown(e, localPoint.x, localPoint.y);
        }
        else {
            if (this.options.preventDefaultBlankAction &&
                ['touchstart'].includes(e.type)) {
                evt.preventDefault();
            }
            this.graph.trigger('blank:mousedown', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.delegateDragEvents(e, view);
    }
    onMouseMove(evt) {
        const data = this.getEventData(evt);
        const startPosition = data.startPosition;
        if (startPosition &&
            startPosition.x === evt.clientX &&
            startPosition.y === evt.clientY) {
            return;
        }
        if (data.mouseMovedCount == null) {
            data.mouseMovedCount = 0;
        }
        data.mouseMovedCount += 1;
        const mouseMovedCount = data.mouseMovedCount;
        if (mouseMovedCount <= this.options.moveThreshold) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        const view = data.currentView;
        if (view) {
            view.onMouseMove(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mousemove', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.setEventData(e, data);
    }
    onMouseUp(e) {
        this.undelegateDocumentEvents();
        const normalized = this.normalizeEvent(e);
        const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
        const data = this.getEventData(e);
        const view = data.currentView;
        if (view) {
            view.onMouseUp(normalized, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mouseup', {
                e: normalized,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        if (!e.isPropagationStopped()) {
            const ev = new EventObject(e, {
                type: 'click',
                data: e.data,
            });
            this.onClick(ev);
        }
        e.stopImmediatePropagation();
        this.delegateEvents();
    }
    onMouseOver(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOver(e);
        }
        else {
            // prevent border of paper from triggering this
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseover', { e });
        }
    }
    onMouseOut(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOut(e);
        }
        else {
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseout', { e });
        }
    }
    onMouseEnter(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from tool to view
                return;
            }
            view.onMouseEnter(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseenter', { e });
        }
    }
    onMouseLeave(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from view to tool
                return;
            }
            view.onMouseLeave(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseleave', { e });
        }
    }
    onMouseWheel(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const originalEvent = e.originalEvent;
        const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
        const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));
        if (view) {
            view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
        }
        else {
            this.graph.trigger('blank:mousewheel', {
                e,
                delta,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onCustomEvent(evt) {
        const elem = evt.currentTarget;
        const event = elem.getAttribute('event') || elem.getAttribute('data-event');
        if (event) {
            const view = this.findView(elem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                view.onCustomEvent(e, event, localPoint.x, localPoint.y);
            }
        }
    }
    handleMagnetEvent(evt, handler) {
        const magnetElem = evt.currentTarget;
        const magnetValue = magnetElem.getAttribute('magnet');
        if (magnetValue && magnetValue.toLowerCase() !== 'false') {
            const view = this.findView(magnetElem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                call$1(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
            }
        }
    }
    onMagnetMouseDown(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetMouseDown(e, magnet, x, y);
        });
    }
    onMagnetDblClick(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetDblClick(e, magnet, x, y);
        });
    }
    onMagnetContextMenu(e) {
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(view)) {
            e.preventDefault();
        }
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetContextMenu(e, magnet, x, y);
        });
    }
    onLabelMouseDown(evt) {
        const labelNode = evt.currentTarget;
        const view = this.findView(labelNode);
        if (view) {
            const e = this.normalizeEvent(evt);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            view.onLabelMouseDown(e, localPoint.x, localPoint.y);
        }
    }
    onImageDragStart() {
        // This is the only way to prevent image dragging in Firefox that works.
        // Setting -moz-user-select: none, draggable="false" attribute or
        // user-drag: none didn't help.
        return false;
    }
    dispose() {
        this.undelegateEvents();
        this.undelegateDocumentEvents();
        this.restore();
        this.restore = () => { };
    }
}
__decorate$c([
    View.dispose()
], GraphView.prototype, "dispose", null);
(function (GraphView) {
    const prefixCls = `${Config.prefixCls}-graph`;
    GraphView.markup = [
        {
            ns: ns.xhtml,
            tagName: 'div',
            selector: 'background',
            className: `${prefixCls}-background`,
        },
        {
            ns: ns.xhtml,
            tagName: 'div',
            selector: 'grid',
            className: `${prefixCls}-grid`,
        },
        {
            ns: ns.svg,
            tagName: 'svg',
            selector: 'svg',
            className: `${prefixCls}-svg`,
            attrs: {
                width: '100%',
                height: '100%',
                'xmlns:xlink': ns.xlink,
            },
            children: [
                {
                    tagName: 'defs',
                    selector: 'defs',
                },
                {
                    tagName: 'g',
                    selector: 'viewport',
                    className: `${prefixCls}-svg-viewport`,
                    children: [
                        {
                            tagName: 'g',
                            selector: 'primer',
                            className: `${prefixCls}-svg-primer`,
                        },
                        {
                            tagName: 'g',
                            selector: 'stage',
                            className: `${prefixCls}-svg-stage`,
                        },
                        {
                            tagName: 'g',
                            selector: 'decorator',
                            className: `${prefixCls}-svg-decorator`,
                        },
                        {
                            tagName: 'g',
                            selector: 'overlay',
                            className: `${prefixCls}-svg-overlay`,
                        },
                    ],
                },
            ],
        },
    ];
    function snapshoot(elem) {
        const cloned = elem.cloneNode();
        elem.childNodes.forEach((child) => cloned.appendChild(child));
        return () => {
            // remove all children
            empty(elem);
            // remove all attributes
            while (elem.attributes.length > 0) {
                elem.removeAttribute(elem.attributes[0].name);
            }
            // restore attributes
            for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
                const attr = cloned.attributes[i];
                elem.setAttribute(attr.name, attr.value);
            }
            // restore children
            cloned.childNodes.forEach((child) => elem.appendChild(child));
        };
    }
    GraphView.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));
(function (GraphView) {
    const prefixCls = Config.prefixCls;
    GraphView.events = {
        dblclick: 'onDblClick',
        contextmenu: 'onContextMenu',
        touchstart: 'onMouseDown',
        mousedown: 'onMouseDown',
        mouseover: 'onMouseOver',
        mouseout: 'onMouseOut',
        mouseenter: 'onMouseEnter',
        mouseleave: 'onMouseLeave',
        mousewheel: 'onMouseWheel',
        DOMMouseScroll: 'onMouseWheel',
        [`mouseenter  .${prefixCls}-cell`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell`]: 'onMouseLeave',
        [`mouseenter  .${prefixCls}-cell-tools`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell-tools`]: 'onMouseLeave',
        [`mousedown   .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`mousedown   .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`dblclick    .${prefixCls}-cell [magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`dblclick    .${prefixCls}-cell [data-magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [data-magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`dragstart   .${prefixCls}-cell image`]: 'onImageDragStart',
        [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
        [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
    };
    GraphView.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp',
    };
})(GraphView || (GraphView = {}));

/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;

class Base extends Disposable {
    get options() {
        return this.graph.options;
    }
    get model() {
        return this.graph.model;
    }
    get view() {
        return this.graph.view;
    }
    constructor(graph) {
        super();
        this.graph = graph;
        this.init();
    }
    init() { }
}

var __decorate$b = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class CSSManager extends Base {
    init() {
        {
            ensure('core', content);
        }
    }
    dispose() {
        clean('core');
    }
}
__decorate$b([
    CSSManager.dispose()
], CSSManager.prototype, "dispose", null);

var __rest$3 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Options;
(function (Options) {
    function get(options) {
        const { grid, panning, mousewheel, embedding } = options, others = __rest$3(options
        // size
        // ----
        , ["grid", "panning", "mousewheel", "embedding"]);
        // size
        // ----
        const container = options.container;
        if (container != null) {
            if (others.width == null) {
                others.width = container.clientWidth;
            }
            if (others.height == null) {
                others.height = container.clientHeight;
            }
        }
        else {
            throw new Error(`Ensure the container of the graph is specified and valid`);
        }
        const result = merge$1({}, Options.defaults, others);
        // grid
        // ----
        const defaultGrid = { size: 10, visible: false };
        if (typeof grid === 'number') {
            result.grid = { size: grid, visible: false };
        }
        else if (typeof grid === 'boolean') {
            result.grid = Object.assign(Object.assign({}, defaultGrid), { visible: grid });
        }
        else {
            result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
        }
        // booleas
        // -------
        const booleas = [
            'panning',
            'mousewheel',
            'embedding',
        ];
        booleas.forEach((key) => {
            const val = options[key];
            if (typeof val === 'boolean') {
                result[key].enabled = val;
            }
            else {
                result[key] = Object.assign(Object.assign({}, result[key]), val);
            }
        });
        return result;
    }
    Options.get = get;
})(Options || (Options = {}));
(function (Options) {
    Options.defaults = {
        x: 0,
        y: 0,
        scaling: {
            min: 0.01,
            max: 16,
        },
        grid: {
            size: 10,
            visible: false,
        },
        background: false,
        panning: {
            enabled: false,
            eventTypes: ['leftMouseDown'],
        },
        mousewheel: {
            enabled: false,
            factor: 1.2,
            zoomAtMousePosition: true,
        },
        highlighting: {
            default: {
                name: 'stroke',
                args: {
                    padding: 3,
                },
            },
            nodeAvailable: {
                name: 'className',
                args: {
                    className: Config.prefix('available-node'),
                },
            },
            magnetAvailable: {
                name: 'className',
                args: {
                    className: Config.prefix('available-magnet'),
                },
            },
        },
        connecting: {
            snap: false,
            allowLoop: true,
            allowNode: true,
            allowEdge: false,
            allowPort: true,
            allowBlank: true,
            allowMulti: true,
            highlight: false,
            anchor: 'center',
            edgeAnchor: 'ratio',
            connectionPoint: 'boundary',
            router: 'normal',
            connector: 'normal',
            validateConnection({ type, sourceView, targetView }) {
                const view = type === 'target' ? targetView : sourceView;
                return view != null;
            },
            createEdge() {
                return new Edge();
            },
        },
        translating: {
            restrict: false,
        },
        embedding: {
            enabled: false,
            findParent: 'bbox',
            frontOnly: true,
            validate: () => true,
        },
        moveThreshold: 0,
        clickThreshold: 0,
        magnetThreshold: 0,
        preventDefaultDblClick: true,
        preventDefaultMouseDown: false,
        preventDefaultContextMenu: true,
        preventDefaultBlankAction: true,
        interacting: {
            edgeLabelMovable: false,
        },
        async: true,
        virtual: false,
        guard: () => false,
    };
})(Options || (Options = {}));

var __decorate$a = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$2 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class GridManager extends Base {
    get elem() {
        return this.view.grid;
    }
    get grid() {
        return this.options.grid;
    }
    init() {
        this.startListening();
        this.draw(this.grid);
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    setVisible(visible) {
        if (this.grid.visible !== visible) {
            this.grid.visible = visible;
            this.update();
        }
    }
    getGridSize() {
        return this.grid.size;
    }
    setGridSize(size) {
        this.grid.size = Math.max(size, 1);
        this.update();
    }
    show() {
        this.setVisible(true);
        this.update();
    }
    hide() {
        this.setVisible(false);
        this.update();
    }
    clear() {
        this.elem.style.backgroundImage = '';
    }
    draw(options) {
        this.clear();
        this.instance = null;
        Object.assign(this.grid, options);
        this.patterns = this.resolveGrid(options);
        this.update();
    }
    update(options = {}) {
        const gridSize = this.grid.size;
        if (gridSize <= 1 || !this.grid.visible) {
            return this.clear();
        }
        const ctm = this.graph.matrix();
        const grid = this.getInstance();
        const items = Array.isArray(options) ? options : [options];
        this.patterns.forEach((settings, index) => {
            const id = `pattern_${index}`;
            const sx = ctm.a || 1;
            const sy = ctm.d || 1;
            const { update, markup } = settings, others = __rest$2(settings, ["update", "markup"]);
            const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), { sx,
                sy, ox: ctm.e || 0, oy: ctm.f || 0, width: gridSize * sx, height: gridSize * sy });
            if (!grid.has(id)) {
                grid.add(id, Vector.create('pattern', { id, patternUnits: 'userSpaceOnUse' }, Vector.createVectors(markup)).node);
            }
            const patternElem = grid.get(id);
            if (typeof update === 'function') {
                update(patternElem.childNodes[0], options);
            }
            let x = options.ox % options.width;
            if (x < 0) {
                x += options.width;
            }
            let y = options.oy % options.height;
            if (y < 0) {
                y += options.height;
            }
            attr(patternElem, {
                x,
                y,
                width: options.width,
                height: options.height,
            });
        });
        const base64 = new XMLSerializer().serializeToString(grid.root);
        const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
        this.elem.style.backgroundImage = url;
    }
    getInstance() {
        if (!this.instance) {
            this.instance = new Grid();
        }
        return this.instance;
    }
    resolveGrid(options) {
        if (!options) {
            return [];
        }
        const type = options.type;
        if (type == null) {
            return [
                Object.assign(Object.assign({}, Grid.presets.dot), options.args),
            ];
        }
        const items = Grid.registry.get(type);
        if (items) {
            let args = options.args || [];
            if (!Array.isArray(args)) {
                args = [args];
            }
            return Array.isArray(items)
                ? items.map((item, index) => (Object.assign(Object.assign({}, item), args[index])))
                : [Object.assign(Object.assign({}, items), args[0])];
        }
        return Grid.registry.onNotFound(type);
    }
    dispose() {
        this.stopListening();
        this.clear();
    }
}
__decorate$a([
    Base.dispose()
], GridManager.prototype, "dispose", null);

class TransformManager extends Base {
    get container() {
        return this.graph.view.container;
    }
    get viewport() {
        return this.graph.view.viewport;
    }
    get stage() {
        return this.graph.view.stage;
    }
    init() {
        this.resize();
    }
    /**
     * Returns the current transformation matrix of the graph.
     */
    getMatrix() {
        const transform = this.viewport.getAttribute('transform');
        if (transform !== this.viewportTransformString) {
            // `getCTM`: top-left relative to the SVG element
            // `getScreenCTM`: top-left relative to the document
            this.viewportMatrix = this.viewport.getCTM();
            this.viewportTransformString = transform;
        }
        // Clone the cached current transformation matrix.
        // If no matrix previously stored the identity matrix is returned.
        return createSVGMatrix(this.viewportMatrix);
    }
    /**
     * Sets new transformation with the given `matrix`
     */
    setMatrix(matrix) {
        const ctm = createSVGMatrix(matrix);
        const transform = matrixToTransformString(ctm);
        this.viewport.setAttribute('transform', transform);
        this.viewportMatrix = ctm;
        this.viewportTransformString = transform;
    }
    resize(width, height) {
        let w = width === undefined ? this.options.width : width;
        let h = height === undefined ? this.options.height : height;
        this.options.width = w;
        this.options.height = h;
        if (typeof w === 'number') {
            w = Math.round(w);
        }
        if (typeof h === 'number') {
            h = Math.round(h);
        }
        this.container.style.width = w == null ? '' : `${w}px`;
        this.container.style.height = h == null ? '' : `${h}px`;
        const size = this.getComputedSize();
        this.graph.trigger('resize', Object.assign({}, size));
        return this;
    }
    getComputedSize() {
        let w = this.options.width;
        let h = this.options.height;
        if (!isNumber(w)) {
            w = this.container.clientWidth;
        }
        if (!isNumber(h)) {
            h = this.container.clientHeight;
        }
        return { width: w, height: h };
    }
    getScale() {
        return matrixToScale(this.getMatrix());
    }
    scale(sx, sy = sx, ox = 0, oy = 0) {
        sx = this.clampScale(sx); // eslint-disable-line
        sy = this.clampScale(sy); // eslint-disable-line
        if (ox || oy) {
            const ts = this.getTranslation();
            const tx = ts.tx - ox * (sx - 1);
            const ty = ts.ty - oy * (sy - 1);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        const matrix = this.getMatrix();
        matrix.a = sx;
        matrix.d = sy;
        this.setMatrix(matrix);
        this.graph.trigger('scale', { sx, sy, ox, oy });
        return this;
    }
    clampScale(scale) {
        const range = this.graph.options.scaling;
        return clamp(scale, range.min || 0.01, range.max || 16);
    }
    getZoom() {
        return this.getScale().sx;
    }
    zoom(factor, options) {
        options = options || {}; // eslint-disable-line
        let sx = factor;
        let sy = factor;
        const scale = this.getScale();
        const clientSize = this.getComputedSize();
        let cx = clientSize.width / 2;
        let cy = clientSize.height / 2;
        if (!options.absolute) {
            sx += scale.sx;
            sy += scale.sy;
        }
        if (options.scaleGrid) {
            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
        }
        if (options.maxScale) {
            sx = Math.min(options.maxScale, sx);
            sy = Math.min(options.maxScale, sy);
        }
        if (options.minScale) {
            sx = Math.max(options.minScale, sx);
            sy = Math.max(options.minScale, sy);
        }
        if (options.center) {
            cx = options.center.x;
            cy = options.center.y;
        }
        sx = this.clampScale(sx);
        sy = this.clampScale(sy);
        if (cx || cy) {
            const ts = this.getTranslation();
            const tx = cx - (cx - ts.tx) * (sx / scale.sx);
            const ty = cy - (cy - ts.ty) * (sy / scale.sy);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        this.scale(sx, sy);
        return this;
    }
    getRotation() {
        return matrixToRotation(this.getMatrix());
    }
    rotate(angle, cx, cy) {
        if (cx == null || cy == null) {
            const bbox = Util.getBBox(this.stage);
            cx = bbox.width / 2; // eslint-disable-line
            cy = bbox.height / 2; // eslint-disable-line
        }
        const ctm = this.getMatrix()
            .translate(cx, cy)
            .rotate(angle)
            .translate(-cx, -cy);
        this.setMatrix(ctm);
        return this;
    }
    getTranslation() {
        return matrixToTranslation(this.getMatrix());
    }
    translate(tx, ty) {
        const matrix = this.getMatrix();
        matrix.e = tx || 0;
        matrix.f = ty || 0;
        this.setMatrix(matrix);
        const ts = this.getTranslation();
        this.options.x = ts.tx;
        this.options.y = ts.ty;
        this.graph.trigger('translate', Object.assign({}, ts));
        return this;
    }
    setOrigin(ox, oy) {
        return this.translate(ox || 0, oy || 0);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        if (typeof gridWidth === 'object') {
            const opts = gridWidth;
            gridWidth = opts.gridWidth || 1; // eslint-disable-line
            gridHeight = opts.gridHeight || 1; // eslint-disable-line
            padding = opts.padding || 0; // eslint-disable-line
            options = opts; // eslint-disable-line
        }
        else {
            gridWidth = gridWidth || 1; // eslint-disable-line
            gridHeight = gridHeight || 1; // eslint-disable-line
            padding = padding || 0; // eslint-disable-line
            if (options == null) {
                options = {}; // eslint-disable-line
            }
        }
        const paddings = normalizeSides(padding);
        const border = options.border || 0;
        const contentArea = options.contentArea
            ? Rectangle.create(options.contentArea)
            : this.getContentArea(options);
        if (border > 0) {
            contentArea.inflate(border);
        }
        const scale = this.getScale();
        const translate = this.getTranslation();
        const sx = scale.sx;
        const sy = scale.sy;
        contentArea.x *= sx;
        contentArea.y *= sy;
        contentArea.width *= sx;
        contentArea.height *= sy;
        let width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) *
            gridWidth;
        let height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
        let tx = 0;
        let ty = 0;
        if ((options.allowNewOrigin === 'negative' && contentArea.x < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.x >= 0) ||
            options.allowNewOrigin === 'any') {
            tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
            tx += paddings.left;
            width += tx;
        }
        if ((options.allowNewOrigin === 'negative' && contentArea.y < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.y >= 0) ||
            options.allowNewOrigin === 'any') {
            ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
            ty += paddings.top;
            height += ty;
        }
        width += paddings.right;
        height += paddings.bottom;
        // Make sure the resulting width and height are greater than minimum.
        width = Math.max(width, options.minWidth || 0);
        height = Math.max(height, options.minHeight || 0);
        // Make sure the resulting width and height are lesser than maximum.
        width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
        height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
        const size = this.getComputedSize();
        const sizeChanged = width !== size.width || height !== size.height;
        const originChanged = tx !== translate.tx || ty !== translate.ty;
        // Change the dimensions only if there is a size discrepency or an origin change
        if (originChanged) {
            this.translate(tx, ty);
        }
        if (sizeChanged) {
            this.resize(width, height);
        }
        return new Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
    }
    scaleContentToFit(options = {}) {
        this.scaleContentToFitImpl(options);
    }
    scaleContentToFitImpl(options = {}, translate = true) {
        let contentBBox;
        let contentLocalOrigin;
        if (options.contentArea) {
            const contentArea = options.contentArea;
            contentBBox = this.graph.localToGraph(contentArea);
            contentLocalOrigin = Point.create(contentArea);
        }
        else {
            contentBBox = this.getContentBBox(options);
            contentLocalOrigin = this.graph.graphToLocal(contentBBox);
        }
        if (!contentBBox.width || !contentBBox.height) {
            return;
        }
        const padding = normalizeSides(options.padding);
        const minScale = options.minScale || 0;
        const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
        const minScaleX = options.minScaleX || minScale;
        const maxScaleX = options.maxScaleX || maxScale;
        const minScaleY = options.minScaleY || minScale;
        const maxScaleY = options.maxScaleY || maxScale;
        let fittingBox;
        if (options.viewportArea) {
            fittingBox = options.viewportArea;
        }
        else {
            const computedSize = this.getComputedSize();
            const currentTranslate = this.getTranslation();
            fittingBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height,
            };
        }
        fittingBox = Rectangle.create(fittingBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom,
        });
        const currentScale = this.getScale();
        let newSX = (fittingBox.width / contentBBox.width) * currentScale.sx;
        let newSY = (fittingBox.height / contentBBox.height) * currentScale.sy;
        if (options.preserveAspectRatio !== false) {
            newSX = newSY = Math.min(newSX, newSY);
        }
        // snap scale to a grid
        const gridSize = options.scaleGrid;
        if (gridSize) {
            newSX = gridSize * Math.floor(newSX / gridSize);
            newSY = gridSize * Math.floor(newSY / gridSize);
        }
        // scale min/max boundaries
        newSX = clamp(newSX, minScaleX, maxScaleX);
        newSY = clamp(newSY, minScaleY, maxScaleY);
        this.scale(newSX, newSY);
        if (translate) {
            const origin = this.options;
            const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
            const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
            this.translate(newOX, newOY);
        }
    }
    getContentArea(options = {}) {
        // use geometry calc default
        if (options.useCellGeometry !== false) {
            return this.model.getAllCellsBBox() || new Rectangle();
        }
        return Util.getBBox(this.stage);
    }
    getContentBBox(options = {}) {
        return this.graph.localToGraph(this.getContentArea(options));
    }
    getGraphArea() {
        const rect = Rectangle.fromSize(this.getComputedSize());
        return this.graph.graphToLocal(rect);
    }
    zoomToRect(rect, options = {}) {
        const area = Rectangle.create(rect);
        const graph = this.graph;
        options.contentArea = area;
        if (options.viewportArea == null) {
            options.viewportArea = {
                x: graph.options.x,
                y: graph.options.y,
                width: this.options.width,
                height: this.options.height,
            };
        }
        this.scaleContentToFitImpl(options, false);
        const center = area.getCenter();
        this.centerPoint(center.x, center.y);
        return this;
    }
    zoomToFit(options = {}) {
        return this.zoomToRect(this.getContentArea(options), options);
    }
    centerPoint(x, y) {
        const clientSize = this.getComputedSize();
        const scale = this.getScale();
        const ts = this.getTranslation();
        const cx = clientSize.width / 2;
        const cy = clientSize.height / 2;
        x = typeof x === 'number' ? x : cx; // eslint-disable-line
        y = typeof y === 'number' ? y : cy; // eslint-disable-line
        x = cx - x * scale.sx; // eslint-disable-line
        y = cy - y * scale.sy; // eslint-disable-line
        if (ts.tx !== x || ts.ty !== y) {
            this.translate(x, y);
        }
    }
    centerContent(options) {
        const rect = this.graph.getContentArea(options);
        const center = rect.getCenter();
        this.centerPoint(center.x, center.y);
    }
    centerCell(cell) {
        return this.positionCell(cell, 'center');
    }
    positionPoint(point, x, y) {
        const clientSize = this.getComputedSize();
        // eslint-disable-next-line
        x = normalizePercentage(x, Math.max(0, clientSize.width));
        if (x < 0) {
            x = clientSize.width + x; // eslint-disable-line
        }
        // eslint-disable-next-line
        y = normalizePercentage(y, Math.max(0, clientSize.height));
        if (y < 0) {
            y = clientSize.height + y; // eslint-disable-line
        }
        const ts = this.getTranslation();
        const scale = this.getScale();
        const dx = x - point.x * scale.sx;
        const dy = y - point.y * scale.sy;
        if (ts.tx !== dx || ts.ty !== dy) {
            this.translate(dx, dy);
        }
    }
    positionRect(rect, pos) {
        const bbox = Rectangle.create(rect);
        switch (pos) {
            case 'center':
                return this.positionPoint(bbox.getCenter(), '50%', '50%');
            case 'top':
                return this.positionPoint(bbox.getTopCenter(), '50%', 0);
            case 'top-right':
                return this.positionPoint(bbox.getTopRight(), '100%', 0);
            case 'right':
                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');
            case 'bottom-right':
                return this.positionPoint(bbox.getBottomRight(), '100%', '100%');
            case 'bottom':
                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');
            case 'bottom-left':
                return this.positionPoint(bbox.getBottomLeft(), 0, '100%');
            case 'left':
                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');
            case 'top-left':
                return this.positionPoint(bbox.getTopLeft(), 0, 0);
            default:
                return this;
        }
    }
    positionCell(cell, pos) {
        const bbox = cell.getBBox();
        return this.positionRect(bbox, pos);
    }
    positionContent(pos, options) {
        const rect = this.graph.getContentArea(options);
        return this.positionRect(rect, pos);
    }
}

var __decorate$9 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class BackgroundManager extends Base {
    get elem() {
        return this.view.background;
    }
    init() {
        this.startListening();
        if (this.options.background) {
            this.draw(this.options.background);
        }
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    updateBackgroundImage(options = {}) {
        let backgroundSize = options.size || 'auto auto';
        let backgroundPosition = options.position || 'center';
        const scale = this.graph.transform.getScale();
        const ts = this.graph.translate();
        // backgroundPosition
        if (typeof backgroundPosition === 'object') {
            const x = ts.tx + scale.sx * (backgroundPosition.x || 0);
            const y = ts.ty + scale.sy * (backgroundPosition.y || 0);
            backgroundPosition = `${x}px ${y}px`;
        }
        // backgroundSize
        if (typeof backgroundSize === 'object') {
            backgroundSize = Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);
            backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
        }
        this.elem.style.backgroundSize = backgroundSize;
        this.elem.style.backgroundPosition = backgroundPosition;
    }
    drawBackgroundImage(img, options = {}) {
        if (!(img instanceof HTMLImageElement)) {
            this.elem.style.backgroundImage = '';
            return;
        }
        // draw multiple times to show the last image
        const cache = this.optionsCache;
        if (cache && cache.image !== options.image) {
            return;
        }
        let uri;
        const opacity = options.opacity;
        const backgroundSize = options.size;
        let backgroundRepeat = options.repeat || 'no-repeat';
        const pattern = Background.registry.get(backgroundRepeat);
        if (typeof pattern === 'function') {
            const quality = options.quality || 1;
            img.width *= quality;
            img.height *= quality;
            const canvas = pattern(img, options);
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new Error('Background pattern must return an HTML Canvas instance');
            }
            uri = canvas.toDataURL('image/png');
            // `repeat` was changed in pattern function
            if (options.repeat && backgroundRepeat !== options.repeat) {
                backgroundRepeat = options.repeat;
            }
            else {
                backgroundRepeat = 'repeat';
            }
            if (typeof backgroundSize === 'object') {
                // recalculate the tile size if an object passed in
                backgroundSize.width *= canvas.width / img.width;
                backgroundSize.height *= canvas.height / img.height;
            }
            else if (backgroundSize === undefined) {
                // calcule the tile size if no provided
                options.size = {
                    width: canvas.width / quality,
                    height: canvas.height / quality,
                };
            }
        }
        else {
            uri = img.src;
            if (backgroundSize === undefined) {
                options.size = {
                    width: img.width,
                    height: img.height,
                };
            }
        }
        if (cache != null &&
            typeof options.size === 'object' &&
            options.image === cache.image &&
            options.repeat === cache.repeat &&
            options.quality ===
                cache.quality) {
            cache.size = clone(options.size);
        }
        const style = this.elem.style;
        style.backgroundImage = `url(${uri})`;
        style.backgroundRepeat = backgroundRepeat;
        style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`;
        this.updateBackgroundImage(options);
    }
    updateBackgroundColor(color) {
        this.elem.style.backgroundColor = color || '';
    }
    updateBackgroundOptions(options) {
        this.graph.options.background = options;
    }
    update() {
        if (this.optionsCache) {
            this.updateBackgroundImage(this.optionsCache);
        }
    }
    draw(options) {
        const opts = options || {};
        this.updateBackgroundOptions(options);
        this.updateBackgroundColor(opts.color);
        if (opts.image) {
            this.optionsCache = clone(opts);
            const img = document.createElement('img');
            img.onload = () => this.drawBackgroundImage(img, options);
            img.setAttribute('crossorigin', 'anonymous');
            img.src = opts.image;
        }
        else {
            this.drawBackgroundImage(null);
            this.optionsCache = null;
        }
    }
    clear() {
        this.draw();
    }
    dispose() {
        this.clear();
        this.stopListening();
    }
}
__decorate$9([
    Base.dispose()
], BackgroundManager.prototype, "dispose", null);

var __decorate$8 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PanningManager extends Base {
    get widgetOptions() {
        return this.options.panning;
    }
    get pannable() {
        return this.widgetOptions && this.widgetOptions.enabled === true;
    }
    init() {
        this.onRightMouseDown = this.onRightMouseDown.bind(this);
        this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this);
        this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this);
        this.startListening();
        this.updateClassName();
    }
    startListening() {
        this.graph.on('blank:mousedown', this.onMouseDown, this);
        this.graph.on('node:unhandled:mousedown', this.onMouseDown, this);
        this.graph.on('edge:unhandled:mousedown', this.onMouseDown, this);
        Event.on(this.graph.container, 'mousedown', this.onRightMouseDown);
        Event.on(document.body, {
            keydown: this.onSpaceKeyDown,
            keyup: this.onSpaceKeyUp,
        });
        this.mousewheelHandle = new MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
        this.mousewheelHandle.enable();
    }
    stopListening() {
        this.graph.off('blank:mousedown', this.onMouseDown, this);
        this.graph.off('node:unhandled:mousedown', this.onMouseDown, this);
        this.graph.off('edge:unhandled:mousedown', this.onMouseDown, this);
        Event.off(this.graph.container, 'mousedown', this.onRightMouseDown);
        Event.off(document.body, {
            keydown: this.onSpaceKeyDown,
            keyup: this.onSpaceKeyUp,
        });
        if (this.mousewheelHandle) {
            this.mousewheelHandle.disable();
        }
    }
    allowPanning(e, strict) {
        e.spaceKey = this.isSpaceKeyPressed;
        return (this.pannable &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict));
    }
    startPanning(evt) {
        const e = this.view.normalizeEvent(evt);
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.panning = true;
        this.updateClassName();
        Event.on(document.body, {
            'mousemove.panning touchmove.panning': this.pan.bind(this),
            'mouseup.panning touchend.panning': this.stopPanning.bind(this),
            'mouseleave.panning': this.stopPanning.bind(this),
        });
        Event.on(window, 'mouseup.panning', this.stopPanning.bind(this));
    }
    pan(evt) {
        const e = this.view.normalizeEvent(evt);
        const dx = e.clientX - this.clientX;
        const dy = e.clientY - this.clientY;
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.graph.translateBy(dx, dy);
    }
    // eslint-disable-next-line
    stopPanning(e) {
        this.panning = false;
        this.updateClassName();
        Event.off(document.body, '.panning');
        Event.off(window, '.panning');
    }
    updateClassName() {
        const container = this.view.container;
        const panning = this.view.prefixClassName('graph-panning');
        const pannable = this.view.prefixClassName('graph-pannable');
        if (this.pannable) {
            if (this.panning) {
                addClass(container, panning);
                removeClass(container, pannable);
            }
            else {
                removeClass(container, panning);
                addClass(container, pannable);
            }
        }
        else {
            removeClass(container, panning);
            removeClass(container, pannable);
        }
    }
    onMouseDown({ e }) {
        if (!this.allowBlankMouseDown(e)) {
            return;
        }
        const selection = this.graph.getPlugin('selection');
        const allowRubberband = selection && selection.allowRubberband(e, true);
        if (this.allowPanning(e, true) ||
            (this.allowPanning(e) && !allowRubberband)) {
            this.startPanning(e);
        }
    }
    onRightMouseDown(e) {
        const eventTypes = this.widgetOptions.eventTypes;
        if (!((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('rightMouseDown')) && e.button === 2)) {
            return;
        }
        if (this.allowPanning(e, true)) {
            this.startPanning(e);
        }
    }
    onMouseWheel(e, deltaX, deltaY) {
        this.graph.translateBy(-deltaX, -deltaY);
    }
    onSpaceKeyDown(e) {
        if (e.which === 32) {
            this.isSpaceKeyPressed = true;
        }
    }
    onSpaceKeyUp(e) {
        if (e.which === 32) {
            this.isSpaceKeyPressed = false;
        }
    }
    allowBlankMouseDown(e) {
        const eventTypes = this.widgetOptions.eventTypes;
        return (((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('leftMouseDown')) && e.button === 0) ||
            ((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('mouseWheelDown')) && e.button === 1));
    }
    allowMouseWheel(e) {
        var _a;
        return (this.pannable &&
            !e.ctrlKey &&
            ((_a = this.widgetOptions.eventTypes) === null || _a === void 0 ? void 0 : _a.includes('mouseWheel')));
    }
    autoPanning(x, y) {
        const buffer = 10;
        const graphArea = this.graph.getGraphArea();
        let dx = 0;
        let dy = 0;
        if (x <= graphArea.left + buffer) {
            dx = -buffer;
        }
        if (y <= graphArea.top + buffer) {
            dy = -buffer;
        }
        if (x >= graphArea.right - buffer) {
            dx = buffer;
        }
        if (y >= graphArea.bottom - buffer) {
            dy = buffer;
        }
        if (dx !== 0 || dy !== 0) {
            this.graph.translateBy(-dx, -dy);
        }
    }
    enablePanning() {
        if (!this.pannable) {
            this.widgetOptions.enabled = true;
            this.updateClassName();
        }
    }
    disablePanning() {
        if (this.pannable) {
            this.widgetOptions.enabled = false;
            this.updateClassName();
        }
    }
    dispose() {
        this.stopListening();
    }
}
__decorate$8([
    Base.dispose()
], PanningManager.prototype, "dispose", null);

var __decorate$7 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MouseWheel extends Base {
    constructor() {
        super(...arguments);
        this.cumulatedFactor = 1;
    }
    get widgetOptions() {
        return this.options.mousewheel;
    }
    init() {
        this.container = this.graph.container;
        this.target = this.widgetOptions.global ? document : this.container;
        this.mousewheelHandle = new MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
        if (this.widgetOptions.enabled) {
            this.enable(true);
        }
    }
    get disabled() {
        return this.widgetOptions.enabled !== true;
    }
    enable(force) {
        if (this.disabled || force) {
            this.widgetOptions.enabled = true;
            this.mousewheelHandle.enable();
        }
    }
    disable() {
        if (!this.disabled) {
            this.widgetOptions.enabled = false;
            this.mousewheelHandle.disable();
        }
    }
    allowMouseWheel(e) {
        const guard = this.widgetOptions.guard;
        return ((guard == null || guard(e)) &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers));
    }
    onMouseWheel(e) {
        const guard = this.widgetOptions.guard;
        if ((guard == null || guard(e)) &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers)) {
            const factor = this.widgetOptions.factor || 1.2;
            if (this.currentScale == null) {
                this.startPos = { x: e.clientX, y: e.clientY };
                this.currentScale = this.graph.transform.getScale().sx;
            }
            const delta = e.deltaY;
            if (delta < 0) {
                // zoomin
                // ------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale < 0.15) {
                    this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
                    if (this.cumulatedFactor === 1) {
                        this.cumulatedFactor = 1.05;
                    }
                }
            }
            else {
                // zoomout
                // -------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale <= 0.15) {
                    this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * (1 / factor) * 20) /
                            20 /
                            this.currentScale;
                    if (this.cumulatedFactor === 1) {
                        this.cumulatedFactor = 0.95;
                    }
                }
            }
            this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) /
                this.currentScale);
            const currentScale = this.currentScale;
            let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
            const minScale = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER;
            const maxScale = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
            targetScale = clamp(targetScale, minScale, maxScale);
            if (targetScale !== currentScale) {
                if (this.widgetOptions.zoomAtMousePosition) {
                    const hasScroller = !!this.graph.getPlugin('scroller');
                    const origin = hasScroller
                        ? this.graph.clientToLocal(this.startPos)
                        : this.graph.clientToGraph(this.startPos);
                    this.graph.zoom(targetScale, {
                        absolute: true,
                        center: origin.clone(),
                    });
                }
                else {
                    this.graph.zoom(targetScale, { absolute: true });
                }
            }
            this.currentScale = null;
            this.cumulatedFactor = 1;
        }
    }
    dispose() {
        this.disable();
    }
}
__decorate$7([
    Disposable.dispose()
], MouseWheel.prototype, "dispose", null);

var __decorate$6 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class VirtualRenderManager extends Base {
    init() {
        this.resetRenderArea = throttle(this.resetRenderArea, 200, {
            leading: true,
        });
        this.resetRenderArea();
        this.startListening();
    }
    startListening() {
        this.graph.on('translate', this.resetRenderArea, this);
        this.graph.on('scale', this.resetRenderArea, this);
        this.graph.on('resize', this.resetRenderArea, this);
    }
    stopListening() {
        this.graph.off('translate', this.resetRenderArea, this);
        this.graph.off('scale', this.resetRenderArea, this);
        this.graph.off('resize', this.resetRenderArea, this);
    }
    enableVirtualRender() {
        this.options.virtual = true;
        this.resetRenderArea();
    }
    disableVirtualRender() {
        this.options.virtual = false;
        this.graph.renderer.setRenderArea(undefined);
    }
    resetRenderArea() {
        if (this.options.virtual) {
            const renderArea = this.graph.getGraphArea();
            this.graph.renderer.setRenderArea(renderArea);
        }
    }
    dispose() {
        this.stopListening();
    }
}
__decorate$6([
    Base.dispose()
], VirtualRenderManager.prototype, "dispose", null);

class JobQueue {
    constructor() {
        this.isFlushing = false;
        this.isFlushPending = false;
        this.scheduleId = 0;
        this.queue = [];
        this.frameInterval = 33;
        this.initialTime = Date.now();
    }
    queueJob(job) {
        if (job.priority & JOB_PRIORITY.PRIOR) {
            job.cb();
        }
        else {
            const index = this.findInsertionIndex(job);
            if (index >= 0) {
                this.queue.splice(index, 0, job);
            }
        }
    }
    queueFlush() {
        if (!this.isFlushing && !this.isFlushPending) {
            this.isFlushPending = true;
            this.scheduleJob();
        }
    }
    queueFlushSync() {
        if (!this.isFlushing && !this.isFlushPending) {
            this.isFlushPending = true;
            this.flushJobsSync();
        }
    }
    clearJobs() {
        this.queue.length = 0;
        this.isFlushing = false;
        this.isFlushPending = false;
        this.cancelScheduleJob();
    }
    flushJobs() {
        this.isFlushPending = false;
        this.isFlushing = true;
        const startTime = this.getCurrentTime();
        let job;
        while ((job = this.queue.shift())) {
            job.cb();
            if (this.getCurrentTime() - startTime >= this.frameInterval) {
                break;
            }
        }
        this.isFlushing = false;
        if (this.queue.length) {
            this.queueFlush();
        }
    }
    flushJobsSync() {
        this.isFlushPending = false;
        this.isFlushing = true;
        let job;
        while ((job = this.queue.shift())) {
            try {
                job.cb();
            }
            catch (error) {
                // eslint-disable-next-line
                console.log(error);
            }
        }
        this.isFlushing = false;
    }
    findInsertionIndex(job) {
        let left = 0;
        let ins = this.queue.length;
        let right = ins - 1;
        const priority = job.priority;
        while (left <= right) {
            const mid = ((right - left) >> 1) + left;
            if (priority <= this.queue[mid].priority) {
                left = mid + 1;
            }
            else {
                ins = mid;
                right = mid - 1;
            }
        }
        return ins;
    }
    scheduleJob() {
        if ('requestIdleCallback' in window) {
            if (this.scheduleId) {
                this.cancelScheduleJob();
            }
            this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
                timeout: 100,
            });
        }
        else {
            if (this.scheduleId) {
                this.cancelScheduleJob();
            }
            this.scheduleId = window.setTimeout(this.flushJobs.bind(this));
        }
    }
    cancelScheduleJob() {
        if ('cancelIdleCallback' in window) {
            if (this.scheduleId) {
                window.cancelIdleCallback(this.scheduleId);
            }
            this.scheduleId = 0;
        }
        else {
            if (this.scheduleId) {
                clearTimeout(this.scheduleId);
            }
            this.scheduleId = 0;
        }
    }
    getCurrentTime() {
        const hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
        if (hasPerformanceNow) {
            return performance.now();
        }
        return Date.now() - this.initialTime;
    }
}
var JOB_PRIORITY;
(function (JOB_PRIORITY) {
    JOB_PRIORITY[JOB_PRIORITY["Update"] = 2] = "Update";
    JOB_PRIORITY[JOB_PRIORITY["RenderEdge"] = 4] = "RenderEdge";
    JOB_PRIORITY[JOB_PRIORITY["RenderNode"] = 8] = "RenderNode";
    JOB_PRIORITY[JOB_PRIORITY["PRIOR"] = 1048576] = "PRIOR";
})(JOB_PRIORITY || (JOB_PRIORITY = {}));
// function findInsertionIndex(job: Job) {
//   let start = 0
//   for (let i = 0, len = queue.length; i < len; i += 1) {
//     const j = queue[i]
//     if (j.id === job.id) {
//       console.log('xx', j.bit, job.bit)
//     }
//     if (j.id === job.id && (job.bit ^ (job.bit & j.bit)) === 0) {
//       return -1
//     }
//     if (j.priority <= job.priority) {
//       start += 1
//     }
//   }
//   return start
// }

var __decorate$5 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Scheduler extends Disposable {
    get model() {
        return this.graph.model;
    }
    get container() {
        return this.graph.view.stage;
    }
    constructor(graph) {
        super();
        this.views = {};
        this.willRemoveViews = {};
        this.queue = new JobQueue();
        this.graph = graph;
        this.init();
    }
    init() {
        this.startListening();
        this.renderViews(this.model.getCells());
    }
    startListening() {
        this.model.on('reseted', this.onModelReseted, this);
        this.model.on('cell:added', this.onCellAdded, this);
        this.model.on('cell:removed', this.onCellRemoved, this);
        this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.on('cell:change:visible', this.onCellVisibleChanged, this);
    }
    stopListening() {
        this.model.off('reseted', this.onModelReseted, this);
        this.model.off('cell:added', this.onCellAdded, this);
        this.model.off('cell:removed', this.onCellRemoved, this);
        this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.off('cell:change:visible', this.onCellVisibleChanged, this);
    }
    onModelReseted({ options }) {
        this.queue.clearJobs();
        this.removeZPivots();
        this.resetViews();
        const cells = this.model.getCells();
        this.renderViews(cells, Object.assign(Object.assign({}, options), { queue: cells.map((cell) => cell.id) }));
    }
    onCellAdded({ cell, options }) {
        this.renderViews([cell], options);
    }
    onCellRemoved({ cell }) {
        this.removeViews([cell]);
    }
    onCellZIndexChanged({ cell, options, }) {
        const viewItem = this.views[cell.id];
        if (viewItem) {
            this.requestViewUpdate(viewItem.view, Scheduler.FLAG_INSERT, options, JOB_PRIORITY.Update, true);
        }
    }
    onCellVisibleChanged({ cell, current, }) {
        this.toggleVisible(cell, !!current);
    }
    requestViewUpdate(view, flag, options = {}, priority = JOB_PRIORITY.Update, flush = true) {
        const id = view.cell.id;
        const viewItem = this.views[id];
        if (!viewItem) {
            return;
        }
        viewItem.flag = flag;
        viewItem.options = options;
        const priorAction = view.hasAction(flag, ['translate', 'resize', 'rotate']);
        if (priorAction || options.async === false) {
            priority = JOB_PRIORITY.PRIOR; // eslint-disable-line
            flush = false; // eslint-disable-line
        }
        this.queue.queueJob({
            id,
            priority,
            cb: () => {
                this.renderViewInArea(view, flag, options);
                const queue = options.queue;
                if (queue) {
                    const index = queue.indexOf(view.cell.id);
                    if (index >= 0) {
                        queue.splice(index, 1);
                    }
                    if (queue.length === 0) {
                        this.graph.trigger('render:done');
                    }
                }
            },
        });
        const effectedEdges = this.getEffectedEdges(view);
        effectedEdges.forEach((edge) => {
            this.requestViewUpdate(edge.view, edge.flag, options, priority, false);
        });
        if (flush) {
            this.flush();
        }
    }
    setRenderArea(area) {
        this.renderArea = area;
        this.flushWaitingViews();
    }
    isViewMounted(view) {
        if (view == null) {
            return false;
        }
        const viewItem = this.views[view.cell.id];
        if (!viewItem) {
            return false;
        }
        return viewItem.state === Scheduler.ViewState.MOUNTED;
    }
    renderViews(cells, options = {}) {
        cells.sort((c1, c2) => {
            if (c1.isNode() && c2.isEdge()) {
                return -1;
            }
            return 0;
        });
        cells.forEach((cell) => {
            const id = cell.id;
            const views = this.views;
            let flag = 0;
            let viewItem = views[id];
            if (viewItem) {
                flag = Scheduler.FLAG_INSERT;
            }
            else {
                const cellView = this.createCellView(cell);
                if (cellView) {
                    cellView.graph = this.graph;
                    flag = Scheduler.FLAG_INSERT | cellView.getBootstrapFlag();
                    viewItem = {
                        view: cellView,
                        flag,
                        options,
                        state: Scheduler.ViewState.CREATED,
                    };
                    this.views[id] = viewItem;
                }
            }
            if (viewItem) {
                this.requestViewUpdate(viewItem.view, flag, options, this.getRenderPriority(viewItem.view), false);
            }
        });
        this.flush();
    }
    renderViewInArea(view, flag, options = {}) {
        const cell = view.cell;
        const id = cell.id;
        const viewItem = this.views[id];
        if (!viewItem) {
            return;
        }
        let result = 0;
        if (this.isUpdatable(view)) {
            result = this.updateView(view, flag, options);
            viewItem.flag = result;
        }
        else {
            if (viewItem.state === Scheduler.ViewState.MOUNTED) {
                result = this.updateView(view, flag, options);
                viewItem.flag = result;
            }
            else {
                viewItem.state = Scheduler.ViewState.WAITING;
            }
        }
        if (result) {
            if (cell.isEdge() &&
                (result & view.getFlag(['source', 'target'])) === 0) {
                this.queue.queueJob({
                    id,
                    priority: JOB_PRIORITY.RenderEdge,
                    cb: () => {
                        this.updateView(view, flag, options);
                    },
                });
            }
        }
    }
    removeViews(cells) {
        cells.forEach((cell) => {
            const id = cell.id;
            const viewItem = this.views[id];
            if (viewItem) {
                this.willRemoveViews[id] = viewItem;
                delete this.views[id];
                this.queue.queueJob({
                    id,
                    priority: this.getRenderPriority(viewItem.view),
                    cb: () => {
                        this.removeView(viewItem.view);
                    },
                });
            }
        });
        this.flush();
    }
    flush() {
        this.graph.options.async
            ? this.queue.queueFlush()
            : this.queue.queueFlushSync();
    }
    flushWaitingViews() {
        Object.values(this.views).forEach((viewItem) => {
            if (viewItem && viewItem.state === Scheduler.ViewState.WAITING) {
                const { view, flag, options } = viewItem;
                this.requestViewUpdate(view, flag, options, this.getRenderPriority(view), false);
            }
        });
        this.flush();
    }
    updateView(view, flag, options = {}) {
        if (view == null) {
            return 0;
        }
        if (CellView.isCellView(view)) {
            if (flag & Scheduler.FLAG_REMOVE) {
                this.removeView(view.cell);
                return 0;
            }
            if (flag & Scheduler.FLAG_INSERT) {
                this.insertView(view);
                flag ^= Scheduler.FLAG_INSERT; // eslint-disable-line
            }
        }
        if (!flag) {
            return 0;
        }
        return view.confirmUpdate(flag, options);
    }
    insertView(view) {
        const viewItem = this.views[view.cell.id];
        if (viewItem) {
            const zIndex = view.cell.getZIndex();
            const pivot = this.addZPivot(zIndex);
            this.container.insertBefore(view.container, pivot);
            if (!view.cell.isVisible()) {
                this.toggleVisible(view.cell, false);
            }
            viewItem.state = Scheduler.ViewState.MOUNTED;
            this.graph.trigger('view:mounted', { view });
        }
    }
    resetViews() {
        this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews);
        Object.values(this.willRemoveViews).forEach((viewItem) => {
            if (viewItem) {
                this.removeView(viewItem.view);
            }
        });
        this.views = {};
        this.willRemoveViews = {};
    }
    removeView(view) {
        const cell = view.cell;
        const viewItem = this.willRemoveViews[cell.id];
        if (viewItem && view) {
            viewItem.view.remove();
            delete this.willRemoveViews[cell.id];
            this.graph.trigger('view:unmounted', { view });
        }
    }
    toggleVisible(cell, visible) {
        const edges = this.model.getConnectedEdges(cell);
        for (let i = 0, len = edges.length; i < len; i += 1) {
            const edge = edges[i];
            if (visible) {
                const source = edge.getSourceCell();
                const target = edge.getTargetCell();
                if ((source && !source.isVisible()) ||
                    (target && !target.isVisible())) {
                    continue;
                }
                this.toggleVisible(edge, true);
            }
            else {
                this.toggleVisible(edge, false);
            }
        }
        const viewItem = this.views[cell.id];
        if (viewItem) {
            css(viewItem.view.container, {
                display: visible ? 'unset' : 'none',
            });
        }
    }
    addZPivot(zIndex = 0) {
        if (this.zPivots == null) {
            this.zPivots = {};
        }
        const pivots = this.zPivots;
        let pivot = pivots[zIndex];
        if (pivot) {
            return pivot;
        }
        pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
        let neighborZ = -Infinity;
        // eslint-disable-next-line
        for (const key in pivots) {
            const currentZ = +key;
            if (currentZ < zIndex && currentZ > neighborZ) {
                neighborZ = currentZ;
                if (neighborZ === zIndex - 1) {
                    continue;
                }
            }
        }
        const layer = this.container;
        if (neighborZ !== -Infinity) {
            const neighborPivot = pivots[neighborZ];
            layer.insertBefore(pivot, neighborPivot.nextSibling);
        }
        else {
            layer.insertBefore(pivot, layer.firstChild);
        }
        return pivot;
    }
    removeZPivots() {
        if (this.zPivots) {
            Object.values(this.zPivots).forEach((elem) => {
                if (elem && elem.parentNode) {
                    elem.parentNode.removeChild(elem);
                }
            });
        }
        this.zPivots = {};
    }
    createCellView(cell) {
        const options = { graph: this.graph };
        const createViewHook = this.graph.options.createCellView;
        if (createViewHook) {
            const ret = call$1(createViewHook, this.graph, cell);
            if (ret) {
                return new ret(cell, options); // eslint-disable-line new-cap
            }
            if (ret === null) {
                // null means not render
                return null;
            }
        }
        const view = cell.view;
        if (view != null && typeof view === 'string') {
            const def = CellView.registry.get(view);
            if (def) {
                return new def(cell, options); // eslint-disable-line new-cap
            }
            return CellView.registry.onNotFound(view);
        }
        if (cell.isNode()) {
            return new NodeView(cell, options);
        }
        if (cell.isEdge()) {
            return new EdgeView(cell, options);
        }
        return null;
    }
    getEffectedEdges(view) {
        const effectedEdges = [];
        const cell = view.cell;
        const edges = this.model.getConnectedEdges(cell);
        for (let i = 0, n = edges.length; i < n; i += 1) {
            const edge = edges[i];
            const viewItem = this.views[edge.id];
            if (!viewItem) {
                continue;
            }
            const edgeView = viewItem.view;
            if (!this.isViewMounted(edgeView)) {
                continue;
            }
            const flagLabels = ['update'];
            if (edge.getTargetCell() === cell) {
                flagLabels.push('target');
            }
            if (edge.getSourceCell() === cell) {
                flagLabels.push('source');
            }
            effectedEdges.push({
                id: edge.id,
                view: edgeView,
                flag: edgeView.getFlag(flagLabels),
            });
        }
        return effectedEdges;
    }
    isUpdatable(view) {
        if (view.isNodeView()) {
            if (this.renderArea) {
                return this.renderArea.isIntersectWithRect(view.cell.getBBox());
            }
            return true;
        }
        if (view.isEdgeView()) {
            const edge = view.cell;
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (this.renderArea && sourceCell && targetCell) {
                return (this.renderArea.isIntersectWithRect(sourceCell.getBBox()) ||
                    this.renderArea.isIntersectWithRect(targetCell.getBBox()));
            }
        }
        return true;
    }
    getRenderPriority(view) {
        return view.cell.isNode()
            ? JOB_PRIORITY.RenderNode
            : JOB_PRIORITY.RenderEdge;
    }
    dispose() {
        this.stopListening();
        // clear views
        Object.keys(this.views).forEach((id) => {
            this.views[id].view.dispose();
        });
        this.views = {};
    }
}
__decorate$5([
    Disposable.dispose()
], Scheduler.prototype, "dispose", null);
(function (Scheduler) {
    Scheduler.FLAG_INSERT = 1 << 30;
    Scheduler.FLAG_REMOVE = 1 << 29;
    Scheduler.FLAG_RENDER = (1 << 26) - 1;
})(Scheduler || (Scheduler = {}));
(function (Scheduler) {
    (function (ViewState) {
        ViewState[ViewState["CREATED"] = 0] = "CREATED";
        ViewState[ViewState["MOUNTED"] = 1] = "MOUNTED";
        ViewState[ViewState["WAITING"] = 2] = "WAITING";
    })(Scheduler.ViewState || (Scheduler.ViewState = {}));
})(Scheduler || (Scheduler = {}));

var __decorate$4 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Renderer extends Base {
    constructor() {
        super(...arguments);
        this.schedule = new Scheduler(this.graph);
    }
    requestViewUpdate(view, flag, options = {}) {
        this.schedule.requestViewUpdate(view, flag, options);
    }
    isViewMounted(view) {
        return this.schedule.isViewMounted(view);
    }
    setRenderArea(area) {
        this.schedule.setRenderArea(area);
    }
    findViewByElem(elem) {
        if (elem == null) {
            return null;
        }
        const container = this.options.container;
        const target = typeof elem === 'string'
            ? container.querySelector(elem)
            : elem instanceof Element
                ? elem
                : elem[0];
        if (target) {
            const id = this.graph.view.findAttr('data-cell-id', target);
            if (id) {
                const views = this.schedule.views;
                if (views[id]) {
                    return views[id].view;
                }
            }
        }
        return null;
    }
    findViewByCell(cell) {
        if (cell == null) {
            return null;
        }
        const id = Cell.isCell(cell) ? cell.id : cell;
        const views = this.schedule.views;
        if (views[id]) {
            return views[id].view;
        }
        return null;
    }
    findViewsFromPoint(p) {
        const ref = { x: p.x, y: p.y };
        return this.model
            .getCells()
            .map((cell) => this.findViewByCell(cell))
            .filter((view) => {
            if (view != null) {
                return Util.getBBox(view.container, {
                    target: this.view.stage,
                }).containsPoint(ref);
            }
            return false;
        });
    }
    findEdgeViewsFromPoint(p, threshold = 5) {
        return this.model
            .getEdges()
            .map((edge) => this.findViewByCell(edge))
            .filter((view) => {
            if (view != null) {
                const point = view.getClosestPoint(p);
                if (point) {
                    return point.distance(p) <= threshold;
                }
            }
            return false;
        });
    }
    findViewsInArea(rect, options = {}) {
        const area = Rectangle.create(rect);
        return this.model
            .getCells()
            .map((cell) => this.findViewByCell(cell))
            .filter((view) => {
            if (view) {
                if (options.nodeOnly && !view.isNodeView()) {
                    return false;
                }
                const bbox = Util.getBBox(view.container, {
                    target: this.view.stage,
                });
                if (bbox.width === 0) {
                    bbox.inflate(1, 0);
                }
                else if (bbox.height === 0) {
                    bbox.inflate(0, 1);
                }
                return options.strict
                    ? area.containsRect(bbox)
                    : area.isIntersectWithRect(bbox);
            }
            return false;
        });
    }
    dispose() {
        this.schedule.dispose();
    }
}
__decorate$4([
    Base.dispose()
], Renderer.prototype, "dispose", null);

var __rest$1 = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class DefsManager extends Base {
    get cid() {
        return this.graph.view.cid;
    }
    get svg() {
        return this.view.svg;
    }
    get defs() {
        return this.view.defs;
    }
    isDefined(id) {
        return this.svg.getElementById(id) != null;
    }
    filter(options) {
        let filterId = options.id;
        const name = options.name;
        if (!filterId) {
            filterId = `filter-${name}-${this.cid}-${hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(filterId)) {
            const fn = Filter.registry.get(name);
            if (fn == null) {
                return Filter.registry.onNotFound(name);
            }
            const markup = fn(options.args || {});
            // Set the filter area to be 3x the bounding box of the cell
            // and center the filter around the cell.
            const attrs = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: 'objectBoundingBox' }, options.attrs), { id: filterId });
            Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs);
        }
        return filterId;
    }
    gradient(options) {
        let id = options.id;
        const type = options.type;
        if (!id) {
            id = `gradient-${type}-${this.cid}-${hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(id)) {
            const stops = options.stops;
            const arr = stops.map((stop) => {
                const opacity = stop.opacity != null && Number.isFinite(stop.opacity)
                    ? stop.opacity
                    : 1;
                return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity}"/>`;
            });
            const markup = `<${type}>${arr.join('')}</${type}>`;
            const attrs = Object.assign({ id }, options.attrs);
            Vector.create(markup, attrs).appendTo(this.defs);
        }
        return id;
    }
    marker(options) {
        const { id, refX, refY, markerUnits, markerOrient, tagName, children } = options, attrs = __rest$1(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
        let markerId = id;
        if (!markerId) {
            markerId = `marker-${this.cid}-${hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(markerId)) {
            if (tagName !== 'path') {
                // remove unnecessary d attribute inherit from standard edge.
                delete attrs.d;
            }
            const pathMarker = Vector.create('marker', {
                refX,
                refY,
                id: markerId,
                overflow: 'visible',
                orient: markerOrient != null ? markerOrient : 'auto',
                markerUnits: markerUnits || 'userSpaceOnUse',
            }, children
                ? children.map((_a) => {
                    var { tagName } = _a, other = __rest$1(_a, ["tagName"]);
                    return Vector.create(`${tagName}` || 'path', kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
                })
                : [Vector.create(tagName || 'path', kebablizeAttrs(attrs))]);
            this.defs.appendChild(pathMarker.node);
        }
        return markerId;
    }
    remove(id) {
        const elem = this.svg.getElementById(id);
        if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }
}

class CoordManager extends Base {
    getClientMatrix() {
        return createSVGMatrix(this.view.stage.getScreenCTM());
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */
    getClientOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        const rect = this.view.svg.getBoundingClientRect();
        return new Point(rect.left, rect.top);
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */
    getPageOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        return this.getClientOffset().translate(window.scrollX, window.scrollY);
    }
    snapToGrid(x, y) {
        const p = typeof x === 'number'
            ? this.clientToLocalPoint(x, y)
            : this.clientToLocalPoint(x.x, x.y);
        return p.snapToGrid(this.graph.getGridSize());
    }
    localToGraphPoint(x, y) {
        const localPoint = Point.create(x, y);
        return Util.transformPoint(localPoint, this.graph.matrix());
    }
    localToClientPoint(x, y) {
        const localPoint = Point.create(x, y);
        return Util.transformPoint(localPoint, this.getClientMatrix());
    }
    localToPagePoint(x, y) {
        const p = typeof x === 'number'
            ? this.localToGraphPoint(x, y)
            : this.localToGraphPoint(x);
        return p.translate(this.getPageOffset());
    }
    localToGraphRect(x, y, width, height) {
        const localRect = Rectangle.create(x, y, width, height);
        return Util.transformRectangle(localRect, this.graph.matrix());
    }
    localToClientRect(x, y, width, height) {
        const localRect = Rectangle.create(x, y, width, height);
        return Util.transformRectangle(localRect, this.getClientMatrix());
    }
    localToPageRect(x, y, width, height) {
        const rect = typeof x === 'number'
            ? this.localToGraphRect(x, y, width, height)
            : this.localToGraphRect(x);
        return rect.translate(this.getPageOffset());
    }
    graphToLocalPoint(x, y) {
        const graphPoint = Point.create(x, y);
        return Util.transformPoint(graphPoint, this.graph.matrix().inverse());
    }
    clientToLocalPoint(x, y) {
        const clientPoint = Point.create(x, y);
        return Util.transformPoint(clientPoint, this.getClientMatrix().inverse());
    }
    clientToGraphPoint(x, y) {
        const clientPoint = Point.create(x, y);
        return Util.transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalPoint(x, y) {
        const pagePoint = Point.create(x, y);
        const graphPoint = pagePoint.diff(this.getPageOffset());
        return this.graphToLocalPoint(graphPoint);
    }
    graphToLocalRect(x, y, width, height) {
        const graphRect = Rectangle.create(x, y, width, height);
        return Util.transformRectangle(graphRect, this.graph.matrix().inverse());
    }
    clientToLocalRect(x, y, width, height) {
        const clientRect = Rectangle.create(x, y, width, height);
        return Util.transformRectangle(clientRect, this.getClientMatrix().inverse());
    }
    clientToGraphRect(x, y, width, height) {
        const clientRect = Rectangle.create(x, y, width, height);
        return Util.transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalRect(x, y, width, height) {
        const graphRect = Rectangle.create(x, y, width, height);
        const pageOffset = this.getPageOffset();
        graphRect.x -= pageOffset.x;
        graphRect.y -= pageOffset.y;
        return this.graphToLocalRect(graphRect);
    }
}

var __decorate$3 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class HighlightManager extends Base {
    constructor() {
        super(...arguments);
        this.highlights = {};
    }
    init() {
        this.startListening();
    }
    startListening() {
        this.graph.on('cell:highlight', this.onCellHighlight, this);
        this.graph.on('cell:unhighlight', this.onCellUnhighlight, this);
    }
    stopListening() {
        this.graph.off('cell:highlight', this.onCellHighlight, this);
        this.graph.off('cell:unhighlight', this.onCellUnhighlight, this);
    }
    onCellHighlight({ view: cellView, magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const key = this.getHighlighterId(magnet, resolved);
        if (!this.highlights[key]) {
            const highlighter = resolved.highlighter;
            highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
            this.highlights[key] = {
                cellView,
                magnet,
                highlighter,
                args: resolved.args,
            };
        }
    }
    onCellUnhighlight({ magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const id = this.getHighlighterId(magnet, resolved);
        this.unhighlight(id);
    }
    resolveHighlighter(options) {
        const graphOptions = this.options;
        let highlighterDef = options.highlighter;
        if (highlighterDef == null) {
            // check for built-in types
            const type = options.type;
            highlighterDef =
                (type && graphOptions.highlighting[type]) ||
                    graphOptions.highlighting.default;
        }
        if (highlighterDef == null) {
            return null;
        }
        const def = typeof highlighterDef === 'string'
            ? {
                name: highlighterDef,
            }
            : highlighterDef;
        const name = def.name;
        const highlighter = Highlighter.registry.get(name);
        if (highlighter == null) {
            return Highlighter.registry.onNotFound(name);
        }
        Highlighter.check(name, highlighter);
        return {
            name,
            highlighter,
            args: def.args || {},
        };
    }
    getHighlighterId(magnet, options) {
        ensureId(magnet);
        return options.name + magnet.id + JSON.stringify(options.args);
    }
    unhighlight(id) {
        const highlight = this.highlights[id];
        if (highlight) {
            highlight.highlighter.unhighlight(highlight.cellView, highlight.magnet, highlight.args);
            delete this.highlights[id];
        }
    }
    dispose() {
        Object.keys(this.highlights).forEach((id) => this.unhighlight(id));
        this.stopListening();
    }
}
__decorate$3([
    HighlightManager.dispose()
], HighlightManager.prototype, "dispose", null);

var __decorate$2 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SizeManager extends Base {
    getScroller() {
        const scroller = this.graph.getPlugin('scroller');
        if (scroller && scroller.options.enabled) {
            return scroller;
        }
        return null;
    }
    getContainer() {
        const scroller = this.getScroller();
        if (scroller) {
            return scroller.container.parentElement;
        }
        return this.graph.container.parentElement;
    }
    getSensorTarget() {
        const autoResize = this.options.autoResize;
        if (autoResize) {
            if (typeof autoResize === 'boolean') {
                return this.getContainer();
            }
            return autoResize;
        }
    }
    init() {
        const autoResize = this.options.autoResize;
        if (autoResize) {
            const target = this.getSensorTarget();
            if (target) {
                SizeSensor.bind(target, () => {
                    const width = target.offsetWidth;
                    const height = target.offsetHeight;
                    this.resize(width, height);
                });
            }
        }
    }
    resize(width, height) {
        const scroller = this.getScroller();
        if (scroller) {
            scroller.resize(width, height);
        }
        else {
            this.graph.transform.resize(width, height);
        }
    }
    dispose() {
        SizeSensor.clear(this.graph.container);
    }
}
__decorate$2([
    Base.dispose()
], SizeManager.prototype, "dispose", null);

var __decorate$1 = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Graph extends Basecoat {
    get container() {
        return this.options.container;
    }
    get [Symbol.toStringTag]() {
        return Graph.toStringTag;
    }
    constructor(options) {
        super();
        this.installedPlugins = new Set();
        this.options = Options.get(options);
        this.css = new CSSManager(this);
        this.view = new GraphView(this);
        this.defs = new DefsManager(this);
        this.coord = new CoordManager(this);
        this.transform = new TransformManager(this);
        this.highlight = new HighlightManager(this);
        this.grid = new GridManager(this);
        this.background = new BackgroundManager(this);
        if (this.options.model) {
            this.model = this.options.model;
        }
        else {
            this.model = new Model();
            this.model.graph = this;
        }
        this.renderer = new Renderer(this);
        this.panning = new PanningManager(this);
        this.mousewheel = new MouseWheel(this);
        this.virtualRender = new VirtualRenderManager(this);
        this.size = new SizeManager(this);
    }
    // #region model
    isNode(cell) {
        return cell.isNode();
    }
    isEdge(cell) {
        return cell.isEdge();
    }
    resetCells(cells, options = {}) {
        this.model.resetCells(cells, options);
        return this;
    }
    clearCells(options = {}) {
        this.model.clear(options);
        return this;
    }
    toJSON(options = {}) {
        return this.model.toJSON(options);
    }
    parseJSON(data) {
        return this.model.parseJSON(data);
    }
    fromJSON(data, options = {}) {
        this.model.fromJSON(data, options);
        return this;
    }
    getCellById(id) {
        return this.model.getCell(id);
    }
    addNode(node, options = {}) {
        return this.model.addNode(node, options);
    }
    addNodes(nodes, options = {}) {
        return this.addCell(nodes.map((node) => (Node$1.isNode(node) ? node : this.createNode(node))), options);
    }
    createNode(metadata) {
        return this.model.createNode(metadata);
    }
    removeNode(node, options = {}) {
        return this.model.removeCell(node, options);
    }
    addEdge(edge, options = {}) {
        return this.model.addEdge(edge, options);
    }
    addEdges(edges, options = {}) {
        return this.addCell(edges.map((edge) => (Edge$1.isEdge(edge) ? edge : this.createEdge(edge))), options);
    }
    removeEdge(edge, options = {}) {
        return this.model.removeCell(edge, options);
    }
    createEdge(metadata) {
        return this.model.createEdge(metadata);
    }
    addCell(cell, options = {}) {
        this.model.addCell(cell, options);
        return this;
    }
    removeCell(cell, options = {}) {
        return this.model.removeCell(cell, options);
    }
    removeCells(cells, options = {}) {
        return this.model.removeCells(cells, options);
    }
    removeConnectedEdges(cell, options = {}) {
        return this.model.removeConnectedEdges(cell, options);
    }
    disconnectConnectedEdges(cell, options = {}) {
        this.model.disconnectConnectedEdges(cell, options);
        return this;
    }
    hasCell(cell) {
        return this.model.has(cell);
    }
    getCells() {
        return this.model.getCells();
    }
    getCellCount() {
        return this.model.total();
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.model.getNodes();
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.model.getEdges();
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        return this.model.getOutgoingEdges(cell);
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        return this.model.getIncomingEdges(cell);
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        return this.model.getConnectedEdges(cell, options);
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRootNodes() {
        return this.model.getRoots();
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafNodes() {
        return this.model.getLeafs();
    }
    /**
     * Returns `true` if the node is a root node, i.e.
     * there is no  edges coming to the node.
     */
    isRootNode(cell) {
        return this.model.isRoot(cell);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e.
     * there is no edges going out from the node.
     */
    isLeafNode(cell) {
        return this.model.isLeaf(cell);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        return this.model.getNeighbors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        return this.model.isNeighbor(cell1, cell2, options);
    }
    getSuccessors(cell, options = {}) {
        return this.model.getSuccessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        return this.model.isSuccessor(cell1, cell2, options);
    }
    getPredecessors(cell, options = {}) {
        return this.model.getPredecessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        return this.model.isPredecessor(cell1, cell2, options);
    }
    getCommonAncestor(...cells) {
        return this.model.getCommonAncestor(...cells);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        return this.model.getSubGraph(cells, options);
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        return this.model.cloneSubGraph(cells, options);
    }
    cloneCells(cells) {
        return this.model.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        return this.model.getNodesFromPoint(x, y);
    }
    getNodesInArea(x, y, w, h, options) {
        return this.model.getNodesInArea(x, y, w, h, options);
    }
    getNodesUnderNode(node, options = {}) {
        return this.model.getNodesUnderNode(node, options);
    }
    searchCell(cell, iterator, options = {}) {
        this.model.search(cell, iterator, options);
        return this;
    }
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        return this.model.getShortestPath(source, target, options);
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.model.getAllCellsBBox();
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return this.model.getCellsBBox(cells, options);
    }
    startBatch(name, data = {}) {
        this.model.startBatch(name, data);
    }
    stopBatch(name, data = {}) {
        this.model.stopBatch(name, data);
    }
    batchUpdate(arg1, arg2, arg3) {
        const name = typeof arg1 === 'string' ? arg1 : 'update';
        const execute = typeof arg1 === 'string' ? arg2 : arg1;
        const data = typeof arg2 === 'function' ? arg3 : arg2;
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    updateCellId(cell, newId) {
        return this.model.updateCellId(cell, newId);
    }
    // #endregion
    // #region view
    findView(ref) {
        if (Cell.isCell(ref)) {
            return this.findViewByCell(ref);
        }
        return this.findViewByElem(ref);
    }
    findViews(ref) {
        if (Rectangle.isRectangleLike(ref)) {
            return this.findViewsInArea(ref);
        }
        if (Point.isPointLike(ref)) {
            return this.findViewsFromPoint(ref);
        }
        return [];
    }
    findViewByCell(cell) {
        return this.renderer.findViewByCell(cell);
    }
    findViewByElem(elem) {
        return this.renderer.findViewByElem(elem);
    }
    findViewsFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y } : x;
        return this.renderer.findViewsFromPoint(p);
    }
    findViewsInArea(x, y, width, height, options) {
        const rect = typeof x === 'number'
            ? {
                x,
                y: y,
                width: width,
                height: height,
            }
            : x;
        const localOptions = typeof x === 'number'
            ? options
            : y;
        return this.renderer.findViewsInArea(rect, localOptions);
    }
    matrix(mat) {
        if (typeof mat === 'undefined') {
            return this.transform.getMatrix();
        }
        this.transform.setMatrix(mat);
        return this;
    }
    resize(width, height) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.resize(width, height);
        }
        else {
            this.transform.resize(width, height);
        }
        return this;
    }
    scale(sx, sy = sx, cx = 0, cy = 0) {
        if (typeof sx === 'undefined') {
            return this.transform.getScale();
        }
        this.transform.scale(sx, sy, cx, cy);
        return this;
    }
    zoom(factor, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            if (typeof factor === 'undefined') {
                return scroller.zoom();
            }
            scroller.zoom(factor, options);
        }
        else {
            if (typeof factor === 'undefined') {
                return this.transform.getZoom();
            }
            this.transform.zoom(factor, options);
        }
        return this;
    }
    zoomTo(factor, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        else {
            this.transform.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        return this;
    }
    zoomToRect(rect, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoomToRect(rect, options);
        }
        else {
            this.transform.zoomToRect(rect, options);
        }
        return this;
    }
    zoomToFit(options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoomToFit(options);
        }
        else {
            this.transform.zoomToFit(options);
        }
        return this;
    }
    rotate(angle, cx, cy) {
        if (typeof angle === 'undefined') {
            return this.transform.getRotation();
        }
        this.transform.rotate(angle, cx, cy);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'undefined') {
            return this.transform.getTranslation();
        }
        this.transform.translate(tx, ty);
        return this;
    }
    translateBy(dx, dy) {
        const ts = this.translate();
        const tx = ts.tx + dx;
        const ty = ts.ty + dy;
        return this.translate(tx, ty);
    }
    getGraphArea() {
        return this.transform.getGraphArea();
    }
    getContentArea(options = {}) {
        return this.transform.getContentArea(options);
    }
    getContentBBox(options = {}) {
        return this.transform.getContentBBox(options);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
    }
    scaleContentToFit(options = {}) {
        this.transform.scaleContentToFit(options);
        return this;
    }
    /**
     * Position the center of graph to the center of the viewport.
     */
    center(options) {
        return this.centerPoint(options);
    }
    centerPoint(x, y, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerPoint(x, y, options);
        }
        else {
            this.transform.centerPoint(x, y);
        }
        return this;
    }
    centerContent(options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerContent(options);
        }
        else {
            this.transform.centerContent(options);
        }
        return this;
    }
    centerCell(cell, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerCell(cell, options);
        }
        else {
            this.transform.centerCell(cell);
        }
        return this;
    }
    positionPoint(point, x, y, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionPoint(point, x, y, options);
        }
        else {
            this.transform.positionPoint(point, x, y);
        }
        return this;
    }
    positionRect(rect, direction, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionRect(rect, direction, options);
        }
        else {
            this.transform.positionRect(rect, direction);
        }
        return this;
    }
    positionCell(cell, direction, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionCell(cell, direction, options);
        }
        else {
            this.transform.positionCell(cell, direction);
        }
        return this;
    }
    positionContent(pos, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionContent(pos, options);
        }
        else {
            this.transform.positionContent(pos, options);
        }
        return this;
    }
    snapToGrid(x, y) {
        return this.coord.snapToGrid(x, y);
    }
    pageToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.pageToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.pageToLocalRect(x, y, width, height);
        }
        return this.coord.pageToLocalPoint(x, y);
    }
    localToPage(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToPageRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToPageRect(x, y, width, height);
        }
        return this.coord.localToPagePoint(x, y);
    }
    clientToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.clientToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToLocalRect(x, y, width, height);
        }
        return this.coord.clientToLocalPoint(x, y);
    }
    localToClient(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToClientRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToClientRect(x, y, width, height);
        }
        return this.coord.localToClientPoint(x, y);
    }
    localToGraph(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToGraphRect(x, y, width, height);
        }
        return this.coord.localToGraphPoint(x, y);
    }
    graphToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.graphToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.graphToLocalRect(x, y, width, height);
        }
        return this.coord.graphToLocalPoint(x, y);
    }
    clientToGraph(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.clientToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToGraphRect(x, y, width, height);
        }
        return this.coord.clientToGraphPoint(x, y);
    }
    // #endregion
    // #region defs
    defineFilter(options) {
        return this.defs.filter(options);
    }
    defineGradient(options) {
        return this.defs.gradient(options);
    }
    defineMarker(options) {
        return this.defs.marker(options);
    }
    // #endregion
    // #region grid
    getGridSize() {
        return this.grid.getGridSize();
    }
    setGridSize(gridSize) {
        this.grid.setGridSize(gridSize);
        return this;
    }
    showGrid() {
        this.grid.show();
        return this;
    }
    hideGrid() {
        this.grid.hide();
        return this;
    }
    clearGrid() {
        this.grid.clear();
        return this;
    }
    drawGrid(options) {
        this.grid.draw(options);
        return this;
    }
    // #endregion
    // #region background
    updateBackground() {
        this.background.update();
        return this;
    }
    drawBackground(options, onGraph) {
        const scroller = this.getPlugin('scroller');
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.drawBackground(options, onGraph);
        }
        else {
            this.background.draw(options);
        }
        return this;
    }
    clearBackground(onGraph) {
        const scroller = this.getPlugin('scroller');
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.clearBackground(onGraph);
        }
        else {
            this.background.clear();
        }
        return this;
    }
    // #endregion
    // #region virtual-render
    enableVirtualRender() {
        this.virtualRender.enableVirtualRender();
        return this;
    }
    disableVirtualRender() {
        this.virtualRender.disableVirtualRender();
        return this;
    }
    // #endregion
    // #region mousewheel
    isMouseWheelEnabled() {
        return !this.mousewheel.disabled;
    }
    enableMouseWheel() {
        this.mousewheel.enable();
        return this;
    }
    disableMouseWheel() {
        this.mousewheel.disable();
        return this;
    }
    toggleMouseWheel(enabled) {
        if (enabled == null) {
            if (this.isMouseWheelEnabled()) {
                this.disableMouseWheel();
            }
            else {
                this.enableMouseWheel();
            }
        }
        else if (enabled) {
            this.enableMouseWheel();
        }
        else {
            this.disableMouseWheel();
        }
        return this;
    }
    // #endregion
    // #region panning
    isPannable() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            return scroller.isPannable();
        }
        return this.panning.pannable;
    }
    enablePanning() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.enablePanning();
        }
        else {
            this.panning.enablePanning();
        }
        return this;
    }
    disablePanning() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.disablePanning();
        }
        else {
            this.panning.disablePanning();
        }
        return this;
    }
    togglePanning(pannable) {
        if (pannable == null) {
            if (this.isPannable()) {
                this.disablePanning();
            }
            else {
                this.enablePanning();
            }
        }
        else if (pannable !== this.isPannable()) {
            if (pannable) {
                this.enablePanning();
            }
            else {
                this.disablePanning();
            }
        }
        return this;
    }
    // #endregion
    // #region plugin
    use(plugin, ...options) {
        if (!this.installedPlugins.has(plugin)) {
            this.installedPlugins.add(plugin);
            plugin.init(this, ...options);
        }
        return this;
    }
    getPlugin(pluginName) {
        return Array.from(this.installedPlugins).find((plugin) => plugin.name === pluginName);
    }
    getPlugins(pluginName) {
        return Array.from(this.installedPlugins).filter((plugin) => pluginName.includes(plugin.name));
    }
    enablePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            var _a;
            (_a = plugin === null || plugin === void 0 ? void 0 : plugin.enable) === null || _a === void 0 ? void 0 : _a.call(plugin);
        });
        return this;
    }
    disablePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            var _a;
            (_a = plugin === null || plugin === void 0 ? void 0 : plugin.disable) === null || _a === void 0 ? void 0 : _a.call(plugin);
        });
        return this;
    }
    isPluginEnabled(pluginName) {
        var _a;
        const pluginIns = this.getPlugin(pluginName);
        return (_a = pluginIns === null || pluginIns === void 0 ? void 0 : pluginIns.isEnabled) === null || _a === void 0 ? void 0 : _a.call(pluginIns);
    }
    disposePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            plugin.dispose();
            this.installedPlugins.delete(plugin);
        });
        return this;
    }
    // #endregion
    // #region dispose
    dispose(clean = true) {
        if (clean) {
            this.model.dispose();
        }
        this.css.dispose();
        this.defs.dispose();
        this.grid.dispose();
        this.coord.dispose();
        this.transform.dispose();
        this.highlight.dispose();
        this.background.dispose();
        this.mousewheel.dispose();
        this.panning.dispose();
        this.view.dispose();
        this.renderer.dispose();
        this.installedPlugins.forEach((plugin) => {
            plugin.dispose();
        });
    }
}
__decorate$1([
    Basecoat.dispose()
], Graph.prototype, "dispose", null);
(function (Graph) {
    /* eslint-disable @typescript-eslint/no-unused-vars */
    Graph.View = GraphView;
    Graph.Renderer = Renderer;
    Graph.MouseWheel = MouseWheel;
    Graph.DefsManager = DefsManager;
    Graph.GridManager = GridManager;
    Graph.CoordManager = CoordManager;
    Graph.TransformManager = TransformManager;
    Graph.HighlightManager = HighlightManager;
    Graph.BackgroundManager = BackgroundManager;
    Graph.PanningManager = PanningManager;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.toStringTag = `X6.${Graph.name}`;
    function isGraph(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Graph) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        if (tag == null || tag === Graph.toStringTag) {
            return true;
        }
        return false;
    }
    Graph.isGraph = isGraph;
})(Graph || (Graph = {}));
(function (Graph) {
    function render(options, data) {
        const graph = options instanceof HTMLElement
            ? new Graph({ container: options })
            : new Graph(options);
        if (data != null) {
            graph.fromJSON(data);
        }
        return graph;
    }
    Graph.render = render;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.registerNode = Node$1.registry.register;
    Graph.registerEdge = Edge$1.registry.register;
    Graph.registerView = CellView.registry.register;
    Graph.registerAttr = Attr.registry.register;
    Graph.registerGrid = Grid.registry.register;
    Graph.registerFilter = Filter.registry.register;
    Graph.registerNodeTool = NodeTool.registry.register;
    Graph.registerEdgeTool = EdgeTool.registry.register;
    Graph.registerBackground = Background.registry.register;
    Graph.registerHighlighter = Highlighter.registry.register;
    Graph.registerPortLayout = PortLayout.registry.register;
    Graph.registerPortLabelLayout = PortLabelLayout.registry.register;
    Graph.registerMarker = Marker.registry.register;
    Graph.registerRouter = Router.registry.register;
    Graph.registerConnector = Connector.registry.register;
    Graph.registerAnchor = NodeAnchor.registry.register;
    Graph.registerEdgeAnchor = EdgeAnchor.registry.register;
    Graph.registerConnectionPoint = ConnectionPoint.registry.register;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.unregisterNode = Node$1.registry.unregister;
    Graph.unregisterEdge = Edge$1.registry.unregister;
    Graph.unregisterView = CellView.registry.unregister;
    Graph.unregisterAttr = Attr.registry.unregister;
    Graph.unregisterGrid = Grid.registry.unregister;
    Graph.unregisterFilter = Filter.registry.unregister;
    Graph.unregisterNodeTool = NodeTool.registry.unregister;
    Graph.unregisterEdgeTool = EdgeTool.registry.unregister;
    Graph.unregisterBackground = Background.registry.unregister;
    Graph.unregisterHighlighter = Highlighter.registry.unregister;
    Graph.unregisterPortLayout = PortLayout.registry.unregister;
    Graph.unregisterPortLabelLayout = PortLabelLayout.registry.unregister;
    Graph.unregisterMarker = Marker.registry.unregister;
    Graph.unregisterRouter = Router.registry.unregister;
    Graph.unregisterConnector = Connector.registry.unregister;
    Graph.unregisterAnchor = NodeAnchor.registry.unregister;
    Graph.unregisterEdgeAnchor = EdgeAnchor.registry.unregister;
    Graph.unregisterConnectionPoint = ConnectionPoint.registry.unregister;
})(Graph || (Graph = {}));

var __decorate = (globalThis && globalThis.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (globalThis && globalThis.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class HTML extends Node$1 {
}
(function (HTML) {
    class View extends NodeView {
        init() {
            super.init();
            this.cell.on('change:*', this.onCellChangeAny, this);
        }
        onCellChangeAny({ key }) {
            const content = HTML.shapeMaps[this.cell.shape];
            if (content) {
                const { effect } = content;
                if (!effect || effect.includes(key)) {
                    this.renderHTMLComponent();
                }
            }
        }
        confirmUpdate(flag) {
            const ret = super.confirmUpdate(flag);
            return this.handleAction(ret, View.action, () => this.renderHTMLComponent());
        }
        renderHTMLComponent() {
            const container = this.selectors && this.selectors.foContent;
            if (container) {
                empty(container);
                const content = HTML.shapeMaps[this.cell.shape];
                if (!content) {
                    return;
                }
                let { html } = content;
                if (typeof html === 'function') {
                    html = html(this.cell);
                }
                if (html) {
                    if (typeof html === 'string') {
                        container.innerHTML = html;
                    }
                    else {
                        append(container, html);
                    }
                }
            }
        }
        dispose() {
            this.cell.off('change:*', this.onCellChangeAny, this);
        }
    }
    __decorate([
        View.dispose()
    ], View.prototype, "dispose", null);
    HTML.View = View;
    (function (View) {
        View.action = 'html';
        View.config({
            bootstrap: [View.action],
            actions: {
                html: View.action,
            },
        });
        NodeView.registry.register('html-view', View, true);
    })(View = HTML.View || (HTML.View = {}));
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.config({
        view: 'html-view',
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            Object.assign({}, Markup.getForeignObjectMarkup()),
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            body: {
                fill: 'none',
                stroke: 'none',
                refWidth: '100%',
                refHeight: '100%',
            },
            fo: {
                refWidth: '100%',
                refHeight: '100%',
            },
        },
    });
    Node$1.registry.register('html', HTML, true);
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.shapeMaps = {};
    function register(config) {
        const { shape, html, effect, inherit } = config, others = __rest(config, ["shape", "html", "effect", "inherit"]);
        if (!shape) {
            throw new Error('should specify shape in config');
        }
        HTML.shapeMaps[shape] = {
            html,
            effect,
        };
        Graph.registerNode(shape, Object.assign({ inherit: inherit || 'html' }, others), true);
    }
    HTML.register = register;
})(HTML || (HTML = {}));

const allAnimations = (cellNode, val) => {
  function onAnimation(cellNode2) {
    const node = cellNode2.prop();
    let stretchToggle = false;
    let currentTransitions = 0;
    let playNumber = node?.data?.playNumer * 3 || 1;
    function contract() {
      cellNode2.transition(
        "position",
        { x: node.position.x, y: node.position.y + 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object,
          jumpedToEnd: false
        }
      );
      stretchToggle = true;
    }
    function stretch() {
      cellNode2.transition(
        "position",
        { x: node.position.x, y: node.position.y - 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object,
          jumpedToEnd: false
        }
      );
      stretchToggle = false;
    }
    stretch();
    cellNode2.on("transition:start", () => {
      currentTransitions += 1;
    });
    cellNode2.on("transition:complete", () => {
      currentTransitions -= 1;
      if (node?.data?.playNumer) {
        playNumber -= 1;
        if (playNumber && playNumber < 0) {
          return;
        }
      }
      if (currentTransitions === 0) {
        if (stretchToggle) {
          stretch();
        } else {
          contract();
        }
      }
    });
    cellNode2.on("transition:stop", () => {
      cellNode2.prop("position", { x: node.position.x, y: node.position.y });
    });
  }
  function onLeftAnimation(cellNode2) {
    const node = cellNode2.prop();
    let stretchToggle = false;
    let currentTransitions = 0;
    let playNumber = node.data.playNumer * 3 || 1;
    function contract() {
      cellNode2.transition(
        "position",
        { x: node.position.x + 5, y: node.position.y },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      stretchToggle = true;
    }
    function stretch() {
      cellNode2.transition(
        "position",
        { x: node.position.x - 5, y: node.position.y },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      stretchToggle = false;
    }
    stretch();
    cellNode2.on("transition:start", () => {
      currentTransitions += 1;
    });
    cellNode2.on("transition:complete", () => {
      console.log(1);
      currentTransitions -= 1;
      if (node.data.playNumer) {
        console.log(1);
        playNumber -= 1;
        if (playNumber && playNumber < 0) {
          return;
        }
      }
      if (currentTransitions === 0) {
        if (stretchToggle) {
          stretch();
        } else {
          contract();
        }
      }
    });
  }
  function onBodyAnimation(cellNode2) {
    const node = cellNode2.prop();
    let stretchToggle = false;
    let currentTransitions = 0;
    let playNumber = node.data.playNumer * 3 || 1;
    function contract() {
      cellNode2.transition(
        "size",
        { width: node.size.width + 5, height: node.size.height + 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      cellNode2.transition(
        "position",
        { x: node.position.x - 5, y: node.position.y - 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      stretchToggle = true;
    }
    function stretch() {
      cellNode2.transition(
        "size",
        { width: node.size.width - 5, height: node.size.height - 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      cellNode2.transition(
        "position",
        { x: node.position.x + 5, y: node.position.y + 5 },
        {
          delay: 100,
          duration: 10,
          interp: Interp.object
        }
      );
      stretchToggle = false;
    }
    stretch();
    cellNode2.on("transition:start", () => {
      currentTransitions += 1;
    });
    cellNode2.on("transition:complete", () => {
      currentTransitions -= 1;
      if (node.data.playNumer) {
        playNumber -= 1;
        if (playNumber && playNumber < 0) {
          return;
        }
      }
      if (currentTransitions === 0) {
        if (stretchToggle) {
          stretch();
        } else {
          contract();
        }
      }
    });
  }
  switch (val) {
    case "onAnimation":
      onAnimation(cellNode);
      break;
    case "onLeftAnimation":
      onLeftAnimation(cellNode);
      break;
    case "onBodyAnimation":
      onBodyAnimation(cellNode);
      break;
  }
};
const onChangeImage = (cellNode, val) => {
  cellNode.attr("image/xlink:href", val);
};
const edgeAnimations = (currentEdge, val) => {
  const animationData = currentEdge.attr("line2");
  let options1 = {
    delay: 0,
    duration: 3e3,
    timing: Timing.linear,
    complete: () => {
      currentEdge.attr("circle", {
        r: 5,
        fill: animationData.stroke,
        atConnectionRatio: 0,
        refCy: -20
      });
      currentEdge.transition("attrs/circle/atConnectionRatio", 1, options1);
    }
  };
  switch (val) {
    case "water":
      if (currentEdge.getTransitions()) {
        currentEdge.stopTransition("attrs/circle/atConnectionRatio");
        currentEdge.attr("circle", {
          opacity: 0,
          atConnectionRatio: 0
        });
      }
      animationData.style.animation = "ant-line 30s infinite linear";
      animationData.opacity = 1;
      currentEdge.attr("line/opacity", 0.1);
      currentEdge.attr("line4/opacity", 0);
      currentEdge.attr("line3/opacity", 1);
      currentEdge.attr("line2", animationData);
      break;
    case "dots":
      animationData.opacity = 0;
      animationData.style.animation = "";
      currentEdge.attr("line/opacity", 1);
      currentEdge.attr("line2", animationData);
      currentEdge.attr("circle/opacity", 1);
      currentEdge.transition("attrs/circle/atConnectionRatio", 1, options1);
      break;
  }
};

const restoreNodePosition = (node, nodePosition) => {
  node.stopTransition("position");
  node.prop("position", nodePosition);
};
const nodeEvent = (node, val, item, nodePosition, nodeSize, callback) => {
  const nodeProp = node.prop();
  if (val.eventAction == "playAnimation") {
    allAnimations(node, nodeProp.nodeAnimation?.animation);
  } else if (val?.hrefImage && val?.event == item) {
    console.log(val?.hrefImage);
    onChangeImage(node, val.hrefImage);
  } else if (val.eventAction == "openModel" && val?.event == item) {
    console.log(111);
    callback(val);
  } else {
    switch (nodeProp.nodeAnimation?.animation) {
      case "onAnimation":
      case "onLeftAnimation":
        restoreNodePosition(node, nodePosition);
        break;
      case "onBodyAnimation":
        restoreNodePosition(node, nodePosition);
        node.stopTransition("size");
        node.prop("size", nodeSize);
        break;
    }
  }
};
const edgeEvent = (edge, val, edgeProp) => {
  if (val.eventAction == "playAnimation") {
    edgeAnimations(edge, edgeProp.animation);
  } else {
    switch (edgeProp.animation) {
      case "water":
        edge.attr("line/opacity", 1);
        edge.attr("line2/opacity", 0);
        edge.attr("line2/style/animation", "");
        break;
      case "dots":
        edge.stopTransition("attrs/circle/atConnectionRatio");
        edge.attr("circle", {
          opacity: 0,
          atConnectionRatio: 0
        });
        break;
    }
  }
};
const eventList = (formJson, graph, callback) => {
  let nodeEvents = [];
  let edgeEvents = [];
  formJson?.cells.map((item) => {
    item?.data?.map((item1) => {
      nodeEvents.push(item1.event);
    });
    item?.edgeData?.map((item2) => {
      edgeEvents.push(item2.event);
    });
  });
  const eventAll = Array.from(new Set(nodeEvents));
  eventAll.forEach((item1) => {
    graph.on("node:" + item1, ({ e, node }) => {
      const nodeProp = node.prop();
      const nodePosition = { x: node.prop().position.x, y: node.prop().position.y };
      const nodeSize = { x: node.prop().size.width, y: node.prop().size.height };
      nodeProp?.data?.forEach((item2) => {
        if (nodeProp?.nodeAnimation?.animation && item2.targetObject == "" && item2.event == item1) {
          nodeEvent(node, item2, item1, nodePosition, nodeSize, callback);
        }
        if (nodeProp?.nodeAnimation?.animation && item2.targetObject != "" && item2.event == item1) {
          const cell = formJson.cells.find(
            (item) => item.nodeName === item2.targetObject
          );
          if (cell.shape === "edge") {
            const edge = graph.getCellById(cell.id);
            const edgeProp = edge.prop();
            edgeEvent(edge, item2, edgeProp);
          } else {
            const targetNode = graph.getCellById(cell.id);
            const targetProp = targetNode.prop();
            const targetPosition = { x: targetProp.position.x, y: targetProp.position.y };
            const targetSize = { x: targetProp.size.width, y: targetProp.size.height };
            nodeEvent(targetNode, item2, item1, targetPosition, targetSize);
          }
        }
      });
    });
  });
  const eventEdgeAll = Array.from(new Set(edgeEvents));
  eventEdgeAll.forEach((item1) => {
    graph.on("edge:" + item1, ({ e, edge }) => {
      console.log(edge.prop());
      const edgeProp = edge.prop();
      edgeProp?.edgeData?.forEach((item2) => {
        if (edgeProp.animation && item2.targetObject == "" && item2.event == item1) {
          edgeEvent(edge, item2, edgeProp);
        }
        if (edgeProp?.animation && item2.targetObject != "" && item2.event == item1) {
          const cell = formJson.cells.find(
            (item) => item.nodeName === item2.targetObject
          );
          if (cell.shape === "edge") {
            const targetEdge = graph.getCellById(cell.id);
            const targetEdgeProp = edge.prop();
            edgeEvent(targetEdge, item2, targetEdgeProp);
          } else {
            const targetNode = graph.getCellById(cell.id);
            const targetProp = targetNode.prop();
            const targetPosition = { x: targetProp.position.x, y: targetProp.position.y };
            const targetSize = { x: targetProp.size.width, y: targetProp.size.height };
            nodeEvent(targetNode, item2, item1, targetPosition, targetSize);
          }
        }
      });
    });
  });
};

const allList = (graph) => {
  const ports = {
    groups: {
      top: {
        position: "top",
        attrs: {
          circle: {
            r: 4,
            magnet: true,
            stroke: "#5F95FF",
            strokeWidth: 1,
            fill: "#fff",
            style: {
              visibility: "hidden"
            }
          }
        }
      },
      right: {
        position: "right",
        attrs: {
          circle: {
            r: 4,
            magnet: true,
            stroke: "#5F95FF",
            strokeWidth: 1,
            fill: "#fff",
            style: {
              visibility: "hidden"
            }
          }
        }
      },
      bottom: {
        position: "bottom",
        attrs: {
          circle: {
            r: 4,
            magnet: true,
            stroke: "#5F95FF",
            strokeWidth: 1,
            fill: "#fff",
            style: {
              visibility: "hidden"
            }
          }
        }
      },
      left: {
        position: "left",
        attrs: {
          circle: {
            r: 4,
            magnet: true,
            stroke: "#5F95FF",
            strokeWidth: 1,
            fill: "#fff",
            style: {
              visibility: "hidden"
            }
          }
        }
      }
    },
    items: [
      {
        group: "top"
      },
      {
        group: "right"
      },
      {
        group: "bottom"
      },
      {
        group: "left"
      }
    ]
  };
  Graph.registerNode(
    "custom-rect",
    {
      inherit: "rect",
      width: 66,
      height: 36,
      attrs: {
        body: {
          strokeWidth: 1,
          stroke: "#5F95FF",
          fill: "#EFF4FF"
        },
        text: {
          fontSize: 12,
          fill: "#262626"
        }
      },
      ports: { ...ports }
    },
    true
  );
  Graph.registerNode(
    "custom-polygon",
    {
      inherit: "polygon",
      width: 66,
      height: 36,
      attrs: {
        body: {
          strokeWidth: 1,
          stroke: "#5F95FF",
          fill: "#EFF4FF"
        },
        text: {
          fontSize: 12,
          fill: "#262626"
        }
      },
      ports: {
        ...ports,
        items: [
          {
            group: "top"
          },
          {
            group: "bottom"
          }
        ]
      }
    },
    true
  );
  Graph.registerNode(
    "custom-circle",
    {
      inherit: "circle",
      width: 45,
      height: 45,
      attrs: {
        body: {
          strokeWidth: 1,
          stroke: "#5F95FF",
          fill: "#EFF4FF"
        },
        text: {
          fontSize: 12,
          fill: "#262626"
        }
      },
      ports: { ...ports }
    },
    true
  );
  Graph.registerNode(
    "custom-image",
    {
      inherit: "rect",
      width: 65,
      height: 60,
      markup: [
        {
          tagName: "rect",
          selector: "body"
        },
        {
          tagName: "image"
        },
        {
          tagName: "text",
          selector: "label"
        }
      ],
      attrs: {
        body: {
          stroke: "#ccc",
          fill: "#ccc"
          //..
        },
        image: {
          width: 28,
          height: 28,
          refX: 20,
          refY: 12
        },
        label: {
          refX: 1,
          refY: 48,
          textAnchor: "bottom",
          textVerticalAnchor: "top",
          fontSize: 12,
          fill: "#fff"
        }
      },
      ports: {
        groups: {
          top: {
            position: "top",
            attrs: {
              circle: {
                r: 4,
                magnet: true,
                stroke: "#5F95FF",
                strokeWidth: 1,
                fill: "#fff",
                style: {
                  visibility: "hidden"
                }
              }
            }
          },
          right: {
            position: "right",
            attrs: {
              circle: {
                r: 4,
                magnet: true,
                stroke: "#5F95FF",
                strokeWidth: 1,
                fill: "#fff",
                style: {
                  visibility: "hidden"
                }
              }
            }
          },
          bottom: {
            position: "bottom",
            attrs: {
              circle: {
                r: 4,
                magnet: true,
                stroke: "#5F95FF",
                strokeWidth: 1,
                fill: "#fff",
                style: {
                  visibility: "hidden"
                }
              }
            }
          },
          left: {
            position: "left",
            attrs: {
              circle: {
                r: 4,
                magnet: true,
                stroke: "#5F95FF",
                strokeWidth: 1,
                fill: "#fff",
                style: {
                  visibility: "hidden"
                }
              }
            }
          }
        }
      }
    },
    true
  );
  graph.createNode({
    shape: "custom-rect",
    label: "",
    attrs: {
      body: {
        rx: 20,
        ry: 26
      }
    }
  });
  graph.createNode({
    shape: "custom-rect",
    label: ""
  });
  graph.createNode({
    shape: "custom-rect",
    attrs: {
      body: {
        rx: 6,
        ry: 6
      }
    },
    label: ""
  });
  graph.createNode({
    shape: "custom-polygon",
    attrs: {
      body: {
        refPoints: "0,10 10,0 20,10 10,20"
      }
    },
    label: ""
  });
  graph.createNode({
    shape: "custom-polygon",
    attrs: {
      body: {
        refPoints: "10,0 40,0 30,20 0,20"
      }
    },
    label: ""
  });
  graph.createNode({
    shape: "custom-circle",
    label: ""
  });
};

var ps=Object.defineProperty;var Kg=Object.getOwnPropertyDescriptor;var Gg=Object.getOwnPropertyNames;var Qg=Object.prototype.hasOwnProperty;var we=(t,e)=>()=>(t&&(e=t(t=0)),e);var M=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Qt=(t,e)=>{for(var r in e)ps(t,r,{get:e[r],enumerable:!0});},Yg=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Gg(e))!Qg.call(t,n)&&n!==r&&ps(t,n,{get:()=>e[n],enumerable:!(i=Kg(e,n))||i.enumerable});return t};var X=t=>Yg(ps({},"__esModule",{value:!0}),t);var P,_=we(()=>{P={deviceMemory:8,hardwareConcurrency:8,language:"en-US"};});var C={};Qt(C,{_debugEnd:()=>yu,_debugProcess:()=>gu,_events:()=>Ou,_eventsCount:()=>xu,_exiting:()=>Yl,_fatalExceptions:()=>cu,_getActiveHandles:()=>eu,_getActiveRequests:()=>Zl,_kill:()=>ru,_linkedBinding:()=>Gl,_maxListeners:()=>ku,_preload_modules:()=>Cu,_rawDebug:()=>zl,_startProfilerIdleNotifier:()=>bu,_stopProfilerIdleNotifier:()=>wu,_tickCallback:()=>pu,abort:()=>Eu,addListener:()=>Mu,allowedNodeEnvironmentFlags:()=>lu,arch:()=>xl,argv:()=>Ul,argv0:()=>Ru,assert:()=>uu,binding:()=>Fl,chdir:()=>Hl,config:()=>Jl,cpuUsage:()=>Fi,cwd:()=>$l,debugPort:()=>Tu,default:()=>$u,dlopen:()=>Xl,domain:()=>Ql,emit:()=>Du,emitWarning:()=>jl,env:()=>Ll,execArgv:()=>Nl,execPath:()=>Iu,exit:()=>ou,features:()=>fu,hasUncaughtExceptionCaptureCallback:()=>du,hrtime:()=>ji,kill:()=>su,listeners:()=>Wu,memoryUsage:()=>nu,moduleLoadList:()=>Kl,nextTick:()=>Pl,off:()=>Uu,on:()=>wt,once:()=>Lu,openStdin:()=>au,pid:()=>Su,platform:()=>Ml,ppid:()=>Au,prependListener:()=>ju,prependOnceListener:()=>Fu,reallyExit:()=>tu,release:()=>Vl,removeAllListeners:()=>qu,removeListener:()=>Nu,resourceUsage:()=>iu,setSourceMapsEnabled:()=>Bu,setUncaughtExceptionCaptureCallback:()=>hu,stderr:()=>mu,stdin:()=>vu,stdout:()=>_u,title:()=>Ol,umask:()=>Wl,uptime:()=>Pu,version:()=>ql,versions:()=>Dl});function bs(t){throw new Error("Node.js process "+t+" is not supported by JSPM core outside of Node.js")}function Jg(){!xr||!Yt||(xr=!1,Yt.length?bt=Yt.concat(bt):Di=-1,bt.length&&Bl());}function Bl(){if(!xr){var t=setTimeout(Jg,0);xr=!0;for(var e=bt.length;e;){for(Yt=bt,bt=[];++Di<e;)Yt&&Yt[Di].run();Di=-1,e=bt.length;}Yt=null,xr=!1,clearTimeout(t);}}function Pl(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];bt.push(new kl(t,e)),bt.length===1&&!xr&&setTimeout(Bl,0);}function kl(t,e){this.fun=t,this.array=e;}function ve(){}function Gl(t){bs("_linkedBinding");}function Xl(t){bs("dlopen");}function Zl(){return []}function eu(){return []}function uu(t,e){if(!t)throw new Error(e||"assertion error")}function du(){return !1}function Pu(){return Lt.now()/1e3}function ji(t){var e=Math.floor((Date.now()-Lt.now())*.001),r=Lt.now()*.001,i=Math.floor(r)+e,n=Math.floor(r%1*1e9);return t&&(i=i-t[0],n=n-t[1],n<0&&(i--,n+=ys)),[i,n]}function wt(){return $u}function Wu(t){return []}var bt,xr,Yt,Di,Ol,xl,Ml,Ll,Ul,Nl,ql,Dl,jl,Fl,Wl,$l,Hl,Vl,zl,Kl,Ql,Yl,Jl,tu,ru,Fi,iu,nu,su,ou,au,lu,fu,cu,hu,pu,gu,yu,bu,wu,_u,mu,vu,Eu,Su,Au,Iu,Tu,Ru,Cu,Bu,Lt,gs,ys,ku,Ou,xu,Mu,Lu,Uu,Nu,qu,Du,ju,Fu,$u,Hu=we(()=>{v();m();_();bt=[],xr=!1,Di=-1;kl.prototype.run=function(){this.fun.apply(null,this.array);};Ol="browser",xl="x64",Ml="browser",Ll={PATH:"/usr/bin",LANG:P.language+".UTF-8",PWD:"/",HOME:"/home",TMP:"/tmp"},Ul=["/usr/bin/node"],Nl=[],ql="v16.8.0",Dl={},jl=function(t,e){console.warn((e?e+": ":"")+t);},Fl=function(t){bs("binding");},Wl=function(t){return 0},$l=function(){return "/"},Hl=function(t){},Vl={name:"node",sourceUrl:"",headersUrl:"",libUrl:""};zl=ve,Kl=[];Ql={},Yl=!1,Jl={};tu=ve,ru=ve,Fi=function(){return {}},iu=Fi,nu=Fi,su=ve,ou=ve,au=ve,lu={};fu={inspector:!1,debug:!1,uv:!1,ipv6:!1,tls_alpn:!1,tls_sni:!1,tls_ocsp:!1,tls:!1,cached_builtins:!0},cu=ve,hu=ve;pu=ve,gu=ve,yu=ve,bu=ve,wu=ve,_u=void 0,mu=void 0,vu=void 0,Eu=ve,Su=2,Au=1,Iu="/bin/usr/node",Tu=9229,Ru="node",Cu=[],Bu=ve,Lt={now:typeof performance<"u"?performance.now.bind(performance):void 0,timing:typeof performance<"u"?performance.timing:void 0};Lt.now===void 0&&(gs=Date.now(),Lt.timing&&Lt.timing.navigationStart&&(gs=Lt.timing.navigationStart),Lt.now=()=>Date.now()-gs);ys=1e9;ji.bigint=function(t){var e=ji(t);return typeof BigInt>"u"?e[0]*ys+e[1]:BigInt(e[0]*ys)+BigInt(e[1])};ku=10,Ou={},xu=0;Mu=wt,Lu=wt,Uu=wt,Nu=wt,qu=wt,Du=ve,ju=wt,Fu=wt;$u={version:ql,versions:Dl,arch:xl,platform:Ml,release:Vl,_rawDebug:zl,moduleLoadList:Kl,binding:Fl,_linkedBinding:Gl,_events:Ou,_eventsCount:xu,_maxListeners:ku,on:wt,addListener:Mu,once:Lu,off:Uu,removeListener:Nu,removeAllListeners:qu,emit:Du,prependListener:ju,prependOnceListener:Fu,listeners:Wu,domain:Ql,_exiting:Yl,config:Jl,dlopen:Xl,uptime:Pu,_getActiveRequests:Zl,_getActiveHandles:eu,reallyExit:tu,_kill:ru,cpuUsage:Fi,resourceUsage:iu,memoryUsage:nu,kill:su,exit:ou,openStdin:au,allowedNodeEnvironmentFlags:lu,assert:uu,features:fu,_fatalExceptions:cu,setUncaughtExceptionCaptureCallback:hu,hasUncaughtExceptionCaptureCallback:du,emitWarning:jl,nextTick:Pl,_tickCallback:pu,_debugProcess:gu,_debugEnd:yu,_startProfilerIdleNotifier:bu,_stopProfilerIdleNotifier:wu,stdout:_u,stdin:vu,stderr:mu,abort:Eu,umask:Wl,chdir:Hl,cwd:$l,env:Ll,title:Ol,argv:Ul,execArgv:Nl,pid:Su,ppid:Au,execPath:Iu,debugPort:Tu,hrtime:ji,argv0:Ru,_preload_modules:Cu,setSourceMapsEnabled:Bu};});var m=we(()=>{Hu();});var _e={};Qt(_e,{Buffer:()=>x,INSPECT_MAX_BYTES:()=>ty,default:()=>Ut,kMaxLength:()=>ry});function Xg(){if(Vu)return ui;Vu=!0,ui.byteLength=a,ui.toByteArray=c,ui.fromByteArray=g;for(var t=[],e=[],r=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=0,o=i.length;n<o;++n)t[n]=i[n],e[i.charCodeAt(n)]=n;e["-".charCodeAt(0)]=62,e["_".charCodeAt(0)]=63;function s(y){var w=y.length;if(w%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var E=y.indexOf("=");E===-1&&(E=w);var S=E===w?0:4-E%4;return [E,S]}function a(y){var w=s(y),E=w[0],S=w[1];return (E+S)*3/4-S}function u(y,w,E){return (w+E)*3/4-E}function c(y){var w,E=s(y),S=E[0],I=E[1],B=new r(u(y,S,I)),R=0,U=I>0?S-4:S,N;for(N=0;N<U;N+=4)w=e[y.charCodeAt(N)]<<18|e[y.charCodeAt(N+1)]<<12|e[y.charCodeAt(N+2)]<<6|e[y.charCodeAt(N+3)],B[R++]=w>>16&255,B[R++]=w>>8&255,B[R++]=w&255;return I===2&&(w=e[y.charCodeAt(N)]<<2|e[y.charCodeAt(N+1)]>>4,B[R++]=w&255),I===1&&(w=e[y.charCodeAt(N)]<<10|e[y.charCodeAt(N+1)]<<4|e[y.charCodeAt(N+2)]>>2,B[R++]=w>>8&255,B[R++]=w&255),B}function h(y){return t[y>>18&63]+t[y>>12&63]+t[y>>6&63]+t[y&63]}function d(y,w,E){for(var S,I=[],B=w;B<E;B+=3)S=(y[B]<<16&16711680)+(y[B+1]<<8&65280)+(y[B+2]&255),I.push(h(S));return I.join("")}function g(y){for(var w,E=y.length,S=E%3,I=[],B=16383,R=0,U=E-S;R<U;R+=B)I.push(d(y,R,R+B>U?U:R+B));return S===1?(w=y[E-1],I.push(t[w>>2]+t[w<<4&63]+"==")):S===2&&(w=(y[E-2]<<8)+y[E-1],I.push(t[w>>10]+t[w>>4&63]+t[w<<2&63]+"=")),I.join("")}return ui}function Zg(){if(zu)return Wi;zu=!0;return Wi.read=function(t,e,r,i,n){var o,s,a=n*8-i-1,u=(1<<a)-1,c=u>>1,h=-7,d=r?n-1:0,g=r?-1:1,y=t[e+d];for(d+=g,o=y&(1<<-h)-1,y>>=-h,h+=a;h>0;o=o*256+t[e+d],d+=g,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=i;h>0;s=s*256+t[e+d],d+=g,h-=8);if(o===0)o=1-c;else {if(o===u)return s?NaN:(y?-1:1)*(1/0);s=s+Math.pow(2,i),o=o-c;}return (y?-1:1)*s*Math.pow(2,o-i)},Wi.write=function(t,e,r,i,n,o){var s,a,u,c=o*8-n-1,h=(1<<c)-1,d=h>>1,g=n===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=i?0:o-1,w=i?1:-1,E=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),s+d>=1?e+=g/u:e+=g*Math.pow(2,1-d),e*u>=2&&(s++,u/=2),s+d>=h?(a=0,s=h):s+d>=1?(a=(e*u-1)*Math.pow(2,n),s=s+d):(a=e*Math.pow(2,d-1)*Math.pow(2,n),s=0));n>=8;t[r+y]=a&255,y+=w,a/=256,n-=8);for(s=s<<n|a,c+=n;c>0;t[r+y]=s&255,y+=w,s/=256,c-=8);t[r+y-w]|=E*128;},Wi}function ey(){if(Ku)return Jt;Ku=!0;let t=Xg(),e=Zg(),r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Jt.Buffer=s,Jt.SlowBuffer=I,Jt.INSPECT_MAX_BYTES=50;let i=2147483647;Jt.kMaxLength=i,s.TYPED_ARRAY_SUPPORT=n(),!s.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function n(){try{let p=new Uint8Array(1),l={foo:function(){return 42}};return Object.setPrototypeOf(l,Uint8Array.prototype),Object.setPrototypeOf(p,l),p.foo()===42}catch{return !1}}Object.defineProperty(s.prototype,"parent",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.buffer}}),Object.defineProperty(s.prototype,"offset",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.byteOffset}});function o(p){if(p>i)throw new RangeError('The value "'+p+'" is invalid for option "size"');let l=new Uint8Array(p);return Object.setPrototypeOf(l,s.prototype),l}function s(p,l,f){if(typeof p=="number"){if(typeof l=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return h(p)}return a(p,l,f)}s.poolSize=8192;function a(p,l,f){if(typeof p=="string")return d(p,l);if(ArrayBuffer.isView(p))return y(p);if(p==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof p);if(Ye(p,ArrayBuffer)||p&&Ye(p.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Ye(p,SharedArrayBuffer)||p&&Ye(p.buffer,SharedArrayBuffer)))return w(p,l,f);if(typeof p=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');let b=p.valueOf&&p.valueOf();if(b!=null&&b!==p)return s.from(b,l,f);let A=E(p);if(A)return A;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof p[Symbol.toPrimitive]=="function")return s.from(p[Symbol.toPrimitive]("string"),l,f);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof p)}s.from=function(p,l,f){return a(p,l,f)},Object.setPrototypeOf(s.prototype,Uint8Array.prototype),Object.setPrototypeOf(s,Uint8Array);function u(p){if(typeof p!="number")throw new TypeError('"size" argument must be of type number');if(p<0)throw new RangeError('The value "'+p+'" is invalid for option "size"')}function c(p,l,f){return u(p),p<=0?o(p):l!==void 0?typeof f=="string"?o(p).fill(l,f):o(p).fill(l):o(p)}s.alloc=function(p,l,f){return c(p,l,f)};function h(p){return u(p),o(p<0?0:S(p)|0)}s.allocUnsafe=function(p){return h(p)},s.allocUnsafeSlow=function(p){return h(p)};function d(p,l){if((typeof l!="string"||l==="")&&(l="utf8"),!s.isEncoding(l))throw new TypeError("Unknown encoding: "+l);let f=B(p,l)|0,b=o(f),A=b.write(p,l);return A!==f&&(b=b.slice(0,A)),b}function g(p){let l=p.length<0?0:S(p.length)|0,f=o(l);for(let b=0;b<l;b+=1)f[b]=p[b]&255;return f}function y(p){if(Ye(p,Uint8Array)){let l=new Uint8Array(p);return w(l.buffer,l.byteOffset,l.byteLength)}return g(p)}function w(p,l,f){if(l<0||p.byteLength<l)throw new RangeError('"offset" is outside of buffer bounds');if(p.byteLength<l+(f||0))throw new RangeError('"length" is outside of buffer bounds');let b;return l===void 0&&f===void 0?b=new Uint8Array(p):f===void 0?b=new Uint8Array(p,l):b=new Uint8Array(p,l,f),Object.setPrototypeOf(b,s.prototype),b}function E(p){if(s.isBuffer(p)){let l=S(p.length)|0,f=o(l);return f.length===0||p.copy(f,0,0,l),f}if(p.length!==void 0)return typeof p.length!="number"||ds(p.length)?o(0):g(p);if(p.type==="Buffer"&&Array.isArray(p.data))return g(p.data)}function S(p){if(p>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return p|0}function I(p){return +p!=p&&(p=0),s.alloc(+p)}s.isBuffer=function(l){return l!=null&&l._isBuffer===!0&&l!==s.prototype},s.compare=function(l,f){if(Ye(l,Uint8Array)&&(l=s.from(l,l.offset,l.byteLength)),Ye(f,Uint8Array)&&(f=s.from(f,f.offset,f.byteLength)),!s.isBuffer(l)||!s.isBuffer(f))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(l===f)return 0;let b=l.length,A=f.length;for(let T=0,k=Math.min(b,A);T<k;++T)if(l[T]!==f[T]){b=l[T],A=f[T];break}return b<A?-1:A<b?1:0},s.isEncoding=function(l){switch(String(l).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},s.concat=function(l,f){if(!Array.isArray(l))throw new TypeError('"list" argument must be an Array of Buffers');if(l.length===0)return s.alloc(0);let b;if(f===void 0)for(f=0,b=0;b<l.length;++b)f+=l[b].length;let A=s.allocUnsafe(f),T=0;for(b=0;b<l.length;++b){let k=l[b];if(Ye(k,Uint8Array))T+k.length>A.length?(s.isBuffer(k)||(k=s.from(k)),k.copy(A,T)):Uint8Array.prototype.set.call(A,k,T);else if(s.isBuffer(k))k.copy(A,T);else throw new TypeError('"list" argument must be an Array of Buffers');T+=k.length;}return A};function B(p,l){if(s.isBuffer(p))return p.length;if(ArrayBuffer.isView(p)||Ye(p,ArrayBuffer))return p.byteLength;if(typeof p!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof p);let f=p.length,b=arguments.length>2&&arguments[2]===!0;if(!b&&f===0)return 0;let A=!1;for(;;)switch(l){case"ascii":case"latin1":case"binary":return f;case"utf8":case"utf-8":return hs(p).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return f*2;case"hex":return f>>>1;case"base64":return Cl(p).length;default:if(A)return b?-1:hs(p).length;l=(""+l).toLowerCase(),A=!0;}}s.byteLength=B;function R(p,l,f){let b=!1;if((l===void 0||l<0)&&(l=0),l>this.length||((f===void 0||f>this.length)&&(f=this.length),f<=0)||(f>>>=0,l>>>=0,f<=l))return "";for(p||(p="utf8");;)switch(p){case"hex":return qg(this,l,f);case"utf8":case"utf-8":return Cr(this,l,f);case"ascii":return fs(this,l,f);case"latin1":case"binary":return Ng(this,l,f);case"base64":return pe(this,l,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Dg(this,l,f);default:if(b)throw new TypeError("Unknown encoding: "+p);p=(p+"").toLowerCase(),b=!0;}}s.prototype._isBuffer=!0;function U(p,l,f){let b=p[l];p[l]=p[f],p[f]=b;}s.prototype.swap16=function(){let l=this.length;if(l%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let f=0;f<l;f+=2)U(this,f,f+1);return this},s.prototype.swap32=function(){let l=this.length;if(l%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let f=0;f<l;f+=4)U(this,f,f+3),U(this,f+1,f+2);return this},s.prototype.swap64=function(){let l=this.length;if(l%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let f=0;f<l;f+=8)U(this,f,f+7),U(this,f+1,f+6),U(this,f+2,f+5),U(this,f+3,f+4);return this},s.prototype.toString=function(){let l=this.length;return l===0?"":arguments.length===0?Cr(this,0,l):R.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(l){if(!s.isBuffer(l))throw new TypeError("Argument must be a Buffer");return this===l?!0:s.compare(this,l)===0},s.prototype.inspect=function(){let l="",f=Jt.INSPECT_MAX_BYTES;return l=this.toString("hex",0,f).replace(/(.{2})/g,"$1 ").trim(),this.length>f&&(l+=" ... "),"<Buffer "+l+">"},r&&(s.prototype[r]=s.prototype.inspect),s.prototype.compare=function(l,f,b,A,T){if(Ye(l,Uint8Array)&&(l=s.from(l,l.offset,l.byteLength)),!s.isBuffer(l))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof l);if(f===void 0&&(f=0),b===void 0&&(b=l?l.length:0),A===void 0&&(A=0),T===void 0&&(T=this.length),f<0||b>l.length||A<0||T>this.length)throw new RangeError("out of range index");if(A>=T&&f>=b)return 0;if(A>=T)return -1;if(f>=b)return 1;if(f>>>=0,b>>>=0,A>>>=0,T>>>=0,this===l)return 0;let k=T-A,$=b-f,se=Math.min(k,$),te=this.slice(A,T),oe=l.slice(f,b);for(let J=0;J<se;++J)if(te[J]!==oe[J]){k=te[J],$=oe[J];break}return k<$?-1:$<k?1:0};function N(p,l,f,b,A){if(p.length===0)return -1;if(typeof f=="string"?(b=f,f=0):f>2147483647?f=2147483647:f<-2147483648&&(f=-2147483648),f=+f,ds(f)&&(f=A?0:p.length-1),f<0&&(f=p.length+f),f>=p.length){if(A)return -1;f=p.length-1;}else if(f<0)if(A)f=0;else return -1;if(typeof l=="string"&&(l=s.from(l,b)),s.isBuffer(l))return l.length===0?-1:W(p,l,f,b,A);if(typeof l=="number")return l=l&255,typeof Uint8Array.prototype.indexOf=="function"?A?Uint8Array.prototype.indexOf.call(p,l,f):Uint8Array.prototype.lastIndexOf.call(p,l,f):W(p,[l],f,b,A);throw new TypeError("val must be string, number or Buffer")}function W(p,l,f,b,A){let T=1,k=p.length,$=l.length;if(b!==void 0&&(b=String(b).toLowerCase(),b==="ucs2"||b==="ucs-2"||b==="utf16le"||b==="utf-16le")){if(p.length<2||l.length<2)return -1;T=2,k/=2,$/=2,f/=2;}function se(oe,J){return T===1?oe[J]:oe.readUInt16BE(J*T)}let te;if(A){let oe=-1;for(te=f;te<k;te++)if(se(p,te)===se(l,oe===-1?0:te-oe)){if(oe===-1&&(oe=te),te-oe+1===$)return oe*T}else oe!==-1&&(te-=te-oe),oe=-1;}else for(f+$>k&&(f=k-$),te=f;te>=0;te--){let oe=!0;for(let J=0;J<$;J++)if(se(p,te+J)!==se(l,J)){oe=!1;break}if(oe)return te}return -1}s.prototype.includes=function(l,f,b){return this.indexOf(l,f,b)!==-1},s.prototype.indexOf=function(l,f,b){return N(this,l,f,b,!0)},s.prototype.lastIndexOf=function(l,f,b){return N(this,l,f,b,!1)};function K(p,l,f,b){f=Number(f)||0;let A=p.length-f;b?(b=Number(b),b>A&&(b=A)):b=A;let T=l.length;b>T/2&&(b=T/2);let k;for(k=0;k<b;++k){let $=parseInt(l.substr(k*2,2),16);if(ds($))return k;p[f+k]=$;}return k}function z(p,l,f,b){return qi(hs(l,p.length-f),p,f,b)}function Q(p,l,f,b){return qi($g(l),p,f,b)}function de(p,l,f,b){return qi(Cl(l),p,f,b)}function Gt(p,l,f,b){return qi(Hg(l,p.length-f),p,f,b)}s.prototype.write=function(l,f,b,A){if(f===void 0)A="utf8",b=this.length,f=0;else if(b===void 0&&typeof f=="string")A=f,b=this.length,f=0;else if(isFinite(f))f=f>>>0,isFinite(b)?(b=b>>>0,A===void 0&&(A="utf8")):(A=b,b=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let T=this.length-f;if((b===void 0||b>T)&&(b=T),l.length>0&&(b<0||f<0)||f>this.length)throw new RangeError("Attempt to write outside buffer bounds");A||(A="utf8");let k=!1;for(;;)switch(A){case"hex":return K(this,l,f,b);case"utf8":case"utf-8":return z(this,l,f,b);case"ascii":case"latin1":case"binary":return Q(this,l,f,b);case"base64":return de(this,l,f,b);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Gt(this,l,f,b);default:if(k)throw new TypeError("Unknown encoding: "+A);A=(""+A).toLowerCase(),k=!0;}},s.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function pe(p,l,f){return l===0&&f===p.length?t.fromByteArray(p):t.fromByteArray(p.slice(l,f))}function Cr(p,l,f){f=Math.min(p.length,f);let b=[],A=l;for(;A<f;){let T=p[A],k=null,$=T>239?4:T>223?3:T>191?2:1;if(A+$<=f){let se,te,oe,J;switch($){case 1:T<128&&(k=T);break;case 2:se=p[A+1],(se&192)===128&&(J=(T&31)<<6|se&63,J>127&&(k=J));break;case 3:se=p[A+1],te=p[A+2],(se&192)===128&&(te&192)===128&&(J=(T&15)<<12|(se&63)<<6|te&63,J>2047&&(J<55296||J>57343)&&(k=J));break;case 4:se=p[A+1],te=p[A+2],oe=p[A+3],(se&192)===128&&(te&192)===128&&(oe&192)===128&&(J=(T&15)<<18|(se&63)<<12|(te&63)<<6|oe&63,J>65535&&J<1114112&&(k=J));}}k===null?(k=65533,$=1):k>65535&&(k-=65536,b.push(k>>>10&1023|55296),k=56320|k&1023),b.push(k),A+=$;}return Pr(b)}let Br=4096;function Pr(p){let l=p.length;if(l<=Br)return String.fromCharCode.apply(String,p);let f="",b=0;for(;b<l;)f+=String.fromCharCode.apply(String,p.slice(b,b+=Br));return f}function fs(p,l,f){let b="";f=Math.min(p.length,f);for(let A=l;A<f;++A)b+=String.fromCharCode(p[A]&127);return b}function Ng(p,l,f){let b="";f=Math.min(p.length,f);for(let A=l;A<f;++A)b+=String.fromCharCode(p[A]);return b}function qg(p,l,f){let b=p.length;(!l||l<0)&&(l=0),(!f||f<0||f>b)&&(f=b);let A="";for(let T=l;T<f;++T)A+=Vg[p[T]];return A}function Dg(p,l,f){let b=p.slice(l,f),A="";for(let T=0;T<b.length-1;T+=2)A+=String.fromCharCode(b[T]+b[T+1]*256);return A}s.prototype.slice=function(l,f){let b=this.length;l=~~l,f=f===void 0?b:~~f,l<0?(l+=b,l<0&&(l=0)):l>b&&(l=b),f<0?(f+=b,f<0&&(f=0)):f>b&&(f=b),f<l&&(f=l);let A=this.subarray(l,f);return Object.setPrototypeOf(A,s.prototype),A};function ge(p,l,f){if(p%1!==0||p<0)throw new RangeError("offset is not uint");if(p+l>f)throw new RangeError("Trying to access beyond buffer length")}s.prototype.readUintLE=s.prototype.readUIntLE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l],T=1,k=0;for(;++k<f&&(T*=256);)A+=this[l+k]*T;return A},s.prototype.readUintBE=s.prototype.readUIntBE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l+--f],T=1;for(;f>0&&(T*=256);)A+=this[l+--f]*T;return A},s.prototype.readUint8=s.prototype.readUInt8=function(l,f){return l=l>>>0,f||ge(l,1,this.length),this[l]},s.prototype.readUint16LE=s.prototype.readUInt16LE=function(l,f){return l=l>>>0,f||ge(l,2,this.length),this[l]|this[l+1]<<8},s.prototype.readUint16BE=s.prototype.readUInt16BE=function(l,f){return l=l>>>0,f||ge(l,2,this.length),this[l]<<8|this[l+1]},s.prototype.readUint32LE=s.prototype.readUInt32LE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),(this[l]|this[l+1]<<8|this[l+2]<<16)+this[l+3]*16777216},s.prototype.readUint32BE=s.prototype.readUInt32BE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]*16777216+(this[l+1]<<16|this[l+2]<<8|this[l+3])},s.prototype.readBigUInt64LE=Mt(function(l){l=l>>>0,Or(l,"offset");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&li(l,this.length-8);let A=f+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24,T=this[++l]+this[++l]*2**8+this[++l]*2**16+b*2**24;return BigInt(A)+(BigInt(T)<<BigInt(32))}),s.prototype.readBigUInt64BE=Mt(function(l){l=l>>>0,Or(l,"offset");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&li(l,this.length-8);let A=f*2**24+this[++l]*2**16+this[++l]*2**8+this[++l],T=this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+b;return (BigInt(A)<<BigInt(32))+BigInt(T)}),s.prototype.readIntLE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l],T=1,k=0;for(;++k<f&&(T*=256);)A+=this[l+k]*T;return T*=128,A>=T&&(A-=Math.pow(2,8*f)),A},s.prototype.readIntBE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=f,T=1,k=this[l+--A];for(;A>0&&(T*=256);)k+=this[l+--A]*T;return T*=128,k>=T&&(k-=Math.pow(2,8*f)),k},s.prototype.readInt8=function(l,f){return l=l>>>0,f||ge(l,1,this.length),this[l]&128?(255-this[l]+1)*-1:this[l]},s.prototype.readInt16LE=function(l,f){l=l>>>0,f||ge(l,2,this.length);let b=this[l]|this[l+1]<<8;return b&32768?b|4294901760:b},s.prototype.readInt16BE=function(l,f){l=l>>>0,f||ge(l,2,this.length);let b=this[l+1]|this[l]<<8;return b&32768?b|4294901760:b},s.prototype.readInt32LE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]|this[l+1]<<8|this[l+2]<<16|this[l+3]<<24},s.prototype.readInt32BE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]<<24|this[l+1]<<16|this[l+2]<<8|this[l+3]},s.prototype.readBigInt64LE=Mt(function(l){l=l>>>0,Or(l,"offset");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&li(l,this.length-8);let A=this[l+4]+this[l+5]*2**8+this[l+6]*2**16+(b<<24);return (BigInt(A)<<BigInt(32))+BigInt(f+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24)}),s.prototype.readBigInt64BE=Mt(function(l){l=l>>>0,Or(l,"offset");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&li(l,this.length-8);let A=(f<<24)+this[++l]*2**16+this[++l]*2**8+this[++l];return (BigInt(A)<<BigInt(32))+BigInt(this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+b)}),s.prototype.readFloatLE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),e.read(this,l,!0,23,4)},s.prototype.readFloatBE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),e.read(this,l,!1,23,4)},s.prototype.readDoubleLE=function(l,f){return l=l>>>0,f||ge(l,8,this.length),e.read(this,l,!0,52,8)},s.prototype.readDoubleBE=function(l,f){return l=l>>>0,f||ge(l,8,this.length),e.read(this,l,!1,52,8)};function Ce(p,l,f,b,A,T){if(!s.isBuffer(p))throw new TypeError('"buffer" argument must be a Buffer instance');if(l>A||l<T)throw new RangeError('"value" argument is out of bounds');if(f+b>p.length)throw new RangeError("Index out of range")}s.prototype.writeUintLE=s.prototype.writeUIntLE=function(l,f,b,A){if(l=+l,f=f>>>0,b=b>>>0,!A){let $=Math.pow(2,8*b)-1;Ce(this,l,f,b,$,0);}let T=1,k=0;for(this[f]=l&255;++k<b&&(T*=256);)this[f+k]=l/T&255;return f+b},s.prototype.writeUintBE=s.prototype.writeUIntBE=function(l,f,b,A){if(l=+l,f=f>>>0,b=b>>>0,!A){let $=Math.pow(2,8*b)-1;Ce(this,l,f,b,$,0);}let T=b-1,k=1;for(this[f+T]=l&255;--T>=0&&(k*=256);)this[f+T]=l/k&255;return f+b},s.prototype.writeUint8=s.prototype.writeUInt8=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,1,255,0),this[f]=l&255,f+1},s.prototype.writeUint16LE=s.prototype.writeUInt16LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,65535,0),this[f]=l&255,this[f+1]=l>>>8,f+2},s.prototype.writeUint16BE=s.prototype.writeUInt16BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,65535,0),this[f]=l>>>8,this[f+1]=l&255,f+2},s.prototype.writeUint32LE=s.prototype.writeUInt32LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,4294967295,0),this[f+3]=l>>>24,this[f+2]=l>>>16,this[f+1]=l>>>8,this[f]=l&255,f+4},s.prototype.writeUint32BE=s.prototype.writeUInt32BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,4294967295,0),this[f]=l>>>24,this[f+1]=l>>>16,this[f+2]=l>>>8,this[f+3]=l&255,f+4};function vl(p,l,f,b,A){Rl(l,b,A,p,f,7);let T=Number(l&BigInt(4294967295));p[f++]=T,T=T>>8,p[f++]=T,T=T>>8,p[f++]=T,T=T>>8,p[f++]=T;let k=Number(l>>BigInt(32)&BigInt(4294967295));return p[f++]=k,k=k>>8,p[f++]=k,k=k>>8,p[f++]=k,k=k>>8,p[f++]=k,f}function El(p,l,f,b,A){Rl(l,b,A,p,f,7);let T=Number(l&BigInt(4294967295));p[f+7]=T,T=T>>8,p[f+6]=T,T=T>>8,p[f+5]=T,T=T>>8,p[f+4]=T;let k=Number(l>>BigInt(32)&BigInt(4294967295));return p[f+3]=k,k=k>>8,p[f+2]=k,k=k>>8,p[f+1]=k,k=k>>8,p[f]=k,f+8}s.prototype.writeBigUInt64LE=Mt(function(l,f=0){return vl(this,l,f,BigInt(0),BigInt("0xffffffffffffffff"))}),s.prototype.writeBigUInt64BE=Mt(function(l,f=0){return El(this,l,f,BigInt(0),BigInt("0xffffffffffffffff"))}),s.prototype.writeIntLE=function(l,f,b,A){if(l=+l,f=f>>>0,!A){let se=Math.pow(2,8*b-1);Ce(this,l,f,b,se-1,-se);}let T=0,k=1,$=0;for(this[f]=l&255;++T<b&&(k*=256);)l<0&&$===0&&this[f+T-1]!==0&&($=1),this[f+T]=(l/k>>0)-$&255;return f+b},s.prototype.writeIntBE=function(l,f,b,A){if(l=+l,f=f>>>0,!A){let se=Math.pow(2,8*b-1);Ce(this,l,f,b,se-1,-se);}let T=b-1,k=1,$=0;for(this[f+T]=l&255;--T>=0&&(k*=256);)l<0&&$===0&&this[f+T+1]!==0&&($=1),this[f+T]=(l/k>>0)-$&255;return f+b},s.prototype.writeInt8=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,1,127,-128),l<0&&(l=255+l+1),this[f]=l&255,f+1},s.prototype.writeInt16LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,32767,-32768),this[f]=l&255,this[f+1]=l>>>8,f+2},s.prototype.writeInt16BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,32767,-32768),this[f]=l>>>8,this[f+1]=l&255,f+2},s.prototype.writeInt32LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,2147483647,-2147483648),this[f]=l&255,this[f+1]=l>>>8,this[f+2]=l>>>16,this[f+3]=l>>>24,f+4},s.prototype.writeInt32BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,2147483647,-2147483648),l<0&&(l=4294967295+l+1),this[f]=l>>>24,this[f+1]=l>>>16,this[f+2]=l>>>8,this[f+3]=l&255,f+4},s.prototype.writeBigInt64LE=Mt(function(l,f=0){return vl(this,l,f,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),s.prototype.writeBigInt64BE=Mt(function(l,f=0){return El(this,l,f,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Sl(p,l,f,b,A,T){if(f+b>p.length)throw new RangeError("Index out of range");if(f<0)throw new RangeError("Index out of range")}function Al(p,l,f,b,A){return l=+l,f=f>>>0,A||Sl(p,l,f,4),e.write(p,l,f,b,23,4),f+4}s.prototype.writeFloatLE=function(l,f,b){return Al(this,l,f,!0,b)},s.prototype.writeFloatBE=function(l,f,b){return Al(this,l,f,!1,b)};function Il(p,l,f,b,A){return l=+l,f=f>>>0,A||Sl(p,l,f,8),e.write(p,l,f,b,52,8),f+8}s.prototype.writeDoubleLE=function(l,f,b){return Il(this,l,f,!0,b)},s.prototype.writeDoubleBE=function(l,f,b){return Il(this,l,f,!1,b)},s.prototype.copy=function(l,f,b,A){if(!s.isBuffer(l))throw new TypeError("argument should be a Buffer");if(b||(b=0),!A&&A!==0&&(A=this.length),f>=l.length&&(f=l.length),f||(f=0),A>0&&A<b&&(A=b),A===b||l.length===0||this.length===0)return 0;if(f<0)throw new RangeError("targetStart out of bounds");if(b<0||b>=this.length)throw new RangeError("Index out of range");if(A<0)throw new RangeError("sourceEnd out of bounds");A>this.length&&(A=this.length),l.length-f<A-b&&(A=l.length-f+b);let T=A-b;return this===l&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(f,b,A):Uint8Array.prototype.set.call(l,this.subarray(b,A),f),T},s.prototype.fill=function(l,f,b,A){if(typeof l=="string"){if(typeof f=="string"?(A=f,f=0,b=this.length):typeof b=="string"&&(A=b,b=this.length),A!==void 0&&typeof A!="string")throw new TypeError("encoding must be a string");if(typeof A=="string"&&!s.isEncoding(A))throw new TypeError("Unknown encoding: "+A);if(l.length===1){let k=l.charCodeAt(0);(A==="utf8"&&k<128||A==="latin1")&&(l=k);}}else typeof l=="number"?l=l&255:typeof l=="boolean"&&(l=Number(l));if(f<0||this.length<f||this.length<b)throw new RangeError("Out of range index");if(b<=f)return this;f=f>>>0,b=b===void 0?this.length:b>>>0,l||(l=0);let T;if(typeof l=="number")for(T=f;T<b;++T)this[T]=l;else {let k=s.isBuffer(l)?l:s.from(l,A),$=k.length;if($===0)throw new TypeError('The value "'+l+'" is invalid for argument "value"');for(T=0;T<b-f;++T)this[T+f]=k[T%$];}return this};let kr={};function cs(p,l,f){kr[p]=class extends f{constructor(){super(),Object.defineProperty(this,"message",{value:l.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${p}]`,this.stack,delete this.name;}get code(){return p}set code(A){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:A,writable:!0});}toString(){return `${this.name} [${p}]: ${this.message}`}};}cs("ERR_BUFFER_OUT_OF_BOUNDS",function(p){return p?`${p} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),cs("ERR_INVALID_ARG_TYPE",function(p,l){return `The "${p}" argument must be of type number. Received type ${typeof l}`},TypeError),cs("ERR_OUT_OF_RANGE",function(p,l,f){let b=`The value of "${p}" is out of range.`,A=f;return Number.isInteger(f)&&Math.abs(f)>2**32?A=Tl(String(f)):typeof f=="bigint"&&(A=String(f),(f>BigInt(2)**BigInt(32)||f<-(BigInt(2)**BigInt(32)))&&(A=Tl(A)),A+="n"),b+=` It must be ${l}. Received ${A}`,b},RangeError);function Tl(p){let l="",f=p.length,b=p[0]==="-"?1:0;for(;f>=b+4;f-=3)l=`_${p.slice(f-3,f)}${l}`;return `${p.slice(0,f)}${l}`}function jg(p,l,f){Or(l,"offset"),(p[l]===void 0||p[l+f]===void 0)&&li(l,p.length-(f+1));}function Rl(p,l,f,b,A,T){if(p>f||p<l){let k=typeof l=="bigint"?"n":"",$;throw T>3?l===0||l===BigInt(0)?$=`>= 0${k} and < 2${k} ** ${(T+1)*8}${k}`:$=`>= -(2${k} ** ${(T+1)*8-1}${k}) and < 2 ** ${(T+1)*8-1}${k}`:$=`>= ${l}${k} and <= ${f}${k}`,new kr.ERR_OUT_OF_RANGE("value",$,p)}jg(b,A,T);}function Or(p,l){if(typeof p!="number")throw new kr.ERR_INVALID_ARG_TYPE(l,"number",p)}function li(p,l,f){throw Math.floor(p)!==p?(Or(p,f),new kr.ERR_OUT_OF_RANGE(f||"offset","an integer",p)):l<0?new kr.ERR_BUFFER_OUT_OF_BOUNDS:new kr.ERR_OUT_OF_RANGE(f||"offset",`>= ${f?1:0} and <= ${l}`,p)}let Fg=/[^+/0-9A-Za-z-_]/g;function Wg(p){if(p=p.split("=")[0],p=p.trim().replace(Fg,""),p.length<2)return "";for(;p.length%4!==0;)p=p+"=";return p}function hs(p,l){l=l||1/0;let f,b=p.length,A=null,T=[];for(let k=0;k<b;++k){if(f=p.charCodeAt(k),f>55295&&f<57344){if(!A){if(f>56319){(l-=3)>-1&&T.push(239,191,189);continue}else if(k+1===b){(l-=3)>-1&&T.push(239,191,189);continue}A=f;continue}if(f<56320){(l-=3)>-1&&T.push(239,191,189),A=f;continue}f=(A-55296<<10|f-56320)+65536;}else A&&(l-=3)>-1&&T.push(239,191,189);if(A=null,f<128){if((l-=1)<0)break;T.push(f);}else if(f<2048){if((l-=2)<0)break;T.push(f>>6|192,f&63|128);}else if(f<65536){if((l-=3)<0)break;T.push(f>>12|224,f>>6&63|128,f&63|128);}else if(f<1114112){if((l-=4)<0)break;T.push(f>>18|240,f>>12&63|128,f>>6&63|128,f&63|128);}else throw new Error("Invalid code point")}return T}function $g(p){let l=[];for(let f=0;f<p.length;++f)l.push(p.charCodeAt(f)&255);return l}function Hg(p,l){let f,b,A,T=[];for(let k=0;k<p.length&&!((l-=2)<0);++k)f=p.charCodeAt(k),b=f>>8,A=f%256,T.push(A),T.push(b);return T}function Cl(p){return t.toByteArray(Wg(p))}function qi(p,l,f,b){let A;for(A=0;A<b&&!(A+f>=l.length||A>=p.length);++A)l[A+f]=p[A];return A}function Ye(p,l){return p instanceof l||p!=null&&p.constructor!=null&&p.constructor.name!=null&&p.constructor.name===l.name}function ds(p){return p!==p}let Vg=function(){let p="0123456789abcdef",l=new Array(256);for(let f=0;f<16;++f){let b=f*16;for(let A=0;A<16;++A)l[b+A]=p[f]+p[A];}return l}();function Mt(p){return typeof BigInt>"u"?zg:p}function zg(){throw new Error("BigInt not supported")}return Jt}var ui,Vu,Wi,zu,Jt,Ku,Ut,x,ty,ry,ye=we(()=>{v();m();_();ui={},Vu=!1;Wi={},zu=!1;Jt={},Ku=!1;Ut=ey();Ut.Buffer;Ut.SlowBuffer;Ut.INSPECT_MAX_BYTES;Ut.kMaxLength;x=Ut.Buffer,ty=Ut.INSPECT_MAX_BYTES,ry=Ut.kMaxLength;});var v=we(()=>{ye();});var Gu=M(_s=>{v();m();_();Object.defineProperty(_s,"__esModule",{value:!0});var ws=class{constructor(e){this.aliasToTopic={},this.max=e;}put(e,r){return r===0||r>this.max?!1:(this.aliasToTopic[r]=e,this.length=Object.keys(this.aliasToTopic).length,!0)}getTopicByAlias(e){return this.aliasToTopic[e]}clear(){this.aliasToTopic={};}};_s.default=ws;});var ce=M((OA,Qu)=>{v();m();_();Qu.exports={ArrayIsArray(t){return Array.isArray(t)},ArrayPrototypeIncludes(t,e){return t.includes(e)},ArrayPrototypeIndexOf(t,e){return t.indexOf(e)},ArrayPrototypeJoin(t,e){return t.join(e)},ArrayPrototypeMap(t,e){return t.map(e)},ArrayPrototypePop(t,e){return t.pop(e)},ArrayPrototypePush(t,e){return t.push(e)},ArrayPrototypeSlice(t,e,r){return t.slice(e,r)},Error,FunctionPrototypeCall(t,e,...r){return t.call(e,...r)},FunctionPrototypeSymbolHasInstance(t,e){return Function.prototype[Symbol.hasInstance].call(t,e)},MathFloor:Math.floor,Number,NumberIsInteger:Number.isInteger,NumberIsNaN:Number.isNaN,NumberMAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER,NumberMIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,NumberParseInt:Number.parseInt,ObjectDefineProperties(t,e){return Object.defineProperties(t,e)},ObjectDefineProperty(t,e,r){return Object.defineProperty(t,e,r)},ObjectGetOwnPropertyDescriptor(t,e){return Object.getOwnPropertyDescriptor(t,e)},ObjectKeys(t){return Object.keys(t)},ObjectSetPrototypeOf(t,e){return Object.setPrototypeOf(t,e)},Promise,PromisePrototypeCatch(t,e){return t.catch(e)},PromisePrototypeThen(t,e,r){return t.then(e,r)},PromiseReject(t){return Promise.reject(t)},ReflectApply:Reflect.apply,RegExpPrototypeTest(t,e){return t.test(e)},SafeSet:Set,String,StringPrototypeSlice(t,e,r){return t.slice(e,r)},StringPrototypeToLowerCase(t){return t.toLowerCase()},StringPrototypeToUpperCase(t){return t.toUpperCase()},StringPrototypeTrim(t){return t.trim()},Symbol,SymbolFor:Symbol.for,SymbolAsyncIterator:Symbol.asyncIterator,SymbolHasInstance:Symbol.hasInstance,SymbolIterator:Symbol.iterator,TypedArrayPrototypeSet(t,e,r){return t.set(e,r)},Uint8Array};});var Je=M((WA,vs)=>{v();m();_();var iy=(ye(),X(_e)),ny=Object.getPrototypeOf(async function(){}).constructor,Yu=globalThis.Blob||iy.Blob,sy=typeof Yu<"u"?function(e){return e instanceof Yu}:function(e){return !1},ms=class extends Error{constructor(e){if(!Array.isArray(e))throw new TypeError(`Expected input to be an Array, got ${typeof e}`);let r="";for(let i=0;i<e.length;i++)r+=`    ${e[i].stack}
`;super(r),this.name="AggregateError",this.errors=e;}};vs.exports={AggregateError:ms,kEmptyObject:Object.freeze({}),once(t){let e=!1;return function(...r){e||(e=!0,t.apply(this,r));}},createDeferredPromise:function(){let t,e;return {promise:new Promise((i,n)=>{t=i,e=n;}),resolve:t,reject:e}},promisify(t){return new Promise((e,r)=>{t((i,...n)=>i?r(i):e(...n));})},debuglog(){return function(){}},format(t,...e){return t.replace(/%([sdifj])/g,function(...[r,i]){let n=e.shift();return i==="f"?n.toFixed(6):i==="j"?JSON.stringify(n):i==="s"&&typeof n=="object"?`${n.constructor!==Object?n.constructor.name:""} {}`.trim():n.toString()})},inspect(t){switch(typeof t){case"string":if(t.includes("'"))if(t.includes('"')){if(!t.includes("`")&&!t.includes("${"))return `\`${t}\``}else return `"${t}"`;return `'${t}'`;case"number":return isNaN(t)?"NaN":Object.is(t,-0)?String(t):t;case"bigint":return `${String(t)}n`;case"boolean":case"undefined":return String(t);case"object":return "{}"}},types:{isAsyncFunction(t){return t instanceof ny},isArrayBufferView(t){return ArrayBuffer.isView(t)}},isBlob:sy};vs.exports.promisify.custom=Symbol.for("nodejs.util.promisify.custom");});var Hi=M((XA,$i)=>{v();m();_();var{AbortController:Ju,AbortSignal:oy}=typeof self<"u"?self:typeof window<"u"?window:void 0;$i.exports=Ju;$i.exports.AbortSignal=oy;$i.exports.default=Ju;});var Se=M((lI,ef)=>{v();m();_();var{format:ay,inspect:Vi,AggregateError:ly}=Je(),uy=globalThis.AggregateError||ly,fy=Symbol("kIsNodeError"),cy=["string","function","number","object","Function","Object","boolean","bigint","symbol"],hy=/^([A-Z][a-z0-9]*)+$/,dy="__node_internal_",zi={};function Xt(t,e){if(!t)throw new zi.ERR_INTERNAL_ASSERTION(e)}function Xu(t){let e="",r=t.length,i=t[0]==="-"?1:0;for(;r>=i+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return `${t.slice(0,r)}${e}`}function py(t,e,r){if(typeof e=="function")return Xt(e.length<=r.length,`Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`),e(...r);let i=(e.match(/%[dfijoOs]/g)||[]).length;return Xt(i===r.length,`Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${i}).`),r.length===0?e:ay(e,...r)}function me(t,e,r){r||(r=Error);class i extends r{constructor(...o){super(py(t,e,o));}toString(){return `${this.name} [${t}]: ${this.message}`}}Object.defineProperties(i.prototype,{name:{value:r.name,writable:!0,enumerable:!1,configurable:!0},toString:{value(){return `${this.name} [${t}]: ${this.message}`},writable:!0,enumerable:!1,configurable:!0}}),i.prototype.code=t,i.prototype[fy]=!0,zi[t]=i;}function Zu(t){let e=dy+t.name;return Object.defineProperty(t,"name",{value:e}),t}function gy(t,e){if(t&&e&&t!==e){if(Array.isArray(e.errors))return e.errors.push(t),e;let r=new uy([e,t],e.message);return r.code=e.code,r}return t||e}var Es=class extends Error{constructor(e="The operation was aborted",r=void 0){if(r!==void 0&&typeof r!="object")throw new zi.ERR_INVALID_ARG_TYPE("options","Object",r);super(e,r),this.code="ABORT_ERR",this.name="AbortError";}};me("ERR_ASSERTION","%s",Error);me("ERR_INVALID_ARG_TYPE",(t,e,r)=>{Xt(typeof t=="string","'name' must be a string"),Array.isArray(e)||(e=[e]);let i="The ";t.endsWith(" argument")?i+=`${t} `:i+=`"${t}" ${t.includes(".")?"property":"argument"} `,i+="must be ";let n=[],o=[],s=[];for(let u of e)Xt(typeof u=="string","All expected entries have to be of type string"),cy.includes(u)?n.push(u.toLowerCase()):hy.test(u)?o.push(u):(Xt(u!=="object",'The value "object" should be written as "Object"'),s.push(u));if(o.length>0){let u=n.indexOf("object");u!==-1&&(n.splice(n,u,1),o.push("Object"));}if(n.length>0){switch(n.length){case 1:i+=`of type ${n[0]}`;break;case 2:i+=`one of type ${n[0]} or ${n[1]}`;break;default:{let u=n.pop();i+=`one of type ${n.join(", ")}, or ${u}`;}}(o.length>0||s.length>0)&&(i+=" or ");}if(o.length>0){switch(o.length){case 1:i+=`an instance of ${o[0]}`;break;case 2:i+=`an instance of ${o[0]} or ${o[1]}`;break;default:{let u=o.pop();i+=`an instance of ${o.join(", ")}, or ${u}`;}}s.length>0&&(i+=" or ");}switch(s.length){case 0:break;case 1:s[0].toLowerCase()!==s[0]&&(i+="an "),i+=`${s[0]}`;break;case 2:i+=`one of ${s[0]} or ${s[1]}`;break;default:{let u=s.pop();i+=`one of ${s.join(", ")}, or ${u}`;}}if(r==null)i+=`. Received ${r}`;else if(typeof r=="function"&&r.name)i+=`. Received function ${r.name}`;else if(typeof r=="object"){var a;if((a=r.constructor)!==null&&a!==void 0&&a.name)i+=`. Received an instance of ${r.constructor.name}`;else {let u=Vi(r,{depth:-1});i+=`. Received ${u}`;}}else {let u=Vi(r,{colors:!1});u.length>25&&(u=`${u.slice(0,25)}...`),i+=`. Received type ${typeof r} (${u})`;}return i},TypeError);me("ERR_INVALID_ARG_VALUE",(t,e,r="is invalid")=>{let i=Vi(e);return i.length>128&&(i=i.slice(0,128)+"..."),`The ${t.includes(".")?"property":"argument"} '${t}' ${r}. Received ${i}`},TypeError);me("ERR_INVALID_RETURN_VALUE",(t,e,r)=>{var i;let n=r!=null&&(i=r.constructor)!==null&&i!==void 0&&i.name?`instance of ${r.constructor.name}`:`type ${typeof r}`;return `Expected ${t} to be returned from the "${e}" function but got ${n}.`},TypeError);me("ERR_MISSING_ARGS",(...t)=>{Xt(t.length>0,"At least one arg needs to be specified");let e,r=t.length;switch(t=(Array.isArray(t)?t:[t]).map(i=>`"${i}"`).join(" or "),r){case 1:e+=`The ${t[0]} argument`;break;case 2:e+=`The ${t[0]} and ${t[1]} arguments`;break;default:{let i=t.pop();e+=`The ${t.join(", ")}, and ${i} arguments`;}break}return `${e} must be specified`},TypeError);me("ERR_OUT_OF_RANGE",(t,e,r)=>{Xt(e,'Missing "range" argument');let i;return Number.isInteger(r)&&Math.abs(r)>2**32?i=Xu(String(r)):typeof r=="bigint"?(i=String(r),(r>2n**32n||r<-(2n**32n))&&(i=Xu(i)),i+="n"):i=Vi(r),`The value of "${t}" is out of range. It must be ${e}. Received ${i}`},RangeError);me("ERR_MULTIPLE_CALLBACK","Callback called multiple times",Error);me("ERR_METHOD_NOT_IMPLEMENTED","The %s method is not implemented",Error);me("ERR_STREAM_ALREADY_FINISHED","Cannot call %s after a stream was finished",Error);me("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable",Error);me("ERR_STREAM_DESTROYED","Cannot call %s after a stream was destroyed",Error);me("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError);me("ERR_STREAM_PREMATURE_CLOSE","Premature close",Error);me("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF",Error);me("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event",Error);me("ERR_STREAM_WRITE_AFTER_END","write after end",Error);me("ERR_UNKNOWN_ENCODING","Unknown encoding: %s",TypeError);ef.exports={AbortError:Es,aggregateTwoErrors:Zu(gy),hideStackFrames:Zu,codes:zi};});var fi=M((wI,ff)=>{v();m();_();var{ArrayIsArray:As,ArrayPrototypeIncludes:sf,ArrayPrototypeJoin:of,ArrayPrototypeMap:yy,NumberIsInteger:Is,NumberIsNaN:by,NumberMAX_SAFE_INTEGER:wy,NumberMIN_SAFE_INTEGER:_y,NumberParseInt:my,ObjectPrototypeHasOwnProperty:vy,RegExpPrototypeExec:af,String:Ey,StringPrototypeToUpperCase:Sy,StringPrototypeTrim:Ay}=ce(),{hideStackFrames:Ue,codes:{ERR_SOCKET_BAD_PORT:Iy,ERR_INVALID_ARG_TYPE:Ae,ERR_INVALID_ARG_VALUE:Mr,ERR_OUT_OF_RANGE:Zt,ERR_UNKNOWN_SIGNAL:tf}}=Se(),{normalizeEncoding:Ty}=Je(),{isAsyncFunction:Ry,isArrayBufferView:Cy}=Je().types,rf={};function By(t){return t===(t|0)}function Py(t){return t===t>>>0}var ky=/^[0-7]+$/,Oy="must be a 32-bit unsigned integer or an octal string";function xy(t,e,r){if(typeof t>"u"&&(t=r),typeof t=="string"){if(af(ky,t)===null)throw new Mr(e,t,Oy);t=my(t,8);}return lf(t,e),t}var My=Ue((t,e,r=_y,i=wy)=>{if(typeof t!="number")throw new Ae(e,"number",t);if(!Is(t))throw new Zt(e,"an integer",t);if(t<r||t>i)throw new Zt(e,`>= ${r} && <= ${i}`,t)}),Ly=Ue((t,e,r=-2147483648,i=2147483647)=>{if(typeof t!="number")throw new Ae(e,"number",t);if(!Is(t))throw new Zt(e,"an integer",t);if(t<r||t>i)throw new Zt(e,`>= ${r} && <= ${i}`,t)}),lf=Ue((t,e,r=!1)=>{if(typeof t!="number")throw new Ae(e,"number",t);if(!Is(t))throw new Zt(e,"an integer",t);let i=r?1:0,n=4294967295;if(t<i||t>n)throw new Zt(e,`>= ${i} && <= ${n}`,t)});function Ts(t,e){if(typeof t!="string")throw new Ae(e,"string",t)}function Uy(t,e,r=void 0,i){if(typeof t!="number")throw new Ae(e,"number",t);if(r!=null&&t<r||i!=null&&t>i||(r!=null||i!=null)&&by(t))throw new Zt(e,`${r!=null?`>= ${r}`:""}${r!=null&&i!=null?" && ":""}${i!=null?`<= ${i}`:""}`,t)}var Ny=Ue((t,e,r)=>{if(!sf(r,t)){let n="must be one of: "+of(yy(r,o=>typeof o=="string"?`'${o}'`:Ey(o)),", ");throw new Mr(e,t,n)}});function uf(t,e){if(typeof t!="boolean")throw new Ae(e,"boolean",t)}function Ss(t,e,r){return t==null||!vy(t,e)?r:t[e]}var qy=Ue((t,e,r=null)=>{let i=Ss(r,"allowArray",!1),n=Ss(r,"allowFunction",!1);if(!Ss(r,"nullable",!1)&&t===null||!i&&As(t)||typeof t!="object"&&(!n||typeof t!="function"))throw new Ae(e,"Object",t)}),Dy=Ue((t,e)=>{if(t!=null&&typeof t!="object"&&typeof t!="function")throw new Ae(e,"a dictionary",t)}),Rs=Ue((t,e,r=0)=>{if(!As(t))throw new Ae(e,"Array",t);if(t.length<r){let i=`must be longer than ${r}`;throw new Mr(e,t,i)}});function jy(t,e){Rs(t,e);for(let r=0;r<t.length;r++)Ts(t[r],`${e}[${r}]`);}function Fy(t,e){Rs(t,e);for(let r=0;r<t.length;r++)uf(t[r],`${e}[${r}]`);}function Wy(t,e="signal"){if(Ts(t,e),rf[t]===void 0)throw rf[Sy(t)]!==void 0?new tf(t+" (signals must use all capital letters)"):new tf(t)}var $y=Ue((t,e="buffer")=>{if(!Cy(t))throw new Ae(e,["Buffer","TypedArray","DataView"],t)});function Hy(t,e){let r=Ty(e),i=t.length;if(r==="hex"&&i%2!==0)throw new Mr("encoding",e,`is invalid for data of length ${i}`)}function Vy(t,e="Port",r=!0){if(typeof t!="number"&&typeof t!="string"||typeof t=="string"&&Ay(t).length===0||+t!==+t>>>0||t>65535||t===0&&!r)throw new Iy(e,t,r);return t|0}var zy=Ue((t,e)=>{if(t!==void 0&&(t===null||typeof t!="object"||!("aborted"in t)))throw new Ae(e,"AbortSignal",t)}),Ky=Ue((t,e)=>{if(typeof t!="function")throw new Ae(e,"Function",t)}),Gy=Ue((t,e)=>{if(typeof t!="function"||Ry(t))throw new Ae(e,"Function",t)}),Qy=Ue((t,e)=>{if(t!==void 0)throw new Ae(e,"undefined",t)});function Yy(t,e,r){if(!sf(r,t))throw new Ae(e,`('${of(r,"|")}')`,t)}var Jy=/^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;function nf(t,e){if(typeof t>"u"||!af(Jy,t))throw new Mr(e,t,'must be an array or string of format "</styles.css>; rel=preload; as=style"')}function Xy(t){if(typeof t=="string")return nf(t,"hints"),t;if(As(t)){let e=t.length,r="";if(e===0)return r;for(let i=0;i<e;i++){let n=t[i];nf(n,"hints"),r+=n,i!==e-1&&(r+=", ");}return r}throw new Mr("hints",t,'must be an array or string of format "</styles.css>; rel=preload; as=style"')}ff.exports={isInt32:By,isUint32:Py,parseFileMode:xy,validateArray:Rs,validateStringArray:jy,validateBooleanArray:Fy,validateBoolean:uf,validateBuffer:$y,validateDictionary:Dy,validateEncoding:Hy,validateFunction:Ky,validateInt32:Ly,validateInteger:My,validateNumber:Uy,validateObject:qy,validateOneOf:Ny,validatePlainFunction:Gy,validatePort:Vy,validateSignalName:Wy,validateString:Ts,validateUint32:lf,validateUndefined:Qy,validateUnion:Yy,validateAbortSignal:zy,validateLinkHeaderValue:Xy};});var Nt=M((CI,pf)=>{v();m();_();var ae=pf.exports={},Xe,Ze;function Cs(){throw new Error("setTimeout has not been defined")}function Bs(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?Xe=setTimeout:Xe=Cs;}catch{Xe=Cs;}try{typeof clearTimeout=="function"?Ze=clearTimeout:Ze=Bs;}catch{Ze=Bs;}})();function cf(t){if(Xe===setTimeout)return setTimeout(t,0);if((Xe===Cs||!Xe)&&setTimeout)return Xe=setTimeout,setTimeout(t,0);try{return Xe(t,0)}catch{try{return Xe.call(null,t,0)}catch{return Xe.call(this,t,0)}}}function Zy(t){if(Ze===clearTimeout)return clearTimeout(t);if((Ze===Bs||!Ze)&&clearTimeout)return Ze=clearTimeout,clearTimeout(t);try{return Ze(t)}catch{try{return Ze.call(null,t)}catch{return Ze.call(this,t)}}}var _t=[],Lr=!1,er,Ki=-1;function eb(){!Lr||!er||(Lr=!1,er.length?_t=er.concat(_t):Ki=-1,_t.length&&hf());}function hf(){if(!Lr){var t=cf(eb);Lr=!0;for(var e=_t.length;e;){for(er=_t,_t=[];++Ki<e;)er&&er[Ki].run();Ki=-1,e=_t.length;}er=null,Lr=!1,Zy(t);}}ae.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];_t.push(new df(t,e)),_t.length===1&&!Lr&&cf(hf);};function df(t,e){this.fun=t,this.array=e;}df.prototype.run=function(){this.fun.apply(null,this.array);};ae.title="browser";ae.browser=!0;ae.env={};ae.argv=[];ae.version="";ae.versions={};function mt(){}ae.on=mt;ae.addListener=mt;ae.once=mt;ae.off=mt;ae.removeListener=mt;ae.removeAllListeners=mt;ae.emit=mt;ae.prependListener=mt;ae.prependOnceListener=mt;ae.listeners=function(t){return []};ae.binding=function(t){throw new Error("process.binding is not supported")};ae.cwd=function(){return "/"};ae.chdir=function(t){throw new Error("process.chdir is not supported")};ae.umask=function(){return 0};});var tt=M((qI,Pf)=>{v();m();_();var{Symbol:Gi,SymbolAsyncIterator:gf,SymbolIterator:yf,SymbolFor:bf}=ce(),wf=Gi("kDestroyed"),_f=Gi("kIsErrored"),Ps=Gi("kIsReadable"),mf=Gi("kIsDisturbed"),tb=bf("nodejs.webstream.isClosedPromise"),rb=bf("nodejs.webstream.controllerErrorFunction");function Qi(t,e=!1){var r;return !!(t&&typeof t.pipe=="function"&&typeof t.on=="function"&&(!e||typeof t.pause=="function"&&typeof t.resume=="function")&&(!t._writableState||((r=t._readableState)===null||r===void 0?void 0:r.readable)!==!1)&&(!t._writableState||t._readableState))}function Yi(t){var e;return !!(t&&typeof t.write=="function"&&typeof t.on=="function"&&(!t._readableState||((e=t._writableState)===null||e===void 0?void 0:e.writable)!==!1))}function ib(t){return !!(t&&typeof t.pipe=="function"&&t._readableState&&typeof t.on=="function"&&typeof t.write=="function")}function et(t){return t&&(t._readableState||t._writableState||typeof t.write=="function"&&typeof t.on=="function"||typeof t.pipe=="function"&&typeof t.on=="function")}function vf(t){return !!(t&&!et(t)&&typeof t.pipeThrough=="function"&&typeof t.getReader=="function"&&typeof t.cancel=="function")}function Ef(t){return !!(t&&!et(t)&&typeof t.getWriter=="function"&&typeof t.abort=="function")}function Sf(t){return !!(t&&!et(t)&&typeof t.readable=="object"&&typeof t.writable=="object")}function nb(t){return vf(t)||Ef(t)||Sf(t)}function sb(t,e){return t==null?!1:e===!0?typeof t[gf]=="function":e===!1?typeof t[yf]=="function":typeof t[gf]=="function"||typeof t[yf]=="function"}function Ji(t){if(!et(t))return null;let e=t._writableState,r=t._readableState,i=e||r;return !!(t.destroyed||t[wf]||i!=null&&i.destroyed)}function Af(t){if(!Yi(t))return null;if(t.writableEnded===!0)return !0;let e=t._writableState;return e!=null&&e.errored?!1:typeof e?.ended!="boolean"?null:e.ended}function ob(t,e){if(!Yi(t))return null;if(t.writableFinished===!0)return !0;let r=t._writableState;return r!=null&&r.errored?!1:typeof r?.finished!="boolean"?null:!!(r.finished||e===!1&&r.ended===!0&&r.length===0)}function ab(t){if(!Qi(t))return null;if(t.readableEnded===!0)return !0;let e=t._readableState;return !e||e.errored?!1:typeof e?.ended!="boolean"?null:e.ended}function If(t,e){if(!Qi(t))return null;let r=t._readableState;return r!=null&&r.errored?!1:typeof r?.endEmitted!="boolean"?null:!!(r.endEmitted||e===!1&&r.ended===!0&&r.length===0)}function Tf(t){return t&&t[Ps]!=null?t[Ps]:typeof t?.readable!="boolean"?null:Ji(t)?!1:Qi(t)&&t.readable&&!If(t)}function Rf(t){return typeof t?.writable!="boolean"?null:Ji(t)?!1:Yi(t)&&t.writable&&!Af(t)}function lb(t,e){return et(t)?Ji(t)?!0:!(e?.readable!==!1&&Tf(t)||e?.writable!==!1&&Rf(t)):null}function ub(t){var e,r;return et(t)?t.writableErrored?t.writableErrored:(e=(r=t._writableState)===null||r===void 0?void 0:r.errored)!==null&&e!==void 0?e:null:null}function fb(t){var e,r;return et(t)?t.readableErrored?t.readableErrored:(e=(r=t._readableState)===null||r===void 0?void 0:r.errored)!==null&&e!==void 0?e:null:null}function cb(t){if(!et(t))return null;if(typeof t.closed=="boolean")return t.closed;let e=t._writableState,r=t._readableState;return typeof e?.closed=="boolean"||typeof r?.closed=="boolean"?e?.closed||r?.closed:typeof t._closed=="boolean"&&Cf(t)?t._closed:null}function Cf(t){return typeof t._closed=="boolean"&&typeof t._defaultKeepAlive=="boolean"&&typeof t._removedConnection=="boolean"&&typeof t._removedContLen=="boolean"}function Bf(t){return typeof t._sent100=="boolean"&&Cf(t)}function hb(t){var e;return typeof t._consuming=="boolean"&&typeof t._dumped=="boolean"&&((e=t.req)===null||e===void 0?void 0:e.upgradeOrConnect)===void 0}function db(t){if(!et(t))return null;let e=t._writableState,r=t._readableState,i=e||r;return !i&&Bf(t)||!!(i&&i.autoDestroy&&i.emitClose&&i.closed===!1)}function pb(t){var e;return !!(t&&((e=t[mf])!==null&&e!==void 0?e:t.readableDidRead||t.readableAborted))}function gb(t){var e,r,i,n,o,s,a,u,c,h;return !!(t&&((e=(r=(i=(n=(o=(s=t[_f])!==null&&s!==void 0?s:t.readableErrored)!==null&&o!==void 0?o:t.writableErrored)!==null&&n!==void 0?n:(a=t._readableState)===null||a===void 0?void 0:a.errorEmitted)!==null&&i!==void 0?i:(u=t._writableState)===null||u===void 0?void 0:u.errorEmitted)!==null&&r!==void 0?r:(c=t._readableState)===null||c===void 0?void 0:c.errored)!==null&&e!==void 0?e:!((h=t._writableState)===null||h===void 0)&&h.errored))}Pf.exports={kDestroyed:wf,isDisturbed:pb,kIsDisturbed:mf,isErrored:gb,kIsErrored:_f,isReadable:Tf,kIsReadable:Ps,kIsClosedPromise:tb,kControllerErrorFunction:rb,isClosed:cb,isDestroyed:Ji,isDuplexNodeStream:ib,isFinished:lb,isIterable:sb,isReadableNodeStream:Qi,isReadableStream:vf,isReadableEnded:ab,isReadableFinished:If,isReadableErrored:fb,isNodeStream:et,isWebStream:nb,isWritable:Rf,isWritableNodeStream:Yi,isWritableStream:Ef,isWritableEnded:Af,isWritableFinished:ob,isWritableErrored:ub,isServerRequest:hb,isServerResponse:Bf,willEmitClose:db,isTransformStream:Sf};});var vt=M((GI,Ls)=>{v();m();_();var qt=Nt(),{AbortError:Df,codes:yb}=Se(),{ERR_INVALID_ARG_TYPE:bb,ERR_STREAM_PREMATURE_CLOSE:kf}=yb,{kEmptyObject:Os,once:xs}=Je(),{validateAbortSignal:wb,validateFunction:_b,validateObject:mb,validateBoolean:vb}=fi(),{Promise:Eb,PromisePrototypeThen:Sb}=ce(),{isClosed:Ab,isReadable:Of,isReadableNodeStream:ks,isReadableStream:Ib,isReadableFinished:xf,isReadableErrored:Mf,isWritable:Lf,isWritableNodeStream:Uf,isWritableStream:Tb,isWritableFinished:Nf,isWritableErrored:qf,isNodeStream:Rb,willEmitClose:Cb,kIsClosedPromise:Bb}=tt();function Pb(t){return t.setHeader&&typeof t.abort=="function"}var Ms=()=>{};function jf(t,e,r){var i,n;if(arguments.length===2?(r=e,e=Os):e==null?e=Os:mb(e,"options"),_b(r,"callback"),wb(e.signal,"options.signal"),r=xs(r),Ib(t)||Tb(t))return kb(t,e,r);if(!Rb(t))throw new bb("stream",["ReadableStream","WritableStream","Stream"],t);let o=(i=e.readable)!==null&&i!==void 0?i:ks(t),s=(n=e.writable)!==null&&n!==void 0?n:Uf(t),a=t._writableState,u=t._readableState,c=()=>{t.writable||g();},h=Cb(t)&&ks(t)===o&&Uf(t)===s,d=Nf(t,!1),g=()=>{d=!0,t.destroyed&&(h=!1),!(h&&(!t.readable||o))&&(!o||y)&&r.call(t);},y=xf(t,!1),w=()=>{y=!0,t.destroyed&&(h=!1),!(h&&(!t.writable||s))&&(!s||d)&&r.call(t);},E=N=>{r.call(t,N);},S=Ab(t),I=()=>{S=!0;let N=qf(t)||Mf(t);if(N&&typeof N!="boolean")return r.call(t,N);if(o&&!y&&ks(t,!0)&&!xf(t,!1))return r.call(t,new kf);if(s&&!d&&!Nf(t,!1))return r.call(t,new kf);r.call(t);},B=()=>{S=!0;let N=qf(t)||Mf(t);if(N&&typeof N!="boolean")return r.call(t,N);r.call(t);},R=()=>{t.req.on("finish",g);};Pb(t)?(t.on("complete",g),h||t.on("abort",I),t.req?R():t.on("request",R)):s&&!a&&(t.on("end",c),t.on("close",c)),!h&&typeof t.aborted=="boolean"&&t.on("aborted",I),t.on("end",w),t.on("finish",g),e.error!==!1&&t.on("error",E),t.on("close",I),S?qt.nextTick(I):a!=null&&a.errorEmitted||u!=null&&u.errorEmitted?h||qt.nextTick(B):(!o&&(!h||Of(t))&&(d||Lf(t)===!1)||!s&&(!h||Lf(t))&&(y||Of(t)===!1)||u&&t.req&&t.aborted)&&qt.nextTick(B);let U=()=>{r=Ms,t.removeListener("aborted",I),t.removeListener("complete",g),t.removeListener("abort",I),t.removeListener("request",R),t.req&&t.req.removeListener("finish",g),t.removeListener("end",c),t.removeListener("close",c),t.removeListener("finish",g),t.removeListener("end",w),t.removeListener("error",E),t.removeListener("close",I);};if(e.signal&&!S){let N=()=>{let W=r;U(),W.call(t,new Df(void 0,{cause:e.signal.reason}));};if(e.signal.aborted)qt.nextTick(N);else {let W=r;r=xs((...K)=>{e.signal.removeEventListener("abort",N),W.apply(t,K);}),e.signal.addEventListener("abort",N);}}return U}function kb(t,e,r){let i=!1,n=Ms;if(e.signal)if(n=()=>{i=!0,r.call(t,new Df(void 0,{cause:e.signal.reason}));},e.signal.aborted)qt.nextTick(n);else {let s=r;r=xs((...a)=>{e.signal.removeEventListener("abort",n),s.apply(t,a);}),e.signal.addEventListener("abort",n);}let o=(...s)=>{i||qt.nextTick(()=>r.apply(t,s));};return Sb(t[Bb].promise,o,o),Ms}function Ob(t,e){var r;let i=!1;return e===null&&(e=Os),(r=e)!==null&&r!==void 0&&r.cleanup&&(vb(e.cleanup,"cleanup"),i=e.cleanup),new Eb((n,o)=>{let s=jf(t,e,a=>{i&&s(),a?o(a):n();});})}Ls.exports=jf;Ls.exports.finished=Ob;});var tr=M((nT,Gf)=>{v();m();_();var rt=Nt(),{aggregateTwoErrors:xb,codes:{ERR_MULTIPLE_CALLBACK:Mb},AbortError:Lb}=Se(),{Symbol:$f}=ce(),{kDestroyed:Ub,isDestroyed:Nb,isFinished:qb,isServerRequest:Db}=tt(),Hf=$f("kDestroy"),Us=$f("kConstruct");function Vf(t,e,r){t&&(t.stack,e&&!e.errored&&(e.errored=t),r&&!r.errored&&(r.errored=t));}function jb(t,e){let r=this._readableState,i=this._writableState,n=i||r;return i!=null&&i.destroyed||r!=null&&r.destroyed?(typeof e=="function"&&e(),this):(Vf(t,i,r),i&&(i.destroyed=!0),r&&(r.destroyed=!0),n.constructed?Ff(this,t,e):this.once(Hf,function(o){Ff(this,xb(o,t),e);}),this)}function Ff(t,e,r){let i=!1;function n(o){if(i)return;i=!0;let s=t._readableState,a=t._writableState;Vf(o,a,s),a&&(a.closed=!0),s&&(s.closed=!0),typeof r=="function"&&r(o),o?rt.nextTick(Fb,t,o):rt.nextTick(zf,t);}try{t._destroy(e||null,n);}catch(o){n(o);}}function Fb(t,e){Ns(t,e),zf(t);}function zf(t){let e=t._readableState,r=t._writableState;r&&(r.closeEmitted=!0),e&&(e.closeEmitted=!0),(r!=null&&r.emitClose||e!=null&&e.emitClose)&&t.emit("close");}function Ns(t,e){let r=t._readableState,i=t._writableState;i!=null&&i.errorEmitted||r!=null&&r.errorEmitted||(i&&(i.errorEmitted=!0),r&&(r.errorEmitted=!0),t.emit("error",e));}function Wb(){let t=this._readableState,e=this._writableState;t&&(t.constructed=!0,t.closed=!1,t.closeEmitted=!1,t.destroyed=!1,t.errored=null,t.errorEmitted=!1,t.reading=!1,t.ended=t.readable===!1,t.endEmitted=t.readable===!1),e&&(e.constructed=!0,e.destroyed=!1,e.closed=!1,e.closeEmitted=!1,e.errored=null,e.errorEmitted=!1,e.finalCalled=!1,e.prefinished=!1,e.ended=e.writable===!1,e.ending=e.writable===!1,e.finished=e.writable===!1);}function qs(t,e,r){let i=t._readableState,n=t._writableState;if(n!=null&&n.destroyed||i!=null&&i.destroyed)return this;i!=null&&i.autoDestroy||n!=null&&n.autoDestroy?t.destroy(e):e&&(e.stack,n&&!n.errored&&(n.errored=e),i&&!i.errored&&(i.errored=e),r?rt.nextTick(Ns,t,e):Ns(t,e));}function $b(t,e){if(typeof t._construct!="function")return;let r=t._readableState,i=t._writableState;r&&(r.constructed=!1),i&&(i.constructed=!1),t.once(Us,e),!(t.listenerCount(Us)>1)&&rt.nextTick(Hb,t);}function Hb(t){let e=!1;function r(i){if(e){qs(t,i??new Mb);return}e=!0;let n=t._readableState,o=t._writableState,s=o||n;n&&(n.constructed=!0),o&&(o.constructed=!0),s.destroyed?t.emit(Hf,i):i?qs(t,i,!0):rt.nextTick(Vb,t);}try{t._construct(i=>{rt.nextTick(r,i);});}catch(i){rt.nextTick(r,i);}}function Vb(t){t.emit(Us);}function Wf(t){return t?.setHeader&&typeof t.abort=="function"}function Kf(t){t.emit("close");}function zb(t,e){t.emit("error",e),rt.nextTick(Kf,t);}function Kb(t,e){!t||Nb(t)||(!e&&!qb(t)&&(e=new Lb),Db(t)?(t.socket=null,t.destroy(e)):Wf(t)?t.abort():Wf(t.req)?t.req.abort():typeof t.destroy=="function"?t.destroy(e):typeof t.close=="function"?t.close():e?rt.nextTick(zb,t,e):rt.nextTick(Kf,t),t.destroyed||(t[Ub]=!0));}Gf.exports={construct:$b,destroyer:Kb,destroy:jb,undestroy:Wb,errorOrDestroy:qs};});function Y(){Y.init.call(this);}function Xi(t){if(typeof t!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function nc(t){return t._maxListeners===void 0?Y.defaultMaxListeners:t._maxListeners}function Xf(t,e,r,i){var n,o,s,a;if(Xi(r),(o=t._events)===void 0?(o=t._events=Object.create(null),t._eventsCount=0):(o.newListener!==void 0&&(t.emit("newListener",e,r.listener?r.listener:r),o=t._events),s=o[e]),s===void 0)s=o[e]=r,++t._eventsCount;else if(typeof s=="function"?s=o[e]=i?[r,s]:[s,r]:i?s.unshift(r):s.push(r),(n=nc(t))>0&&s.length>n&&!s.warned){s.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=s.length,a=u,console&&console.warn&&console.warn(a);}return t}function Gb(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Zf(t,e,r){var i={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},n=Gb.bind(i);return n.listener=r,i.wrapFn=n,n}function ec(t,e,r){var i=t._events;if(i===void 0)return [];var n=i[e];return n===void 0?[]:typeof n=="function"?r?[n.listener||n]:[n]:r?function(o){for(var s=new Array(o.length),a=0;a<s.length;++a)s[a]=o[a].listener||o[a];return s}(n):sc(n,n.length)}function tc(t){var e=this._events;if(e!==void 0){var r=e[t];if(typeof r=="function")return 1;if(r!==void 0)return r.length}return 0}function sc(t,e){for(var r=new Array(e),i=0;i<e;++i)r[i]=t[i];return r}var rc,ic,Ur,Qf,Yf,Jf,Be,Ds=we(()=>{v();m();_();Ur=typeof Reflect=="object"?Reflect:null,Qf=Ur&&typeof Ur.apply=="function"?Ur.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};ic=Ur&&typeof Ur.ownKeys=="function"?Ur.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};Yf=Number.isNaN||function(t){return t!=t};rc=Y,Y.EventEmitter=Y,Y.prototype._events=void 0,Y.prototype._eventsCount=0,Y.prototype._maxListeners=void 0;Jf=10;Object.defineProperty(Y,"defaultMaxListeners",{enumerable:!0,get:function(){return Jf},set:function(t){if(typeof t!="number"||t<0||Yf(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");Jf=t;}}),Y.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0;},Y.prototype.setMaxListeners=function(t){if(typeof t!="number"||t<0||Yf(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},Y.prototype.getMaxListeners=function(){return nc(this)},Y.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var i=t==="error",n=this._events;if(n!==void 0)i=i&&n.error===void 0;else if(!i)return !1;if(i){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var s=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw s.context=o,s}var a=n[t];if(a===void 0)return !1;if(typeof a=="function")Qf(a,this,e);else {var u=a.length,c=sc(a,u);for(r=0;r<u;++r)Qf(c[r],this,e);}return !0},Y.prototype.addListener=function(t,e){return Xf(this,t,e,!1)},Y.prototype.on=Y.prototype.addListener,Y.prototype.prependListener=function(t,e){return Xf(this,t,e,!0)},Y.prototype.once=function(t,e){return Xi(e),this.on(t,Zf(this,t,e)),this},Y.prototype.prependOnceListener=function(t,e){return Xi(e),this.prependListener(t,Zf(this,t,e)),this},Y.prototype.removeListener=function(t,e){var r,i,n,o,s;if(Xi(e),(i=this._events)===void 0)return this;if((r=i[t])===void 0)return this;if(r===e||r.listener===e)--this._eventsCount==0?this._events=Object.create(null):(delete i[t],i.removeListener&&this.emit("removeListener",t,r.listener||e));else if(typeof r!="function"){for(n=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){s=r[o].listener,n=o;break}if(n<0)return this;n===0?r.shift():function(a,u){for(;u+1<a.length;u++)a[u]=a[u+1];a.pop();}(r,n),r.length===1&&(i[t]=r[0]),i.removeListener!==void 0&&this.emit("removeListener",t,s||e);}return this},Y.prototype.off=Y.prototype.removeListener,Y.prototype.removeAllListeners=function(t){var e,r,i;if((r=this._events)===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[t]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete r[t]),this;if(arguments.length===0){var n,o=Object.keys(r);for(i=0;i<o.length;++i)(n=o[i])!=="removeListener"&&this.removeAllListeners(n);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(e=r[t])=="function")this.removeListener(t,e);else if(e!==void 0)for(i=e.length-1;i>=0;i--)this.removeListener(t,e[i]);return this},Y.prototype.listeners=function(t){return ec(this,t,!0)},Y.prototype.rawListeners=function(t){return ec(this,t,!1)},Y.listenerCount=function(t,e){return typeof t.listenerCount=="function"?t.listenerCount(e):tc.call(t,e)},Y.prototype.listenerCount=tc,Y.prototype.eventNames=function(){return this._eventsCount>0?ic(this._events):[]};Be=rc;Be.EventEmitter;Be.defaultMaxListeners;Be.init;Be.listenerCount;Be.EventEmitter;Be.defaultMaxListeners;Be.init;Be.listenerCount;});var rr={};Qt(rr,{EventEmitter:()=>Qb,default:()=>Be,defaultMaxListeners:()=>Yb,init:()=>Jb,listenerCount:()=>Xb,on:()=>Zb,once:()=>ew});var Qb,Yb,Jb,Xb,Zb,ew,ir=we(()=>{v();m();_();Ds();Ds();Be.once=function(t,e){return new Promise((r,i)=>{function n(...s){o!==void 0&&t.removeListener("error",o),r(s);}let o;e!=="error"&&(o=s=>{t.removeListener(name,n),i(s);},t.once("error",o)),t.once(e,n);})};Be.on=function(t,e){let r=[],i=[],n=null,o=!1,s={async next(){let c=r.shift();if(c)return createIterResult(c,!1);if(n){let h=Promise.reject(n);return n=null,h}return o?createIterResult(void 0,!0):new Promise((h,d)=>i.push({resolve:h,reject:d}))},async return(){t.removeListener(e,a),t.removeListener("error",u),o=!0;for(let c of i)c.resolve(createIterResult(void 0,!0));return createIterResult(void 0,!0)},throw(c){n=c,t.removeListener(e,a),t.removeListener("error",u);},[Symbol.asyncIterator](){return this}};return t.on(e,a),t.on("error",u),s;function a(...c){let h=i.shift();h?h.resolve(createIterResult(c,!1)):r.push(c);}function u(c){o=!0;let h=i.shift();h?h.reject(c):n=c,s.return();}};({EventEmitter:Qb,defaultMaxListeners:Yb,init:Jb,listenerCount:Xb,on:Zb,once:ew}=Be);});var tn=M((LT,ac)=>{v();m();_();var{ArrayIsArray:tw,ObjectSetPrototypeOf:oc}=ce(),{EventEmitter:Zi}=(ir(),X(rr));function en(t){Zi.call(this,t);}oc(en.prototype,Zi.prototype);oc(en,Zi);en.prototype.pipe=function(t,e){let r=this;function i(h){t.writable&&t.write(h)===!1&&r.pause&&r.pause();}r.on("data",i);function n(){r.readable&&r.resume&&r.resume();}t.on("drain",n),!t._isStdio&&(!e||e.end!==!1)&&(r.on("end",s),r.on("close",a));let o=!1;function s(){o||(o=!0,t.end());}function a(){o||(o=!0,typeof t.destroy=="function"&&t.destroy());}function u(h){c(),Zi.listenerCount(this,"error")===0&&this.emit("error",h);}js(r,"error",u),js(t,"error",u);function c(){r.removeListener("data",i),t.removeListener("drain",n),r.removeListener("end",s),r.removeListener("close",a),r.removeListener("error",u),t.removeListener("error",u),r.removeListener("end",c),r.removeListener("close",c),t.removeListener("close",c);}return r.on("end",c),r.on("close",c),t.on("close",c),t.emit("pipe",r),t};function js(t,e,r){if(typeof t.prependListener=="function")return t.prependListener(e,r);!t._events||!t._events[e]?t.on(e,r):tw(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]];}ac.exports={Stream:en,prependListener:js};});var ci=M((VT,rn)=>{v();m();_();var{AbortError:lc,codes:rw}=Se(),{isNodeStream:uc,isWebStream:iw,kControllerErrorFunction:nw}=tt(),sw=vt(),{ERR_INVALID_ARG_TYPE:fc}=rw,ow=(t,e)=>{if(typeof t!="object"||!("aborted"in t))throw new fc(e,"AbortSignal",t)};rn.exports.addAbortSignal=function(e,r){if(ow(e,"signal"),!uc(r)&&!iw(r))throw new fc("stream",["ReadableStream","WritableStream","Stream"],r);return rn.exports.addAbortSignalNoValidate(e,r)};rn.exports.addAbortSignalNoValidate=function(t,e){if(typeof t!="object"||!("aborted"in t))return e;let r=uc(e)?()=>{e.destroy(new lc(void 0,{cause:t.reason}));}:()=>{e[nw](new lc(void 0,{cause:t.reason}));};return t.aborted?r():(t.addEventListener("abort",r),sw(e,()=>t.removeEventListener("abort",r))),e};});var dc=M((r2,hc)=>{v();m();_();var{StringPrototypeSlice:cc,SymbolIterator:aw,TypedArrayPrototypeSet:nn,Uint8Array:lw}=ce(),{Buffer:Fs}=(ye(),X(_e)),{inspect:uw}=Je();hc.exports=class{constructor(){this.head=null,this.tail=null,this.length=0;}push(e){let r={data:e,next:null};this.length>0?this.tail.next=r:this.head=r,this.tail=r,++this.length;}unshift(e){let r={data:e,next:this.head};this.length===0&&(this.tail=r),this.head=r,++this.length;}shift(){if(this.length===0)return;let e=this.head.data;return this.length===1?this.head=this.tail=null:this.head=this.head.next,--this.length,e}clear(){this.head=this.tail=null,this.length=0;}join(e){if(this.length===0)return "";let r=this.head,i=""+r.data;for(;(r=r.next)!==null;)i+=e+r.data;return i}concat(e){if(this.length===0)return Fs.alloc(0);let r=Fs.allocUnsafe(e>>>0),i=this.head,n=0;for(;i;)nn(r,i.data,n),n+=i.data.length,i=i.next;return r}consume(e,r){let i=this.head.data;if(e<i.length){let n=i.slice(0,e);return this.head.data=i.slice(e),n}return e===i.length?this.shift():r?this._getString(e):this._getBuffer(e)}first(){return this.head.data}*[aw](){for(let e=this.head;e;e=e.next)yield e.data;}_getString(e){let r="",i=this.head,n=0;do{let o=i.data;if(e>o.length)r+=o,e-=o.length;else {e===o.length?(r+=o,++n,i.next?this.head=i.next:this.head=this.tail=null):(r+=cc(o,0,e),this.head=i,i.data=cc(o,e));break}++n;}while((i=i.next)!==null);return this.length-=n,r}_getBuffer(e){let r=Fs.allocUnsafe(e),i=e,n=this.head,o=0;do{let s=n.data;if(e>s.length)nn(r,s,i-e),e-=s.length;else {e===s.length?(nn(r,s,i-e),++o,n.next?this.head=n.next:this.head=this.tail=null):(nn(r,new lw(s.buffer,s.byteOffset,e),i-e),this.head=n,n.data=s.slice(e));break}++o;}while((n=n.next)!==null);return this.length-=o,r}[Symbol.for("nodejs.util.inspect.custom")](e,r){return uw(this,{...r,depth:0,customInspect:!1})}};});var sn=M((h2,gc)=>{v();m();_();var{MathFloor:fw,NumberIsInteger:cw}=ce(),{ERR_INVALID_ARG_VALUE:hw}=Se().codes;function dw(t,e,r){return t.highWaterMark!=null?t.highWaterMark:e?t[r]:null}function pc(t){return t?16:16*1024}function pw(t,e,r,i){let n=dw(e,i,r);if(n!=null){if(!cw(n)||n<0){let o=i?`options.${r}`:"options.highWaterMark";throw new hw(o,n)}return fw(n)}return pc(t.objectMode)}gc.exports={getHighWaterMark:pw,getDefaultHighWaterMark:pc};});function wc(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return r===-1&&(r=e),[r,r===e?0:4-r%4]}function gw(t,e,r){for(var i,n,o=[],s=e;s<r;s+=3)i=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),o.push($e[(n=i)>>18&63]+$e[n>>12&63]+$e[n>>6&63]+$e[63&n]);return o.join("")}function Et(t){if(t>2147483647)throw new RangeError('The value "'+t+'" is invalid for option "size"');var e=new Uint8Array(t);return Object.setPrototypeOf(e,O.prototype),e}function O(t,e,r){if(typeof t=="number"){if(typeof e=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return Vs(t)}return Cc(t,e,r)}function Cc(t,e,r){if(typeof t=="string")return function(o,s){if(typeof s=="string"&&s!==""||(s="utf8"),!O.isEncoding(s))throw new TypeError("Unknown encoding: "+s);var a=0|Pc(o,s),u=Et(a),c=u.write(o,s);return c!==a&&(u=u.slice(0,c)),u}(t,e);if(ArrayBuffer.isView(t))return Ws(t);if(t==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t);if(St(t,ArrayBuffer)||t&&St(t.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(St(t,SharedArrayBuffer)||t&&St(t.buffer,SharedArrayBuffer)))return mc(t,e,r);if(typeof t=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');var i=t.valueOf&&t.valueOf();if(i!=null&&i!==t)return O.from(i,e,r);var n=function(o){if(O.isBuffer(o)){var s=0|Gs(o.length),a=Et(s);return a.length===0||o.copy(a,0,0,s),a}if(o.length!==void 0)return typeof o.length!="number"||Qs(o.length)?Et(0):Ws(o);if(o.type==="Buffer"&&Array.isArray(o.data))return Ws(o.data)}(t);if(n)return n;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof t[Symbol.toPrimitive]=="function")return O.from(t[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t)}function Bc(t){if(typeof t!="number")throw new TypeError('"size" argument must be of type number');if(t<0)throw new RangeError('The value "'+t+'" is invalid for option "size"')}function Vs(t){return Bc(t),Et(t<0?0:0|Gs(t))}function Ws(t){for(var e=t.length<0?0:0|Gs(t.length),r=Et(e),i=0;i<e;i+=1)r[i]=255&t[i];return r}function mc(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');var i;return i=e===void 0&&r===void 0?new Uint8Array(t):r===void 0?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(i,O.prototype),i}function Gs(t){if(t>=2147483647)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+2147483647 .toString(16)+" bytes");return 0|t}function Pc(t,e){if(O.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||St(t,ArrayBuffer))return t.byteLength;if(typeof t!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);var r=t.length,i=arguments.length>2&&arguments[2]===!0;if(!i&&r===0)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return zs(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return Mc(t).length;default:if(n)return i?-1:zs(t).length;e=(""+e).toLowerCase(),n=!0;}}function bw(t,e,r){var i=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0)<=(e>>>=0))return "";for(t||(t="utf8");;)switch(t){case"hex":return Tw(this,e,r);case"utf8":case"utf-8":return Oc(this,e,r);case"ascii":return Aw(this,e,r);case"latin1":case"binary":return Iw(this,e,r);case"base64":return Sw(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Rw(this,e,r);default:if(i)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),i=!0;}}function sr(t,e,r){var i=t[e];t[e]=t[r],t[r]=i;}function vc(t,e,r,i,n){if(t.length===0)return -1;if(typeof r=="string"?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),Qs(r=+r)&&(r=n?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(n)return -1;r=t.length-1;}else if(r<0){if(!n)return -1;r=0;}if(typeof e=="string"&&(e=O.from(e,i)),O.isBuffer(e))return e.length===0?-1:Ec(t,e,r,i,n);if(typeof e=="number")return e&=255,typeof Uint8Array.prototype.indexOf=="function"?n?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):Ec(t,[e],r,i,n);throw new TypeError("val must be string, number or Buffer")}function Ec(t,e,r,i,n){var o,s=1,a=t.length,u=e.length;if(i!==void 0&&((i=String(i).toLowerCase())==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")){if(t.length<2||e.length<2)return -1;s=2,a/=2,u/=2,r/=2;}function c(y,w){return s===1?y[w]:y.readUInt16BE(w*s)}if(n){var h=-1;for(o=r;o<a;o++)if(c(t,o)===c(e,h===-1?0:o-h)){if(h===-1&&(h=o),o-h+1===u)return h*s}else h!==-1&&(o-=o-h),h=-1;}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){for(var d=!0,g=0;g<u;g++)if(c(t,o+g)!==c(e,g)){d=!1;break}if(d)return o}return -1}function ww(t,e,r,i){r=Number(r)||0;var n=t.length-r;i?(i=Number(i))>n&&(i=n):i=n;var o=e.length;i>o/2&&(i=o/2);for(var s=0;s<i;++s){var a=parseInt(e.substr(2*s,2),16);if(Qs(a))return s;t[r+s]=a;}return s}function _w(t,e,r,i){return un(zs(e,t.length-r),t,r,i)}function kc(t,e,r,i){return un(function(n){for(var o=[],s=0;s<n.length;++s)o.push(255&n.charCodeAt(s));return o}(e),t,r,i)}function mw(t,e,r,i){return kc(t,e,r,i)}function vw(t,e,r,i){return un(Mc(e),t,r,i)}function Ew(t,e,r,i){return un(function(n,o){for(var s,a,u,c=[],h=0;h<n.length&&!((o-=2)<0);++h)s=n.charCodeAt(h),a=s>>8,u=s%256,c.push(u),c.push(a);return c}(e,t.length-r),t,r,i)}function Sw(t,e,r){return e===0&&r===t.length?Hs.fromByteArray(t):Hs.fromByteArray(t.slice(e,r))}function Oc(t,e,r){r=Math.min(t.length,r);for(var i=[],n=e;n<r;){var o,s,a,u,c=t[n],h=null,d=c>239?4:c>223?3:c>191?2:1;if(n+d<=r)switch(d){case 1:c<128&&(h=c);break;case 2:(192&(o=t[n+1]))==128&&(u=(31&c)<<6|63&o)>127&&(h=u);break;case 3:o=t[n+1],s=t[n+2],(192&o)==128&&(192&s)==128&&(u=(15&c)<<12|(63&o)<<6|63&s)>2047&&(u<55296||u>57343)&&(h=u);break;case 4:o=t[n+1],s=t[n+2],a=t[n+3],(192&o)==128&&(192&s)==128&&(192&a)==128&&(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&u<1114112&&(h=u);}h===null?(h=65533,d=1):h>65535&&(h-=65536,i.push(h>>>10&1023|55296),h=56320|1023&h),i.push(h),n+=d;}return function(g){var y=g.length;if(y<=4096)return String.fromCharCode.apply(String,g);for(var w="",E=0;E<y;)w+=String.fromCharCode.apply(String,g.slice(E,E+=4096));return w}(i)}function Aw(t,e,r){var i="";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(127&t[n]);return i}function Iw(t,e,r){var i="";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(t[n]);return i}function Tw(t,e,r){var i=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>i)&&(r=i);for(var n="",o=e;o<r;++o)n+=Bw[t[o]];return n}function Rw(t,e,r){for(var i=t.slice(e,r),n="",o=0;o<i.length;o+=2)n+=String.fromCharCode(i[o]+256*i[o+1]);return n}function be(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function Pe(t,e,r,i,n,o){if(!O.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>n||e<o)throw new RangeError('"value" argument is out of bounds');if(r+i>t.length)throw new RangeError("Index out of range")}function xc(t,e,r,i,n,o){if(r+i>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function Sc(t,e,r,i,n){return e=+e,r>>>=0,n||xc(t,0,r,4),Nr.write(t,e,r,i,23,4),r+4}function Ac(t,e,r,i,n){return e=+e,r>>>=0,n||xc(t,0,r,8),Nr.write(t,e,r,i,52,8),r+8}function zs(t,e){var r;e=e||1/0;for(var i=t.length,n=null,o=[],s=0;s<i;++s){if((r=t.charCodeAt(s))>55295&&r<57344){if(!n){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===i){(e-=3)>-1&&o.push(239,191,189);continue}n=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),n=r;continue}r=65536+(n-55296<<10|r-56320);}else n&&(e-=3)>-1&&o.push(239,191,189);if(n=null,r<128){if((e-=1)<0)break;o.push(r);}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128);}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128);}else {if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128);}}return o}function Mc(t){return Hs.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(Cw,"")).length<2)return "";for(;e.length%4!=0;)e+="=";return e}(t))}function un(t,e,r,i){for(var n=0;n<i&&!(n+r>=e.length||n>=t.length);++n)e[n+r]=t[n];return n}function St(t,e){return t instanceof e||t!=null&&t.constructor!=null&&t.constructor.name!=null&&t.constructor.name===e.name}function Qs(t){return t!=t}function Ic(t,e){for(var r in t)e[r]=t[r];}function or(t,e,r){return it(t,e,r)}function hi(t){var e;switch(this.encoding=function(r){var i=function(n){if(!n)return "utf8";for(var o;;)switch(n){case"utf8":case"utf-8":return "utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return "utf16le";case"latin1":case"binary":return "latin1";case"base64":case"ascii":case"hex":return n;default:if(o)return;n=(""+n).toLowerCase(),o=!0;}}(r);if(typeof i!="string"&&(Ks.isEncoding===Tc||!Tc(r)))throw new Error("Unknown encoding: "+r);return i||r}(t),this.encoding){case"utf16le":this.text=Ow,this.end=xw,e=4;break;case"utf8":this.fillLast=kw,e=4;break;case"base64":this.text=Mw,this.end=Lw,e=3;break;default:return this.write=Uw,this.end=Nw,void 0}this.lastNeed=0,this.lastTotal=0,this.lastChar=Ks.allocUnsafe(e);}function $s(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function kw(t){var e=this.lastTotal-this.lastNeed,r=function(i,n,o){if((192&n[0])!=128)return i.lastNeed=0,"\uFFFD";if(i.lastNeed>1&&n.length>1){if((192&n[1])!=128)return i.lastNeed=1,"\uFFFD";if(i.lastNeed>2&&n.length>2&&(192&n[2])!=128)return i.lastNeed=2,"\uFFFD"}}(this,t);return r!==void 0?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),this.lastNeed-=t.length,void 0)}function Ow(t,e){if((t.length-e)%2==0){var r=t.toString("utf16le",e);if(r){var i=r.charCodeAt(r.length-1);if(i>=55296&&i<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString("utf16le",e,t.length-1)}function xw(t){var e=t&&t.length?this.write(t):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString("utf16le",0,r)}return e}function Mw(t,e){var r=(t.length-e)%3;return r===0?t.toString("base64",e):(this.lastNeed=3-r,this.lastTotal=3,r===1?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString("base64",e,t.length-r))}function Lw(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+this.lastChar.toString("base64",0,3-this.lastNeed):e}function Uw(t){return t.toString(this.encoding)}function Nw(t){return t&&t.length?this.write(t):""}var Rc,$e,Oe,yc,on,nr,bc,yw,At,Hs,Nr,_c,Cw,Bw,an,ln,it,Pw,ar,Ks,Tc,Ys=we(()=>{v();m();_();for(Rc={byteLength:function(t){var e=wc(t),r=e[0],i=e[1];return 3*(r+i)/4-i},toByteArray:function(t){var e,r,i=wc(t),n=i[0],o=i[1],s=new yc(function(c,h,d){return 3*(h+d)/4-d}(0,n,o)),a=0,u=o>0?n-4:n;for(r=0;r<u;r+=4)e=Oe[t.charCodeAt(r)]<<18|Oe[t.charCodeAt(r+1)]<<12|Oe[t.charCodeAt(r+2)]<<6|Oe[t.charCodeAt(r+3)],s[a++]=e>>16&255,s[a++]=e>>8&255,s[a++]=255&e;return o===2&&(e=Oe[t.charCodeAt(r)]<<2|Oe[t.charCodeAt(r+1)]>>4,s[a++]=255&e),o===1&&(e=Oe[t.charCodeAt(r)]<<10|Oe[t.charCodeAt(r+1)]<<4|Oe[t.charCodeAt(r+2)]>>2,s[a++]=e>>8&255,s[a++]=255&e),s},fromByteArray:function(t){for(var e,r=t.length,i=r%3,n=[],o=0,s=r-i;o<s;o+=16383)n.push(gw(t,o,o+16383>s?s:o+16383));return i===1?(e=t[r-1],n.push($e[e>>2]+$e[e<<4&63]+"==")):i===2&&(e=(t[r-2]<<8)+t[r-1],n.push($e[e>>10]+$e[e>>4&63]+$e[e<<2&63]+"=")),n.join("")}},$e=[],Oe=[],yc=typeof Uint8Array<"u"?Uint8Array:Array,on="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",nr=0,bc=on.length;nr<bc;++nr)$e[nr]=on[nr],Oe[on.charCodeAt(nr)]=nr;Oe["-".charCodeAt(0)]=62,Oe["_".charCodeAt(0)]=63;yw={read:function(t,e,r,i,n){var o,s,a=8*n-i-1,u=(1<<a)-1,c=u>>1,h=-7,d=r?n-1:0,g=r?-1:1,y=t[e+d];for(d+=g,o=y&(1<<-h)-1,y>>=-h,h+=a;h>0;o=256*o+t[e+d],d+=g,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=i;h>0;s=256*s+t[e+d],d+=g,h-=8);if(o===0)o=1-c;else {if(o===u)return s?NaN:1/0*(y?-1:1);s+=Math.pow(2,i),o-=c;}return (y?-1:1)*s*Math.pow(2,o-i)},write:function(t,e,r,i,n,o){var s,a,u,c=8*o-n-1,h=(1<<c)-1,d=h>>1,g=n===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=i?0:o-1,w=i?1:-1,E=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),(e+=s+d>=1?g/u:g*Math.pow(2,1-d))*u>=2&&(s++,u/=2),s+d>=h?(a=0,s=h):s+d>=1?(a=(e*u-1)*Math.pow(2,n),s+=d):(a=e*Math.pow(2,d-1)*Math.pow(2,n),s=0));n>=8;t[r+y]=255&a,y+=w,a/=256,n-=8);for(s=s<<n|a,c+=n;c>0;t[r+y]=255&s,y+=w,s/=256,c-=8);t[r+y-w]|=128*E;}},At={},Hs=Rc,Nr=yw,_c=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;At.Buffer=O,At.SlowBuffer=function(t){return +t!=t&&(t=0),O.alloc(+t)},At.INSPECT_MAX_BYTES=50;At.kMaxLength=2147483647,O.TYPED_ARRAY_SUPPORT=function(){try{var t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),t.foo()===42}catch{return !1}}(),O.TYPED_ARRAY_SUPPORT||typeof console>"u"||typeof console.error!="function"||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(O.prototype,"parent",{enumerable:!0,get:function(){if(O.isBuffer(this))return this.buffer}}),Object.defineProperty(O.prototype,"offset",{enumerable:!0,get:function(){if(O.isBuffer(this))return this.byteOffset}}),O.poolSize=8192,O.from=function(t,e,r){return Cc(t,e,r)},Object.setPrototypeOf(O.prototype,Uint8Array.prototype),Object.setPrototypeOf(O,Uint8Array),O.alloc=function(t,e,r){return function(i,n,o){return Bc(i),i<=0?Et(i):n!==void 0?typeof o=="string"?Et(i).fill(n,o):Et(i).fill(n):Et(i)}(t,e,r)},O.allocUnsafe=function(t){return Vs(t)},O.allocUnsafeSlow=function(t){return Vs(t)},O.isBuffer=function(t){return t!=null&&t._isBuffer===!0&&t!==O.prototype},O.compare=function(t,e){if(St(t,Uint8Array)&&(t=O.from(t,t.offset,t.byteLength)),St(e,Uint8Array)&&(e=O.from(e,e.offset,e.byteLength)),!O.isBuffer(t)||!O.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;for(var r=t.length,i=e.length,n=0,o=Math.min(r,i);n<o;++n)if(t[n]!==e[n]){r=t[n],i=e[n];break}return r<i?-1:i<r?1:0},O.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},O.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(t.length===0)return O.alloc(0);var r;if(e===void 0)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=O.allocUnsafe(e),n=0;for(r=0;r<t.length;++r){var o=t[r];if(St(o,Uint8Array)&&(o=O.from(o)),!O.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(i,n),n+=o.length;}return i},O.byteLength=Pc,O.prototype._isBuffer=!0,O.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)sr(this,e,e+1);return this},O.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)sr(this,e,e+3),sr(this,e+1,e+2);return this},O.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)sr(this,e,e+7),sr(this,e+1,e+6),sr(this,e+2,e+5),sr(this,e+3,e+4);return this},O.prototype.toString=function(){var t=this.length;return t===0?"":arguments.length===0?Oc(this,0,t):bw.apply(this,arguments)},O.prototype.toLocaleString=O.prototype.toString,O.prototype.equals=function(t){if(!O.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||O.compare(this,t)===0},O.prototype.inspect=function(){var t="",e=At.INSPECT_MAX_BYTES;return t=this.toString("hex",0,e).replace(/(.{2})/g,"$1 ").trim(),this.length>e&&(t+=" ... "),"<Buffer "+t+">"},_c&&(O.prototype[_c]=O.prototype.inspect),O.prototype.compare=function(t,e,r,i,n){if(St(t,Uint8Array)&&(t=O.from(t,t.offset,t.byteLength)),!O.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(e===void 0&&(e=0),r===void 0&&(r=t?t.length:0),i===void 0&&(i=0),n===void 0&&(n=this.length),e<0||r>t.length||i<0||n>this.length)throw new RangeError("out of range index");if(i>=n&&e>=r)return 0;if(i>=n)return -1;if(e>=r)return 1;if(this===t)return 0;for(var o=(n>>>=0)-(i>>>=0),s=(r>>>=0)-(e>>>=0),a=Math.min(o,s),u=this.slice(i,n),c=t.slice(e,r),h=0;h<a;++h)if(u[h]!==c[h]){o=u[h],s=c[h];break}return o<s?-1:s<o?1:0},O.prototype.includes=function(t,e,r){return this.indexOf(t,e,r)!==-1},O.prototype.indexOf=function(t,e,r){return vc(this,t,e,r,!0)},O.prototype.lastIndexOf=function(t,e,r){return vc(this,t,e,r,!1)},O.prototype.write=function(t,e,r,i){if(e===void 0)i="utf8",r=this.length,e=0;else if(r===void 0&&typeof e=="string")i=e,r=this.length,e=0;else {if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e>>>=0,isFinite(r)?(r>>>=0,i===void 0&&(i="utf8")):(i=r,r=void 0);}var n=this.length-e;if((r===void 0||r>n)&&(r=n),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var o=!1;;)switch(i){case"hex":return ww(this,t,e,r);case"utf8":case"utf-8":return _w(this,t,e,r);case"ascii":return kc(this,t,e,r);case"latin1":case"binary":return mw(this,t,e,r);case"base64":return vw(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ew(this,t,e,r);default:if(o)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),o=!0;}},O.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};O.prototype.slice=function(t,e){var r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=e===void 0?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);var i=this.subarray(t,e);return Object.setPrototypeOf(i,O.prototype),i},O.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||be(t,e,this.length);for(var i=this[t],n=1,o=0;++o<e&&(n*=256);)i+=this[t+o]*n;return i},O.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||be(t,e,this.length);for(var i=this[t+--e],n=1;e>0&&(n*=256);)i+=this[t+--e]*n;return i},O.prototype.readUInt8=function(t,e){return t>>>=0,e||be(t,1,this.length),this[t]},O.prototype.readUInt16LE=function(t,e){return t>>>=0,e||be(t,2,this.length),this[t]|this[t+1]<<8},O.prototype.readUInt16BE=function(t,e){return t>>>=0,e||be(t,2,this.length),this[t]<<8|this[t+1]},O.prototype.readUInt32LE=function(t,e){return t>>>=0,e||be(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},O.prototype.readUInt32BE=function(t,e){return t>>>=0,e||be(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},O.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||be(t,e,this.length);for(var i=this[t],n=1,o=0;++o<e&&(n*=256);)i+=this[t+o]*n;return i>=(n*=128)&&(i-=Math.pow(2,8*e)),i},O.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||be(t,e,this.length);for(var i=e,n=1,o=this[t+--i];i>0&&(n*=256);)o+=this[t+--i]*n;return o>=(n*=128)&&(o-=Math.pow(2,8*e)),o},O.prototype.readInt8=function(t,e){return t>>>=0,e||be(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},O.prototype.readInt16LE=function(t,e){t>>>=0,e||be(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},O.prototype.readInt16BE=function(t,e){t>>>=0,e||be(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},O.prototype.readInt32LE=function(t,e){return t>>>=0,e||be(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},O.prototype.readInt32BE=function(t,e){return t>>>=0,e||be(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},O.prototype.readFloatLE=function(t,e){return t>>>=0,e||be(t,4,this.length),Nr.read(this,t,!0,23,4)},O.prototype.readFloatBE=function(t,e){return t>>>=0,e||be(t,4,this.length),Nr.read(this,t,!1,23,4)},O.prototype.readDoubleLE=function(t,e){return t>>>=0,e||be(t,8,this.length),Nr.read(this,t,!0,52,8)},O.prototype.readDoubleBE=function(t,e){return t>>>=0,e||be(t,8,this.length),Nr.read(this,t,!1,52,8)},O.prototype.writeUIntLE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||Pe(this,t,e,r,Math.pow(2,8*r)-1,0);var n=1,o=0;for(this[e]=255&t;++o<r&&(n*=256);)this[e+o]=t/n&255;return e+r},O.prototype.writeUIntBE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||Pe(this,t,e,r,Math.pow(2,8*r)-1,0);var n=r-1,o=1;for(this[e+n]=255&t;--n>=0&&(o*=256);)this[e+n]=t/o&255;return e+r},O.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,1,255,0),this[e]=255&t,e+1},O.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},O.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},O.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},O.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},O.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);Pe(this,t,e,r,n-1,-n);}var o=0,s=1,a=0;for(this[e]=255&t;++o<r&&(s*=256);)t<0&&a===0&&this[e+o-1]!==0&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},O.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);Pe(this,t,e,r,n-1,-n);}var o=r-1,s=1,a=0;for(this[e+o]=255&t;--o>=0&&(s*=256);)t<0&&a===0&&this[e+o+1]!==0&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},O.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},O.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},O.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},O.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},O.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},O.prototype.writeFloatLE=function(t,e,r){return Sc(this,t,e,!0,r)},O.prototype.writeFloatBE=function(t,e,r){return Sc(this,t,e,!1,r)},O.prototype.writeDoubleLE=function(t,e,r){return Ac(this,t,e,!0,r)},O.prototype.writeDoubleBE=function(t,e,r){return Ac(this,t,e,!1,r)},O.prototype.copy=function(t,e,r,i){if(!O.isBuffer(t))throw new TypeError("argument should be a Buffer");if(r||(r=0),i||i===0||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r||t.length===0||this.length===0)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var n=i-r;if(this===t&&typeof Uint8Array.prototype.copyWithin=="function")this.copyWithin(e,r,i);else if(this===t&&r<e&&e<i)for(var o=n-1;o>=0;--o)t[o+e]=this[o+r];else Uint8Array.prototype.set.call(t,this.subarray(r,i),e);return n},O.prototype.fill=function(t,e,r,i){if(typeof t=="string"){if(typeof e=="string"?(i=e,e=0,r=this.length):typeof r=="string"&&(i=r,r=this.length),i!==void 0&&typeof i!="string")throw new TypeError("encoding must be a string");if(typeof i=="string"&&!O.isEncoding(i))throw new TypeError("Unknown encoding: "+i);if(t.length===1){var n=t.charCodeAt(0);(i==="utf8"&&n<128||i==="latin1")&&(t=n);}}else typeof t=="number"?t&=255:typeof t=="boolean"&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;var o;if(e>>>=0,r=r===void 0?this.length:r>>>0,t||(t=0),typeof t=="number")for(o=e;o<r;++o)this[o]=t;else {var s=O.isBuffer(t)?t:O.from(t,i),a=s.length;if(a===0)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(o=0;o<r-e;++o)this[o+e]=s[o%a];}return this};Cw=/[^+/0-9A-Za-z-_]/g;Bw=function(){for(var t=new Array(256),e=0;e<16;++e)for(var r=16*e,i=0;i<16;++i)t[r+i]="0123456789abcdef"[e]+"0123456789abcdef"[i];return t}();At.Buffer;At.INSPECT_MAX_BYTES;At.kMaxLength;an={},ln=At,it=ln.Buffer;it.from&&it.alloc&&it.allocUnsafe&&it.allocUnsafeSlow?an=ln:(Ic(ln,an),an.Buffer=or),or.prototype=Object.create(it.prototype),Ic(it,or),or.from=function(t,e,r){if(typeof t=="number")throw new TypeError("Argument must not be a number");return it(t,e,r)},or.alloc=function(t,e,r){if(typeof t!="number")throw new TypeError("Argument must be a number");var i=it(t);return e!==void 0?typeof r=="string"?i.fill(e,r):i.fill(e):i.fill(0),i},or.allocUnsafe=function(t){if(typeof t!="number")throw new TypeError("Argument must be a number");return it(t)},or.allocUnsafeSlow=function(t){if(typeof t!="number")throw new TypeError("Argument must be a number");return ln.SlowBuffer(t)};Pw=an,ar={},Ks=Pw.Buffer,Tc=Ks.isEncoding||function(t){switch((t=""+t)&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return !0;default:return !1}};ar.StringDecoder=hi,hi.prototype.write=function(t){if(t.length===0)return "";var e,r;if(this.lastNeed){if((e=this.fillLast(t))===void 0)return "";r=this.lastNeed,this.lastNeed=0;}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||""},hi.prototype.end=function(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+"\uFFFD":e},hi.prototype.text=function(t,e){var r=function(n,o,s){var a=o.length-1;if(a<s)return 0;var u=$s(o[a]);return u>=0?(u>0&&(n.lastNeed=u-1),u):--a<s||u===-2?0:(u=$s(o[a]))>=0?(u>0&&(n.lastNeed=u-2),u):--a<s||u===-2?0:(u=$s(o[a]))>=0?(u>0&&(u===2?u=0:n.lastNeed=u-3),u):0}(this,t,e);if(!this.lastNeed)return t.toString("utf8",e);this.lastTotal=r;var i=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,i),t.toString("utf8",e,i)},hi.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length;};ar.StringDecoder;ar.StringDecoder;});var Lc={};Qt(Lc,{StringDecoder:()=>qw,default:()=>ar});var qw,Uc=we(()=>{v();m();_();Ys();Ys();qw=ar.StringDecoder;});var Js=M(($2,jc)=>{v();m();_();var Nc=Nt(),{PromisePrototypeThen:Dw,SymbolAsyncIterator:qc,SymbolIterator:Dc}=ce(),{Buffer:jw}=(ye(),X(_e)),{ERR_INVALID_ARG_TYPE:Fw,ERR_STREAM_NULL_VALUES:Ww}=Se().codes;function $w(t,e,r){let i;if(typeof e=="string"||e instanceof jw)return new t({objectMode:!0,...r,read(){this.push(e),this.push(null);}});let n;if(e&&e[qc])n=!0,i=e[qc]();else if(e&&e[Dc])n=!1,i=e[Dc]();else throw new Fw("iterable",["Iterable"],e);let o=new t({objectMode:!0,highWaterMark:1,...r}),s=!1;o._read=function(){s||(s=!0,u());},o._destroy=function(c,h){Dw(a(c),()=>Nc.nextTick(h,c),d=>Nc.nextTick(h,d||c));};async function a(c){let h=c!=null,d=typeof i.throw=="function";if(h&&d){let{value:g,done:y}=await i.throw(c);if(await g,y)return}if(typeof i.return=="function"){let{value:g}=await i.return();await g;}}async function u(){for(;;){try{let{value:c,done:h}=n?await i.next():i.next();if(h)o.push(null);else {let d=c&&typeof c.then=="function"?await c:c;if(d===null)throw s=!1,new Ww;if(o.push(d))continue;s=!1;}}catch(c){o.destroy(c);}break}}return o}jc.exports=$w;});var di=M((Z2,Zc)=>{v();m();_();var He=Nt(),{ArrayPrototypeIndexOf:Hw,NumberIsInteger:Vw,NumberIsNaN:zw,NumberParseInt:Kw,ObjectDefineProperties:$c,ObjectKeys:Gw,ObjectSetPrototypeOf:Hc,Promise:Qw,SafeSet:Yw,SymbolAsyncIterator:Jw,Symbol:Xw}=ce();Zc.exports=F;F.ReadableState=io;var{EventEmitter:Zw}=(ir(),X(rr)),{Stream:Dt,prependListener:e_}=tn(),{Buffer:Xs}=(ye(),X(_e)),{addAbortSignal:t_}=ci(),r_=vt(),H=Je().debuglog("stream",t=>{H=t;}),i_=dc(),Dr=tr(),{getHighWaterMark:n_,getDefaultHighWaterMark:s_}=sn(),{aggregateTwoErrors:Fc,codes:{ERR_INVALID_ARG_TYPE:o_,ERR_METHOD_NOT_IMPLEMENTED:a_,ERR_OUT_OF_RANGE:l_,ERR_STREAM_PUSH_AFTER_EOF:u_,ERR_STREAM_UNSHIFT_AFTER_END_EVENT:f_}}=Se(),{validateObject:c_}=fi(),lr=Xw("kPaused"),{StringDecoder:Vc}=(Uc(),X(Lc)),h_=Js();Hc(F.prototype,Dt.prototype);Hc(F,Dt);var Zs=()=>{},{errorOrDestroy:qr}=Dr;function io(t,e,r){typeof r!="boolean"&&(r=e instanceof nt()),this.objectMode=!!(t&&t.objectMode),r&&(this.objectMode=this.objectMode||!!(t&&t.readableObjectMode)),this.highWaterMark=t?n_(this,t,"readableHighWaterMark",r):s_(!1),this.buffer=new i_,this.length=0,this.pipes=[],this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.constructed=!0,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this[lr]=null,this.errorEmitted=!1,this.emitClose=!t||t.emitClose!==!1,this.autoDestroy=!t||t.autoDestroy!==!1,this.destroyed=!1,this.errored=null,this.closed=!1,this.closeEmitted=!1,this.defaultEncoding=t&&t.defaultEncoding||"utf8",this.awaitDrainWriters=null,this.multiAwaitDrain=!1,this.readingMore=!1,this.dataEmitted=!1,this.decoder=null,this.encoding=null,t&&t.encoding&&(this.decoder=new Vc(t.encoding),this.encoding=t.encoding);}function F(t){if(!(this instanceof F))return new F(t);let e=this instanceof nt();this._readableState=new io(t,this,e),t&&(typeof t.read=="function"&&(this._read=t.read),typeof t.destroy=="function"&&(this._destroy=t.destroy),typeof t.construct=="function"&&(this._construct=t.construct),t.signal&&!e&&t_(t.signal,this)),Dt.call(this,t),Dr.construct(this,()=>{this._readableState.needReadable&&fn(this,this._readableState);});}F.prototype.destroy=Dr.destroy;F.prototype._undestroy=Dr.undestroy;F.prototype._destroy=function(t,e){e(t);};F.prototype[Zw.captureRejectionSymbol]=function(t){this.destroy(t);};F.prototype.push=function(t,e){return zc(this,t,e,!1)};F.prototype.unshift=function(t,e){return zc(this,t,e,!0)};function zc(t,e,r,i){H("readableAddChunk",e);let n=t._readableState,o;if(n.objectMode||(typeof e=="string"?(r=r||n.defaultEncoding,n.encoding!==r&&(i&&n.encoding?e=Xs.from(e,r).toString(n.encoding):(e=Xs.from(e,r),r=""))):e instanceof Xs?r="":Dt._isUint8Array(e)?(e=Dt._uint8ArrayToBuffer(e),r=""):e!=null&&(o=new o_("chunk",["string","Buffer","Uint8Array"],e))),o)qr(t,o);else if(e===null)n.reading=!1,g_(t,n);else if(n.objectMode||e&&e.length>0)if(i)if(n.endEmitted)qr(t,new f_);else {if(n.destroyed||n.errored)return !1;eo(t,n,e,!0);}else if(n.ended)qr(t,new u_);else {if(n.destroyed||n.errored)return !1;n.reading=!1,n.decoder&&!r?(e=n.decoder.write(e),n.objectMode||e.length!==0?eo(t,n,e,!1):fn(t,n)):eo(t,n,e,!1);}else i||(n.reading=!1,fn(t,n));return !n.ended&&(n.length<n.highWaterMark||n.length===0)}function eo(t,e,r,i){e.flowing&&e.length===0&&!e.sync&&t.listenerCount("data")>0?(e.multiAwaitDrain?e.awaitDrainWriters.clear():e.awaitDrainWriters=null,e.dataEmitted=!0,t.emit("data",r)):(e.length+=e.objectMode?1:r.length,i?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&cn(t)),fn(t,e);}F.prototype.isPaused=function(){let t=this._readableState;return t[lr]===!0||t.flowing===!1};F.prototype.setEncoding=function(t){let e=new Vc(t);this._readableState.decoder=e,this._readableState.encoding=this._readableState.decoder.encoding;let r=this._readableState.buffer,i="";for(let n of r)i+=e.write(n);return r.clear(),i!==""&&r.push(i),this._readableState.length=i.length,this};var d_=1073741824;function p_(t){if(t>d_)throw new l_("size","<= 1GiB",t);return t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++,t}function Wc(t,e){return t<=0||e.length===0&&e.ended?0:e.objectMode?1:zw(t)?e.flowing&&e.length?e.buffer.first().length:e.length:t<=e.length?t:e.ended?e.length:0}F.prototype.read=function(t){H("read",t),t===void 0?t=NaN:Vw(t)||(t=Kw(t,10));let e=this._readableState,r=t;if(t>e.highWaterMark&&(e.highWaterMark=p_(t)),t!==0&&(e.emittedReadable=!1),t===0&&e.needReadable&&((e.highWaterMark!==0?e.length>=e.highWaterMark:e.length>0)||e.ended))return H("read: emitReadable",e.length,e.ended),e.length===0&&e.ended?to(this):cn(this),null;if(t=Wc(t,e),t===0&&e.ended)return e.length===0&&to(this),null;let i=e.needReadable;if(H("need readable",i),(e.length===0||e.length-t<e.highWaterMark)&&(i=!0,H("length less than watermark",i)),e.ended||e.reading||e.destroyed||e.errored||!e.constructed)i=!1,H("reading, ended or constructing",i);else if(i){H("do read"),e.reading=!0,e.sync=!0,e.length===0&&(e.needReadable=!0);try{this._read(e.highWaterMark);}catch(o){qr(this,o);}e.sync=!1,e.reading||(t=Wc(r,e));}let n;return t>0?n=Jc(t,e):n=null,n===null?(e.needReadable=e.length<=e.highWaterMark,t=0):(e.length-=t,e.multiAwaitDrain?e.awaitDrainWriters.clear():e.awaitDrainWriters=null),e.length===0&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&to(this)),n!==null&&!e.errorEmitted&&!e.closeEmitted&&(e.dataEmitted=!0,this.emit("data",n)),n};function g_(t,e){if(H("onEofChunk"),!e.ended){if(e.decoder){let r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length);}e.ended=!0,e.sync?cn(t):(e.needReadable=!1,e.emittedReadable=!0,Kc(t));}}function cn(t){let e=t._readableState;H("emitReadable",e.needReadable,e.emittedReadable),e.needReadable=!1,e.emittedReadable||(H("emitReadable",e.flowing),e.emittedReadable=!0,He.nextTick(Kc,t));}function Kc(t){let e=t._readableState;H("emitReadable_",e.destroyed,e.length,e.ended),!e.destroyed&&!e.errored&&(e.length||e.ended)&&(t.emit("readable"),e.emittedReadable=!1),e.needReadable=!e.flowing&&!e.ended&&e.length<=e.highWaterMark,Qc(t);}function fn(t,e){!e.readingMore&&e.constructed&&(e.readingMore=!0,He.nextTick(y_,t,e));}function y_(t,e){for(;!e.reading&&!e.ended&&(e.length<e.highWaterMark||e.flowing&&e.length===0);){let r=e.length;if(H("maybeReadMore read 0"),t.read(0),r===e.length)break}e.readingMore=!1;}F.prototype._read=function(t){throw new a_("_read()")};F.prototype.pipe=function(t,e){let r=this,i=this._readableState;i.pipes.length===1&&(i.multiAwaitDrain||(i.multiAwaitDrain=!0,i.awaitDrainWriters=new Yw(i.awaitDrainWriters?[i.awaitDrainWriters]:[]))),i.pipes.push(t),H("pipe count=%d opts=%j",i.pipes.length,e);let o=(!e||e.end!==!1)&&t!==He.stdout&&t!==He.stderr?a:S;i.endEmitted?He.nextTick(o):r.once("end",o),t.on("unpipe",s);function s(I,B){H("onunpipe"),I===r&&B&&B.hasUnpiped===!1&&(B.hasUnpiped=!0,h());}function a(){H("onend"),t.end();}let u,c=!1;function h(){H("cleanup"),t.removeListener("close",w),t.removeListener("finish",E),u&&t.removeListener("drain",u),t.removeListener("error",y),t.removeListener("unpipe",s),r.removeListener("end",a),r.removeListener("end",S),r.removeListener("data",g),c=!0,u&&i.awaitDrainWriters&&(!t._writableState||t._writableState.needDrain)&&u();}function d(){c||(i.pipes.length===1&&i.pipes[0]===t?(H("false write response, pause",0),i.awaitDrainWriters=t,i.multiAwaitDrain=!1):i.pipes.length>1&&i.pipes.includes(t)&&(H("false write response, pause",i.awaitDrainWriters.size),i.awaitDrainWriters.add(t)),r.pause()),u||(u=b_(r,t),t.on("drain",u));}r.on("data",g);function g(I){H("ondata");let B=t.write(I);H("dest.write",B),B===!1&&d();}function y(I){if(H("onerror",I),S(),t.removeListener("error",y),t.listenerCount("error")===0){let B=t._writableState||t._readableState;B&&!B.errorEmitted?qr(t,I):t.emit("error",I);}}e_(t,"error",y);function w(){t.removeListener("finish",E),S();}t.once("close",w);function E(){H("onfinish"),t.removeListener("close",w),S();}t.once("finish",E);function S(){H("unpipe"),r.unpipe(t);}return t.emit("pipe",r),t.writableNeedDrain===!0?i.flowing&&d():i.flowing||(H("pipe resume"),r.resume()),t};function b_(t,e){return function(){let i=t._readableState;i.awaitDrainWriters===e?(H("pipeOnDrain",1),i.awaitDrainWriters=null):i.multiAwaitDrain&&(H("pipeOnDrain",i.awaitDrainWriters.size),i.awaitDrainWriters.delete(e)),(!i.awaitDrainWriters||i.awaitDrainWriters.size===0)&&t.listenerCount("data")&&t.resume();}}F.prototype.unpipe=function(t){let e=this._readableState,r={hasUnpiped:!1};if(e.pipes.length===0)return this;if(!t){let n=e.pipes;e.pipes=[],this.pause();for(let o=0;o<n.length;o++)n[o].emit("unpipe",this,{hasUnpiped:!1});return this}let i=Hw(e.pipes,t);return i===-1?this:(e.pipes.splice(i,1),e.pipes.length===0&&this.pause(),t.emit("unpipe",this,r),this)};F.prototype.on=function(t,e){let r=Dt.prototype.on.call(this,t,e),i=this._readableState;return t==="data"?(i.readableListening=this.listenerCount("readable")>0,i.flowing!==!1&&this.resume()):t==="readable"&&!i.endEmitted&&!i.readableListening&&(i.readableListening=i.needReadable=!0,i.flowing=!1,i.emittedReadable=!1,H("on readable",i.length,i.reading),i.length?cn(this):i.reading||He.nextTick(w_,this)),r};F.prototype.addListener=F.prototype.on;F.prototype.removeListener=function(t,e){let r=Dt.prototype.removeListener.call(this,t,e);return t==="readable"&&He.nextTick(Gc,this),r};F.prototype.off=F.prototype.removeListener;F.prototype.removeAllListeners=function(t){let e=Dt.prototype.removeAllListeners.apply(this,arguments);return (t==="readable"||t===void 0)&&He.nextTick(Gc,this),e};function Gc(t){let e=t._readableState;e.readableListening=t.listenerCount("readable")>0,e.resumeScheduled&&e[lr]===!1?e.flowing=!0:t.listenerCount("data")>0?t.resume():e.readableListening||(e.flowing=null);}function w_(t){H("readable nexttick read 0"),t.read(0);}F.prototype.resume=function(){let t=this._readableState;return t.flowing||(H("resume"),t.flowing=!t.readableListening,__(this,t)),t[lr]=!1,this};function __(t,e){e.resumeScheduled||(e.resumeScheduled=!0,He.nextTick(m_,t,e));}function m_(t,e){H("resume",e.reading),e.reading||t.read(0),e.resumeScheduled=!1,t.emit("resume"),Qc(t),e.flowing&&!e.reading&&t.read(0);}F.prototype.pause=function(){return H("call pause flowing=%j",this._readableState.flowing),this._readableState.flowing!==!1&&(H("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState[lr]=!0,this};function Qc(t){let e=t._readableState;for(H("flow",e.flowing);e.flowing&&t.read()!==null;);}F.prototype.wrap=function(t){let e=!1;t.on("data",i=>{!this.push(i)&&t.pause&&(e=!0,t.pause());}),t.on("end",()=>{this.push(null);}),t.on("error",i=>{qr(this,i);}),t.on("close",()=>{this.destroy();}),t.on("destroy",()=>{this.destroy();}),this._read=()=>{e&&t.resume&&(e=!1,t.resume());};let r=Gw(t);for(let i=1;i<r.length;i++){let n=r[i];this[n]===void 0&&typeof t[n]=="function"&&(this[n]=t[n].bind(t));}return this};F.prototype[Jw]=function(){return Yc(this)};F.prototype.iterator=function(t){return t!==void 0&&c_(t,"options"),Yc(this,t)};function Yc(t,e){typeof t.read!="function"&&(t=F.wrap(t,{objectMode:!0}));let r=v_(t,e);return r.stream=t,r}async function*v_(t,e){let r=Zs;function i(s){this===t?(r(),r=Zs):r=s;}t.on("readable",i);let n,o=r_(t,{writable:!1},s=>{n=s?Fc(n,s):null,r(),r=Zs;});try{for(;;){let s=t.destroyed?null:t.read();if(s!==null)yield s;else {if(n)throw n;if(n===null)return;await new Qw(i);}}}catch(s){throw n=Fc(n,s),n}finally{(n||e?.destroyOnReturn!==!1)&&(n===void 0||t._readableState.autoDestroy)?Dr.destroyer(t,null):(t.off("readable",i),o());}}$c(F.prototype,{readable:{__proto__:null,get(){let t=this._readableState;return !!t&&t.readable!==!1&&!t.destroyed&&!t.errorEmitted&&!t.endEmitted},set(t){this._readableState&&(this._readableState.readable=!!t);}},readableDidRead:{__proto__:null,enumerable:!1,get:function(){return this._readableState.dataEmitted}},readableAborted:{__proto__:null,enumerable:!1,get:function(){return !!(this._readableState.readable!==!1&&(this._readableState.destroyed||this._readableState.errored)&&!this._readableState.endEmitted)}},readableHighWaterMark:{__proto__:null,enumerable:!1,get:function(){return this._readableState.highWaterMark}},readableBuffer:{__proto__:null,enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}},readableFlowing:{__proto__:null,enumerable:!1,get:function(){return this._readableState.flowing},set:function(t){this._readableState&&(this._readableState.flowing=t);}},readableLength:{__proto__:null,enumerable:!1,get(){return this._readableState.length}},readableObjectMode:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.objectMode:!1}},readableEncoding:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.encoding:null}},errored:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.errored:null}},closed:{__proto__:null,get(){return this._readableState?this._readableState.closed:!1}},destroyed:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.destroyed:!1},set(t){this._readableState&&(this._readableState.destroyed=t);}},readableEnded:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.endEmitted:!1}}});$c(io.prototype,{pipesCount:{__proto__:null,get(){return this.pipes.length}},paused:{__proto__:null,get(){return this[lr]!==!1},set(t){this[lr]=!!t;}}});F._fromList=Jc;function Jc(t,e){if(e.length===0)return null;let r;return e.objectMode?r=e.buffer.shift():!t||t>=e.length?(e.decoder?r=e.buffer.join(""):e.buffer.length===1?r=e.buffer.first():r=e.buffer.concat(e.length),e.buffer.clear()):r=e.buffer.consume(t,e.decoder),r}function to(t){let e=t._readableState;H("endReadable",e.endEmitted),e.endEmitted||(e.ended=!0,He.nextTick(E_,e,t));}function E_(t,e){if(H("endReadableNT",t.endEmitted,t.length),!t.errored&&!t.closeEmitted&&!t.endEmitted&&t.length===0){if(t.endEmitted=!0,e.emit("end"),e.writable&&e.allowHalfOpen===!1)He.nextTick(S_,e);else if(t.autoDestroy){let r=e._writableState;(!r||r.autoDestroy&&(r.finished||r.writable===!1))&&e.destroy();}}}function S_(t){t.writable&&!t.writableEnded&&!t.destroyed&&t.end();}F.from=function(t,e){return h_(F,t,e)};var ro;function Xc(){return ro===void 0&&(ro={}),ro}F.fromWeb=function(t,e){return Xc().newStreamReadableFromReadableStream(t,e)};F.toWeb=function(t,e){return Xc().newReadableStreamFromStreamReadable(t,e)};F.wrap=function(t,e){var r,i;return new F({objectMode:(r=(i=t.readableObjectMode)!==null&&i!==void 0?i:t.objectMode)!==null&&r!==void 0?r:!0,...e,destroy(n,o){Dr.destroyer(t,n),o(n);}}).wrap(t)};});var fo=M((uR,ch)=>{v();m();_();var ur=Nt(),{ArrayPrototypeSlice:rh,Error:A_,FunctionPrototypeSymbolHasInstance:ih,ObjectDefineProperty:nh,ObjectDefineProperties:I_,ObjectSetPrototypeOf:sh,StringPrototypeToLowerCase:T_,Symbol:R_,SymbolHasInstance:C_}=ce();ch.exports=ie;ie.WritableState=yi;var{EventEmitter:B_}=(ir(),X(rr)),pi=tn().Stream,{Buffer:hn}=(ye(),X(_e)),gn=tr(),{addAbortSignal:P_}=ci(),{getHighWaterMark:k_,getDefaultHighWaterMark:O_}=sn(),{ERR_INVALID_ARG_TYPE:x_,ERR_METHOD_NOT_IMPLEMENTED:M_,ERR_MULTIPLE_CALLBACK:oh,ERR_STREAM_CANNOT_PIPE:L_,ERR_STREAM_DESTROYED:gi,ERR_STREAM_ALREADY_FINISHED:U_,ERR_STREAM_NULL_VALUES:N_,ERR_STREAM_WRITE_AFTER_END:q_,ERR_UNKNOWN_ENCODING:ah}=Se().codes,{errorOrDestroy:jr}=gn;sh(ie.prototype,pi.prototype);sh(ie,pi);function oo(){}var Fr=R_("kOnFinished");function yi(t,e,r){typeof r!="boolean"&&(r=e instanceof nt()),this.objectMode=!!(t&&t.objectMode),r&&(this.objectMode=this.objectMode||!!(t&&t.writableObjectMode)),this.highWaterMark=t?k_(this,t,"writableHighWaterMark",r):O_(!1),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;let i=!!(t&&t.decodeStrings===!1);this.decodeStrings=!i,this.defaultEncoding=t&&t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=j_.bind(void 0,e),this.writecb=null,this.writelen=0,this.afterWriteTickInfo=null,pn(this),this.pendingcb=0,this.constructed=!0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!t||t.emitClose!==!1,this.autoDestroy=!t||t.autoDestroy!==!1,this.errored=null,this.closed=!1,this.closeEmitted=!1,this[Fr]=[];}function pn(t){t.buffered=[],t.bufferedIndex=0,t.allBuffers=!0,t.allNoop=!0;}yi.prototype.getBuffer=function(){return rh(this.buffered,this.bufferedIndex)};nh(yi.prototype,"bufferedRequestCount",{__proto__:null,get(){return this.buffered.length-this.bufferedIndex}});function ie(t){let e=this instanceof nt();if(!e&&!ih(ie,this))return new ie(t);this._writableState=new yi(t,this,e),t&&(typeof t.write=="function"&&(this._write=t.write),typeof t.writev=="function"&&(this._writev=t.writev),typeof t.destroy=="function"&&(this._destroy=t.destroy),typeof t.final=="function"&&(this._final=t.final),typeof t.construct=="function"&&(this._construct=t.construct),t.signal&&P_(t.signal,this)),pi.call(this,t),gn.construct(this,()=>{let r=this._writableState;r.writing||lo(this,r),uo(this,r);});}nh(ie,C_,{__proto__:null,value:function(t){return ih(this,t)?!0:this!==ie?!1:t&&t._writableState instanceof yi}});ie.prototype.pipe=function(){jr(this,new L_);};function lh(t,e,r,i){let n=t._writableState;if(typeof r=="function")i=r,r=n.defaultEncoding;else {if(!r)r=n.defaultEncoding;else if(r!=="buffer"&&!hn.isEncoding(r))throw new ah(r);typeof i!="function"&&(i=oo);}if(e===null)throw new N_;if(!n.objectMode)if(typeof e=="string")n.decodeStrings!==!1&&(e=hn.from(e,r),r="buffer");else if(e instanceof hn)r="buffer";else if(pi._isUint8Array(e))e=pi._uint8ArrayToBuffer(e),r="buffer";else throw new x_("chunk",["string","Buffer","Uint8Array"],e);let o;return n.ending?o=new q_:n.destroyed&&(o=new gi("write")),o?(ur.nextTick(i,o),jr(t,o,!0),o):(n.pendingcb++,D_(t,n,e,r,i))}ie.prototype.write=function(t,e,r){return lh(this,t,e,r)===!0};ie.prototype.cork=function(){this._writableState.corked++;};ie.prototype.uncork=function(){let t=this._writableState;t.corked&&(t.corked--,t.writing||lo(this,t));};ie.prototype.setDefaultEncoding=function(e){if(typeof e=="string"&&(e=T_(e)),!hn.isEncoding(e))throw new ah(e);return this._writableState.defaultEncoding=e,this};function D_(t,e,r,i,n){let o=e.objectMode?1:r.length;e.length+=o;let s=e.length<e.highWaterMark;return s||(e.needDrain=!0),e.writing||e.corked||e.errored||!e.constructed?(e.buffered.push({chunk:r,encoding:i,callback:n}),e.allBuffers&&i!=="buffer"&&(e.allBuffers=!1),e.allNoop&&n!==oo&&(e.allNoop=!1)):(e.writelen=o,e.writecb=n,e.writing=!0,e.sync=!0,t._write(r,i,e.onwrite),e.sync=!1),s&&!e.errored&&!e.destroyed}function eh(t,e,r,i,n,o,s){e.writelen=i,e.writecb=s,e.writing=!0,e.sync=!0,e.destroyed?e.onwrite(new gi("write")):r?t._writev(n,e.onwrite):t._write(n,o,e.onwrite),e.sync=!1;}function th(t,e,r,i){--e.pendingcb,i(r),ao(e),jr(t,r);}function j_(t,e){let r=t._writableState,i=r.sync,n=r.writecb;if(typeof n!="function"){jr(t,new oh);return}r.writing=!1,r.writecb=null,r.length-=r.writelen,r.writelen=0,e?(e.stack,r.errored||(r.errored=e),t._readableState&&!t._readableState.errored&&(t._readableState.errored=e),i?ur.nextTick(th,t,r,e,n):th(t,r,e,n)):(r.buffered.length>r.bufferedIndex&&lo(t,r),i?r.afterWriteTickInfo!==null&&r.afterWriteTickInfo.cb===n?r.afterWriteTickInfo.count++:(r.afterWriteTickInfo={count:1,cb:n,stream:t,state:r},ur.nextTick(F_,r.afterWriteTickInfo)):uh(t,r,1,n));}function F_({stream:t,state:e,count:r,cb:i}){return e.afterWriteTickInfo=null,uh(t,e,r,i)}function uh(t,e,r,i){for(!e.ending&&!t.destroyed&&e.length===0&&e.needDrain&&(e.needDrain=!1,t.emit("drain"));r-- >0;)e.pendingcb--,i();e.destroyed&&ao(e),uo(t,e);}function ao(t){if(t.writing)return;for(let n=t.bufferedIndex;n<t.buffered.length;++n){var e;let{chunk:o,callback:s}=t.buffered[n],a=t.objectMode?1:o.length;t.length-=a,s((e=t.errored)!==null&&e!==void 0?e:new gi("write"));}let r=t[Fr].splice(0);for(let n=0;n<r.length;n++){var i;r[n]((i=t.errored)!==null&&i!==void 0?i:new gi("end"));}pn(t);}function lo(t,e){if(e.corked||e.bufferProcessing||e.destroyed||!e.constructed)return;let{buffered:r,bufferedIndex:i,objectMode:n}=e,o=r.length-i;if(!o)return;let s=i;if(e.bufferProcessing=!0,o>1&&t._writev){e.pendingcb-=o-1;let a=e.allNoop?oo:c=>{for(let h=s;h<r.length;++h)r[h].callback(c);},u=e.allNoop&&s===0?r:rh(r,s);u.allBuffers=e.allBuffers,eh(t,e,!0,e.length,u,"",a),pn(e);}else {do{let{chunk:a,encoding:u,callback:c}=r[s];r[s++]=null;let h=n?1:a.length;eh(t,e,!1,h,a,u,c);}while(s<r.length&&!e.writing);s===r.length?pn(e):s>256?(r.splice(0,s),e.bufferedIndex=0):e.bufferedIndex=s;}e.bufferProcessing=!1;}ie.prototype._write=function(t,e,r){if(this._writev)this._writev([{chunk:t,encoding:e}],r);else throw new M_("_write()")};ie.prototype._writev=null;ie.prototype.end=function(t,e,r){let i=this._writableState;typeof t=="function"?(r=t,t=null,e=null):typeof e=="function"&&(r=e,e=null);let n;if(t!=null){let o=lh(this,t,e);o instanceof A_&&(n=o);}return i.corked&&(i.corked=1,this.uncork()),n||(!i.errored&&!i.ending?(i.ending=!0,uo(this,i,!0),i.ended=!0):i.finished?n=new U_("end"):i.destroyed&&(n=new gi("end"))),typeof r=="function"&&(n||i.finished?ur.nextTick(r,n):i[Fr].push(r)),this};function dn(t){return t.ending&&!t.destroyed&&t.constructed&&t.length===0&&!t.errored&&t.buffered.length===0&&!t.finished&&!t.writing&&!t.errorEmitted&&!t.closeEmitted}function W_(t,e){let r=!1;function i(n){if(r){jr(t,n??oh());return}if(r=!0,e.pendingcb--,n){let o=e[Fr].splice(0);for(let s=0;s<o.length;s++)o[s](n);jr(t,n,e.sync);}else dn(e)&&(e.prefinished=!0,t.emit("prefinish"),e.pendingcb++,ur.nextTick(so,t,e));}e.sync=!0,e.pendingcb++;try{t._final(i);}catch(n){i(n);}e.sync=!1;}function $_(t,e){!e.prefinished&&!e.finalCalled&&(typeof t._final=="function"&&!e.destroyed?(e.finalCalled=!0,W_(t,e)):(e.prefinished=!0,t.emit("prefinish")));}function uo(t,e,r){dn(e)&&($_(t,e),e.pendingcb===0&&(r?(e.pendingcb++,ur.nextTick((i,n)=>{dn(n)?so(i,n):n.pendingcb--;},t,e)):dn(e)&&(e.pendingcb++,so(t,e))));}function so(t,e){e.pendingcb--,e.finished=!0;let r=e[Fr].splice(0);for(let i=0;i<r.length;i++)r[i]();if(t.emit("finish"),e.autoDestroy){let i=t._readableState;(!i||i.autoDestroy&&(i.endEmitted||i.readable===!1))&&t.destroy();}}I_(ie.prototype,{closed:{__proto__:null,get(){return this._writableState?this._writableState.closed:!1}},destroyed:{__proto__:null,get(){return this._writableState?this._writableState.destroyed:!1},set(t){this._writableState&&(this._writableState.destroyed=t);}},writable:{__proto__:null,get(){let t=this._writableState;return !!t&&t.writable!==!1&&!t.destroyed&&!t.errored&&!t.ending&&!t.ended},set(t){this._writableState&&(this._writableState.writable=!!t);}},writableFinished:{__proto__:null,get(){return this._writableState?this._writableState.finished:!1}},writableObjectMode:{__proto__:null,get(){return this._writableState?this._writableState.objectMode:!1}},writableBuffer:{__proto__:null,get(){return this._writableState&&this._writableState.getBuffer()}},writableEnded:{__proto__:null,get(){return this._writableState?this._writableState.ending:!1}},writableNeedDrain:{__proto__:null,get(){let t=this._writableState;return t?!t.destroyed&&!t.ending&&t.needDrain:!1}},writableHighWaterMark:{__proto__:null,get(){return this._writableState&&this._writableState.highWaterMark}},writableCorked:{__proto__:null,get(){return this._writableState?this._writableState.corked:0}},writableLength:{__proto__:null,get(){return this._writableState&&this._writableState.length}},errored:{__proto__:null,enumerable:!1,get(){return this._writableState?this._writableState.errored:null}},writableAborted:{__proto__:null,enumerable:!1,get:function(){return !!(this._writableState.writable!==!1&&(this._writableState.destroyed||this._writableState.errored)&&!this._writableState.finished)}}});var H_=gn.destroy;ie.prototype.destroy=function(t,e){let r=this._writableState;return !r.destroyed&&(r.bufferedIndex<r.buffered.length||r[Fr].length)&&ur.nextTick(ao,r),H_.call(this,t,e),this};ie.prototype._undestroy=gn.undestroy;ie.prototype._destroy=function(t,e){e(t);};ie.prototype[B_.captureRejectionSymbol]=function(t){this.destroy(t);};var no;function fh(){return no===void 0&&(no={}),no}ie.fromWeb=function(t,e){return fh().newStreamWritableFromWritableStream(t,e)};ie.toWeb=function(t){return fh().newWritableStreamFromStreamWritable(t)};});var Sh=M((_R,Eh)=>{v();m();_();var co=Nt(),V_=(ye(),X(_e)),{isReadable:z_,isWritable:K_,isIterable:hh,isNodeStream:G_,isReadableNodeStream:dh,isWritableNodeStream:ph,isDuplexNodeStream:Q_}=tt(),gh=vt(),{AbortError:vh,codes:{ERR_INVALID_ARG_TYPE:Y_,ERR_INVALID_RETURN_VALUE:yh}}=Se(),{destroyer:Wr}=tr(),J_=nt(),X_=di(),{createDeferredPromise:bh}=Je(),wh=Js(),_h=globalThis.Blob||V_.Blob,Z_=typeof _h<"u"?function(e){return e instanceof _h}:function(e){return !1},e0=globalThis.AbortController||Hi().AbortController,{FunctionPrototypeCall:mh}=ce(),fr=class extends J_{constructor(e){super(e),e?.readable===!1&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),e?.writable===!1&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0);}};Eh.exports=function t(e,r){if(Q_(e))return e;if(dh(e))return yn({readable:e});if(ph(e))return yn({writable:e});if(G_(e))return yn({writable:!1,readable:!1});if(typeof e=="function"){let{value:n,write:o,final:s,destroy:a}=t0(e);if(hh(n))return wh(fr,n,{objectMode:!0,write:o,final:s,destroy:a});let u=n?.then;if(typeof u=="function"){let c,h=mh(u,n,d=>{if(d!=null)throw new yh("nully","body",d)},d=>{Wr(c,d);});return c=new fr({objectMode:!0,readable:!1,write:o,final(d){s(async()=>{try{await h,co.nextTick(d,null);}catch(g){co.nextTick(d,g);}});},destroy:a})}throw new yh("Iterable, AsyncIterable or AsyncFunction",r,n)}if(Z_(e))return t(e.arrayBuffer());if(hh(e))return wh(fr,e,{objectMode:!0,writable:!1});if(typeof e?.writable=="object"||typeof e?.readable=="object"){let n=e!=null&&e.readable?dh(e?.readable)?e?.readable:t(e.readable):void 0,o=e!=null&&e.writable?ph(e?.writable)?e?.writable:t(e.writable):void 0;return yn({readable:n,writable:o})}let i=e?.then;if(typeof i=="function"){let n;return mh(i,e,o=>{o!=null&&n.push(o),n.push(null);},o=>{Wr(n,o);}),n=new fr({objectMode:!0,writable:!1,read(){}})}throw new Y_(r,["Blob","ReadableStream","WritableStream","Stream","Iterable","AsyncIterable","Function","{ readable, writable } pair","Promise"],e)};function t0(t){let{promise:e,resolve:r}=bh(),i=new e0,n=i.signal;return {value:t(async function*(){for(;;){let s=e;e=null;let{chunk:a,done:u,cb:c}=await s;if(co.nextTick(c),u)return;if(n.aborted)throw new vh(void 0,{cause:n.reason});(({promise:e,resolve:r}=bh())),yield a;}}(),{signal:n}),write(s,a,u){let c=r;r=null,c({chunk:s,done:!1,cb:u});},final(s){let a=r;r=null,a({done:!0,cb:s});},destroy(s,a){i.abort(),a(s);}}}function yn(t){let e=t.readable&&typeof t.readable.read!="function"?X_.wrap(t.readable):t.readable,r=t.writable,i=!!z_(e),n=!!K_(r),o,s,a,u,c;function h(d){let g=u;u=null,g?g(d):d&&c.destroy(d);}return c=new fr({readableObjectMode:!!(e!=null&&e.readableObjectMode),writableObjectMode:!!(r!=null&&r.writableObjectMode),readable:i,writable:n}),n&&(gh(r,d=>{n=!1,d&&Wr(e,d),h(d);}),c._write=function(d,g,y){r.write(d,g)?y():o=y;},c._final=function(d){r.end(),s=d;},r.on("drain",function(){if(o){let d=o;o=null,d();}}),r.on("finish",function(){if(s){let d=s;s=null,d();}})),i&&(gh(e,d=>{i=!1,d&&Wr(e,d),h(d);}),e.on("readable",function(){if(a){let d=a;a=null,d();}}),e.on("end",function(){c.push(null);}),c._read=function(){for(;;){let d=e.read();if(d===null){a=c._read;return}if(!c.push(d))return}}),c._destroy=function(d,g){!d&&u!==null&&(d=new vh),a=null,o=null,s=null,u===null?g(d):(u=g,Wr(r,d),Wr(e,d));},c}});var nt=M((BR,Th)=>{v();m();_();var{ObjectDefineProperties:r0,ObjectGetOwnPropertyDescriptor:It,ObjectKeys:i0,ObjectSetPrototypeOf:Ah}=ce();Th.exports=Ve;var go=di(),Ne=fo();Ah(Ve.prototype,go.prototype);Ah(Ve,go);{let t=i0(Ne.prototype);for(let e=0;e<t.length;e++){let r=t[e];Ve.prototype[r]||(Ve.prototype[r]=Ne.prototype[r]);}}function Ve(t){if(!(this instanceof Ve))return new Ve(t);go.call(this,t),Ne.call(this,t),t?(this.allowHalfOpen=t.allowHalfOpen!==!1,t.readable===!1&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),t.writable===!1&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0)):this.allowHalfOpen=!0;}r0(Ve.prototype,{writable:{__proto__:null,...It(Ne.prototype,"writable")},writableHighWaterMark:{__proto__:null,...It(Ne.prototype,"writableHighWaterMark")},writableObjectMode:{__proto__:null,...It(Ne.prototype,"writableObjectMode")},writableBuffer:{__proto__:null,...It(Ne.prototype,"writableBuffer")},writableLength:{__proto__:null,...It(Ne.prototype,"writableLength")},writableFinished:{__proto__:null,...It(Ne.prototype,"writableFinished")},writableCorked:{__proto__:null,...It(Ne.prototype,"writableCorked")},writableEnded:{__proto__:null,...It(Ne.prototype,"writableEnded")},writableNeedDrain:{__proto__:null,...It(Ne.prototype,"writableNeedDrain")},destroyed:{__proto__:null,get(){return this._readableState===void 0||this._writableState===void 0?!1:this._readableState.destroyed&&this._writableState.destroyed},set(t){this._readableState&&this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t);}}});var ho;function Ih(){return ho===void 0&&(ho={}),ho}Ve.fromWeb=function(t,e){return Ih().newStreamDuplexFromReadableWritablePair(t,e)};Ve.toWeb=function(t){return Ih().newReadableWritablePairFromDuplex(t)};var po;Ve.from=function(t){return po||(po=Sh()),po(t,"body")};});var wo=M((DR,Ch)=>{v();m();_();var{ObjectSetPrototypeOf:Rh,Symbol:n0}=ce();Ch.exports=Tt;var{ERR_METHOD_NOT_IMPLEMENTED:s0}=Se().codes,bo=nt(),{getHighWaterMark:o0}=sn();Rh(Tt.prototype,bo.prototype);Rh(Tt,bo);var bi=n0("kCallback");function Tt(t){if(!(this instanceof Tt))return new Tt(t);let e=t?o0(this,t,"readableHighWaterMark",!0):null;e===0&&(t={...t,highWaterMark:null,readableHighWaterMark:e,writableHighWaterMark:t.writableHighWaterMark||0}),bo.call(this,t),this._readableState.sync=!1,this[bi]=null,t&&(typeof t.transform=="function"&&(this._transform=t.transform),typeof t.flush=="function"&&(this._flush=t.flush)),this.on("prefinish",a0);}function yo(t){typeof this._flush=="function"&&!this.destroyed?this._flush((e,r)=>{if(e){t?t(e):this.destroy(e);return}r!=null&&this.push(r),this.push(null),t&&t();}):(this.push(null),t&&t());}function a0(){this._final!==yo&&yo.call(this);}Tt.prototype._final=yo;Tt.prototype._transform=function(t,e,r){throw new s0("_transform()")};Tt.prototype._write=function(t,e,r){let i=this._readableState,n=this._writableState,o=i.length;this._transform(t,e,(s,a)=>{if(s){r(s);return}a!=null&&this.push(a),n.ended||o===i.length||i.length<i.highWaterMark?r():this[bi]=r;});};Tt.prototype._read=function(){if(this[bi]){let t=this[bi];this[bi]=null,t();}};});var mo=M((QR,Ph)=>{v();m();_();var{ObjectSetPrototypeOf:Bh}=ce();Ph.exports=$r;var _o=wo();Bh($r.prototype,_o.prototype);Bh($r,_o);function $r(t){if(!(this instanceof $r))return new $r(t);_o.call(this,t);}$r.prototype._transform=function(t,e,r){r(null,t);};});var mn=M((sC,Lh)=>{v();m();_();var wi=Nt(),{ArrayIsArray:l0,Promise:u0,SymbolAsyncIterator:f0}=ce(),_n=vt(),{once:c0}=Je(),h0=tr(),kh=nt(),{aggregateTwoErrors:d0,codes:{ERR_INVALID_ARG_TYPE:Co,ERR_INVALID_RETURN_VALUE:vo,ERR_MISSING_ARGS:p0,ERR_STREAM_DESTROYED:g0,ERR_STREAM_PREMATURE_CLOSE:y0},AbortError:b0}=Se(),{validateFunction:w0,validateAbortSignal:_0}=fi(),{isIterable:cr,isReadable:Eo,isReadableNodeStream:wn,isNodeStream:Oh,isTransformStream:Hr,isWebStream:m0,isReadableStream:So,isReadableEnded:v0}=tt(),E0=globalThis.AbortController||Hi().AbortController,Ao,Io;function xh(t,e,r){let i=!1;t.on("close",()=>{i=!0;});let n=_n(t,{readable:e,writable:r},o=>{i=!o;});return {destroy:o=>{i||(i=!0,h0.destroyer(t,o||new g0("pipe")));},cleanup:n}}function S0(t){return w0(t[t.length-1],"streams[stream.length - 1]"),t.pop()}function To(t){if(cr(t))return t;if(wn(t))return A0(t);throw new Co("val",["Readable","Iterable","AsyncIterable"],t)}async function*A0(t){Io||(Io=di()),yield*Io.prototype[f0].call(t);}async function bn(t,e,r,{end:i}){let n,o=null,s=c=>{if(c&&(n=c),o){let h=o;o=null,h();}},a=()=>new u0((c,h)=>{n?h(n):o=()=>{n?h(n):c();};});e.on("drain",s);let u=_n(e,{readable:!1},s);try{e.writableNeedDrain&&await a();for await(let c of t)e.write(c)||await a();i&&e.end(),await a(),r();}catch(c){r(n!==c?d0(n,c):c);}finally{u(),e.off("drain",s);}}async function Ro(t,e,r,{end:i}){Hr(e)&&(e=e.writable);let n=e.getWriter();try{for await(let o of t)await n.ready,n.write(o).catch(()=>{});await n.ready,i&&await n.close(),r();}catch(o){try{await n.abort(o),r(o);}catch(s){r(s);}}}function I0(...t){return Mh(t,c0(S0(t)))}function Mh(t,e,r){if(t.length===1&&l0(t[0])&&(t=t[0]),t.length<2)throw new p0("streams");let i=new E0,n=i.signal,o=r?.signal,s=[];_0(o,"options.signal");function a(){y(new b0);}o?.addEventListener("abort",a);let u,c,h=[],d=0;function g(B){y(B,--d===0);}function y(B,R){if(B&&(!u||u.code==="ERR_STREAM_PREMATURE_CLOSE")&&(u=B),!(!u&&!R)){for(;h.length;)h.shift()(u);o?.removeEventListener("abort",a),i.abort(),R&&(u||s.forEach(U=>U()),wi.nextTick(e,u,c));}}let w;for(let B=0;B<t.length;B++){let R=t[B],U=B<t.length-1,N=B>0,W=U||r?.end!==!1,K=B===t.length-1;if(Oh(R)){let z=function(Q){Q&&Q.name!=="AbortError"&&Q.code!=="ERR_STREAM_PREMATURE_CLOSE"&&g(Q);};if(W){let{destroy:Q,cleanup:de}=xh(R,U,N);h.push(Q),Eo(R)&&K&&s.push(de);}R.on("error",z),Eo(R)&&K&&s.push(()=>{R.removeListener("error",z);});}if(B===0)if(typeof R=="function"){if(w=R({signal:n}),!cr(w))throw new vo("Iterable, AsyncIterable or Stream","source",w)}else cr(R)||wn(R)||Hr(R)?w=R:w=kh.from(R);else if(typeof R=="function"){if(Hr(w)){var E;w=To((E=w)===null||E===void 0?void 0:E.readable);}else w=To(w);if(w=R(w,{signal:n}),U){if(!cr(w,!0))throw new vo("AsyncIterable",`transform[${B-1}]`,w)}else {var S;Ao||(Ao=mo());let z=new Ao({objectMode:!0}),Q=(S=w)===null||S===void 0?void 0:S.then;if(typeof Q=="function")d++,Q.call(w,pe=>{c=pe,pe!=null&&z.write(pe),W&&z.end(),wi.nextTick(g);},pe=>{z.destroy(pe),wi.nextTick(g,pe);});else if(cr(w,!0))d++,bn(w,z,g,{end:W});else if(So(w)||Hr(w)){let pe=w.readable||w;d++,bn(pe,z,g,{end:W});}else throw new vo("AsyncIterable or Promise","destination",w);w=z;let{destroy:de,cleanup:Gt}=xh(w,!1,!0);h.push(de),K&&s.push(Gt);}}else if(Oh(R)){if(wn(w)){d+=2;let z=T0(w,R,g,{end:W});Eo(R)&&K&&s.push(z);}else if(Hr(w)||So(w)){let z=w.readable||w;d++,bn(z,R,g,{end:W});}else if(cr(w))d++,bn(w,R,g,{end:W});else throw new Co("val",["Readable","Iterable","AsyncIterable","ReadableStream","TransformStream"],w);w=R;}else if(m0(R)){if(wn(w))d++,Ro(To(w),R,g,{end:W});else if(So(w)||cr(w))d++,Ro(w,R,g,{end:W});else if(Hr(w))d++,Ro(w.readable,R,g,{end:W});else throw new Co("val",["Readable","Iterable","AsyncIterable","ReadableStream","TransformStream"],w);w=R;}else w=kh.from(R);}return (n!=null&&n.aborted||o!=null&&o.aborted)&&wi.nextTick(a),w}function T0(t,e,r,{end:i}){let n=!1;if(e.on("close",()=>{n||r(new y0);}),t.pipe(e,{end:!1}),i){let s=function(){n=!0,e.end();};v0(t)?wi.nextTick(s):t.once("end",s);}else r();return _n(t,{readable:!0,writable:!1},s=>{let a=t._readableState;s&&s.code==="ERR_STREAM_PREMATURE_CLOSE"&&a&&a.ended&&!a.errored&&!a.errorEmitted?t.once("end",r).once("error",r):r(s);}),_n(e,{readable:!1,writable:!0},r)}Lh.exports={pipelineImpl:Mh,pipeline:I0};});var Po=M((gC,Fh)=>{v();m();_();var{pipeline:R0}=mn(),vn=nt(),{destroyer:C0}=tr(),{isNodeStream:En,isReadable:Uh,isWritable:Nh,isWebStream:Bo,isTransformStream:hr,isWritableStream:qh,isReadableStream:Dh}=tt(),{AbortError:B0,codes:{ERR_INVALID_ARG_VALUE:jh,ERR_MISSING_ARGS:P0}}=Se(),k0=vt();Fh.exports=function(...e){if(e.length===0)throw new P0("streams");if(e.length===1)return vn.from(e[0]);let r=[...e];if(typeof e[0]=="function"&&(e[0]=vn.from(e[0])),typeof e[e.length-1]=="function"){let y=e.length-1;e[y]=vn.from(e[y]);}for(let y=0;y<e.length;++y)if(!(!En(e[y])&&!Bo(e[y]))){if(y<e.length-1&&!(Uh(e[y])||Dh(e[y])||hr(e[y])))throw new jh(`streams[${y}]`,r[y],"must be readable");if(y>0&&!(Nh(e[y])||qh(e[y])||hr(e[y])))throw new jh(`streams[${y}]`,r[y],"must be writable")}let i,n,o,s,a;function u(y){let w=s;s=null,w?w(y):y?a.destroy(y):!g&&!d&&a.destroy();}let c=e[0],h=R0(e,u),d=!!(Nh(c)||qh(c)||hr(c)),g=!!(Uh(h)||Dh(h)||hr(h));if(a=new vn({writableObjectMode:!!(c!=null&&c.writableObjectMode),readableObjectMode:!!(h!=null&&h.writableObjectMode),writable:d,readable:g}),d){if(En(c))a._write=function(w,E,S){c.write(w,E)?S():i=S;},a._final=function(w){c.end(),n=w;},c.on("drain",function(){if(i){let w=i;i=null,w();}});else if(Bo(c)){let E=(hr(c)?c.writable:c).getWriter();a._write=async function(S,I,B){try{await E.ready,E.write(S).catch(()=>{}),B();}catch(R){B(R);}},a._final=async function(S){try{await E.ready,E.close().catch(()=>{}),n=S;}catch(I){S(I);}};}let y=hr(h)?h.readable:h;k0(y,()=>{if(n){let w=n;n=null,w();}});}if(g){if(En(h))h.on("readable",function(){if(o){let y=o;o=null,y();}}),h.on("end",function(){a.push(null);}),a._read=function(){for(;;){let y=h.read();if(y===null){o=a._read;return}if(!a.push(y))return}};else if(Bo(h)){let w=(hr(h)?h.readable:h).getReader();a._read=async function(){for(;;)try{let{value:E,done:S}=await w.read();if(!a.push(E))return;if(S){a.push(null);return}}catch{return}};}}return a._destroy=function(y,w){!y&&s!==null&&(y=new B0),o=null,i=null,n=null,s===null?w(y):(s=w,En(h)&&C0(h,y));},a};});var Qh=M((IC,xo)=>{v();m();_();var Vh=globalThis.AbortController||Hi().AbortController,{codes:{ERR_INVALID_ARG_VALUE:O0,ERR_INVALID_ARG_TYPE:_i,ERR_MISSING_ARGS:x0,ERR_OUT_OF_RANGE:M0},AbortError:st}=Se(),{validateAbortSignal:dr,validateInteger:L0,validateObject:pr}=fi(),U0=ce().Symbol("kWeak"),{finished:N0}=vt(),q0=Po(),{addAbortSignalNoValidate:D0}=ci(),{isWritable:j0,isNodeStream:F0}=tt(),{ArrayPrototypePush:W0,MathFloor:$0,Number:H0,NumberIsNaN:V0,Promise:Wh,PromiseReject:$h,PromisePrototypeThen:z0,Symbol:zh}=ce(),Sn=zh("kEmpty"),Hh=zh("kEof");function K0(t,e){if(e!=null&&pr(e,"options"),e?.signal!=null&&dr(e.signal,"options.signal"),F0(t)&&!j0(t))throw new O0("stream",t,"must be writable");let r=q0(this,t);return e!=null&&e.signal&&D0(e.signal,r),r}function An(t,e){if(typeof t!="function")throw new _i("fn",["Function","AsyncFunction"],t);e!=null&&pr(e,"options"),e?.signal!=null&&dr(e.signal,"options.signal");let r=1;return e?.concurrency!=null&&(r=$0(e.concurrency)),L0(r,"concurrency",1),async function*(){var n,o;let s=new Vh,a=this,u=[],c=s.signal,h={signal:c},d=()=>s.abort();e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted&&d(),e==null||(o=e.signal)===null||o===void 0||o.addEventListener("abort",d);let g,y,w=!1;function E(){w=!0;}async function S(){try{for await(let R of a){var I;if(w)return;if(c.aborted)throw new st;try{R=t(R,h);}catch(U){R=$h(U);}R!==Sn&&(typeof((I=R)===null||I===void 0?void 0:I.catch)=="function"&&R.catch(E),u.push(R),g&&(g(),g=null),!w&&u.length&&u.length>=r&&await new Wh(U=>{y=U;}));}u.push(Hh);}catch(R){let U=$h(R);z0(U,void 0,E),u.push(U);}finally{var B;w=!0,g&&(g(),g=null),e==null||(B=e.signal)===null||B===void 0||B.removeEventListener("abort",d);}}S();try{for(;;){for(;u.length>0;){let I=await u[0];if(I===Hh)return;if(c.aborted)throw new st;I!==Sn&&(yield I),u.shift(),y&&(y(),y=null);}await new Wh(I=>{g=I;});}}finally{s.abort(),w=!0,y&&(y(),y=null);}}.call(this)}function G0(t=void 0){return t!=null&&pr(t,"options"),t?.signal!=null&&dr(t.signal,"options.signal"),async function*(){let r=0;for await(let n of this){var i;if(t!=null&&(i=t.signal)!==null&&i!==void 0&&i.aborted)throw new st({cause:t.signal.reason});yield [r++,n];}}.call(this)}async function Kh(t,e=void 0){for await(let r of Oo.call(this,t,e))return !0;return !1}async function Q0(t,e=void 0){if(typeof t!="function")throw new _i("fn",["Function","AsyncFunction"],t);return !await Kh.call(this,async(...r)=>!await t(...r),e)}async function Y0(t,e){for await(let r of Oo.call(this,t,e))return r}async function J0(t,e){if(typeof t!="function")throw new _i("fn",["Function","AsyncFunction"],t);async function r(i,n){return await t(i,n),Sn}for await(let i of An.call(this,r,e));}function Oo(t,e){if(typeof t!="function")throw new _i("fn",["Function","AsyncFunction"],t);async function r(i,n){return await t(i,n)?i:Sn}return An.call(this,r,e)}var ko=class extends x0{constructor(){super("reduce"),this.message="Reduce of an empty stream requires an initial value";}};async function X0(t,e,r){var i;if(typeof t!="function")throw new _i("reducer",["Function","AsyncFunction"],t);r!=null&&pr(r,"options"),r?.signal!=null&&dr(r.signal,"options.signal");let n=arguments.length>1;if(r!=null&&(i=r.signal)!==null&&i!==void 0&&i.aborted){let c=new st(void 0,{cause:r.signal.reason});throw this.once("error",()=>{}),await N0(this.destroy(c)),c}let o=new Vh,s=o.signal;if(r!=null&&r.signal){let c={once:!0,[U0]:this};r.signal.addEventListener("abort",()=>o.abort(),c);}let a=!1;try{for await(let c of this){var u;if(a=!0,r!=null&&(u=r.signal)!==null&&u!==void 0&&u.aborted)throw new st;n?e=await t(e,c,{signal:s}):(e=c,n=!0);}if(!a&&!n)throw new ko}finally{o.abort();}return e}async function Z0(t){t!=null&&pr(t,"options"),t?.signal!=null&&dr(t.signal,"options.signal");let e=[];for await(let i of this){var r;if(t!=null&&(r=t.signal)!==null&&r!==void 0&&r.aborted)throw new st(void 0,{cause:t.signal.reason});W0(e,i);}return e}function em(t,e){let r=An.call(this,t,e);return async function*(){for await(let n of r)yield*n;}.call(this)}function Gh(t){if(t=H0(t),V0(t))return 0;if(t<0)throw new M0("number",">= 0",t);return t}function tm(t,e=void 0){return e!=null&&pr(e,"options"),e?.signal!=null&&dr(e.signal,"options.signal"),t=Gh(t),async function*(){var i;if(e!=null&&(i=e.signal)!==null&&i!==void 0&&i.aborted)throw new st;for await(let o of this){var n;if(e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted)throw new st;t--<=0&&(yield o);}}.call(this)}function rm(t,e=void 0){return e!=null&&pr(e,"options"),e?.signal!=null&&dr(e.signal,"options.signal"),t=Gh(t),async function*(){var i;if(e!=null&&(i=e.signal)!==null&&i!==void 0&&i.aborted)throw new st;for await(let o of this){var n;if(e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted)throw new st;if(t-- >0)yield o;else return}}.call(this)}xo.exports.streamReturningOperators={asIndexedPairs:G0,drop:tm,filter:Oo,flatMap:em,map:An,take:rm,compose:K0};xo.exports.promiseReturningOperators={every:Q0,forEach:J0,reduce:X0,toArray:Z0,some:Kh,find:Y0};});var Mo=M((LC,Yh)=>{v();m();_();var{ArrayPrototypePop:im,Promise:nm}=ce(),{isIterable:sm,isNodeStream:om,isWebStream:am}=tt(),{pipelineImpl:lm}=mn(),{finished:um}=vt();Lo();function fm(...t){return new nm((e,r)=>{let i,n,o=t[t.length-1];if(o&&typeof o=="object"&&!om(o)&&!sm(o)&&!am(o)){let s=im(t);i=s.signal,n=s.end;}lm(t,(s,a)=>{s?r(s):e(a);},{signal:i,end:n});})}Yh.exports={finished:um,pipeline:fm};});var Lo=M((VC,sd)=>{v();m();_();var{Buffer:cm}=(ye(),X(_e)),{ObjectDefineProperty:Rt,ObjectKeys:Zh,ReflectApply:ed}=ce(),{promisify:{custom:td}}=Je(),{streamReturningOperators:Jh,promiseReturningOperators:Xh}=Qh(),{codes:{ERR_ILLEGAL_CONSTRUCTOR:rd}}=Se(),hm=Po(),{pipeline:id}=mn(),{destroyer:dm}=tr(),nd=vt(),Uo=Mo(),No=tt(),le=sd.exports=tn().Stream;le.isDisturbed=No.isDisturbed;le.isErrored=No.isErrored;le.isReadable=No.isReadable;le.Readable=di();for(let t of Zh(Jh)){let r=function(...i){if(new.target)throw rd();return le.Readable.from(ed(e,this,i))};let e=Jh[t];Rt(r,"name",{__proto__:null,value:e.name}),Rt(r,"length",{__proto__:null,value:e.length}),Rt(le.Readable.prototype,t,{__proto__:null,value:r,enumerable:!1,configurable:!0,writable:!0});}for(let t of Zh(Xh)){let r=function(...n){if(new.target)throw rd();return ed(e,this,n)};let e=Xh[t];Rt(r,"name",{__proto__:null,value:e.name}),Rt(r,"length",{__proto__:null,value:e.length}),Rt(le.Readable.prototype,t,{__proto__:null,value:r,enumerable:!1,configurable:!0,writable:!0});}le.Writable=fo();le.Duplex=nt();le.Transform=wo();le.PassThrough=mo();le.pipeline=id;var{addAbortSignal:pm}=ci();le.addAbortSignal=pm;le.finished=nd;le.destroy=dm;le.compose=hm;Rt(le,"promises",{__proto__:null,configurable:!0,enumerable:!0,get(){return Uo}});Rt(id,td,{__proto__:null,enumerable:!0,get(){return Uo.pipeline}});Rt(nd,td,{__proto__:null,enumerable:!0,get(){return Uo.finished}});le.Stream=le;le._isUint8Array=function(e){return e instanceof Uint8Array};le._uint8ArrayToBuffer=function(e){return cm.from(e.buffer,e.byteOffset,e.byteLength)};});var jt=M((tB,ue)=>{v();m();_();var he=Lo(),gm=Mo(),ym=he.Readable.destroy;ue.exports=he.Readable;ue.exports._uint8ArrayToBuffer=he._uint8ArrayToBuffer;ue.exports._isUint8Array=he._isUint8Array;ue.exports.isDisturbed=he.isDisturbed;ue.exports.isErrored=he.isErrored;ue.exports.isReadable=he.isReadable;ue.exports.Readable=he.Readable;ue.exports.Writable=he.Writable;ue.exports.Duplex=he.Duplex;ue.exports.Transform=he.Transform;ue.exports.PassThrough=he.PassThrough;ue.exports.addAbortSignal=he.addAbortSignal;ue.exports.finished=he.finished;ue.exports.destroy=he.destroy;ue.exports.destroy=ym;ue.exports.pipeline=he.pipeline;ue.exports.compose=he.compose;Object.defineProperty(he,"promises",{configurable:!0,enumerable:!0,get(){return gm}});ue.exports.Stream=he.Stream;ue.exports.default=ue.exports;});var od=M((cB,Do)=>{v();m();_();typeof Object.create=="function"?Do.exports=function(e,r){r&&(e.super_=r,e.prototype=Object.create(r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}));}:Do.exports=function(e,r){if(r){e.super_=r;var i=function(){};i.prototype=r.prototype,e.prototype=new i,e.prototype.constructor=e;}};});var ud=M((vB,ld)=>{v();m();_();var{Buffer:ze}=(ye(),X(_e)),ad=Symbol.for("BufferList");function ee(t){if(!(this instanceof ee))return new ee(t);ee._init.call(this,t);}ee._init=function(e){Object.defineProperty(this,ad,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e);};ee.prototype._new=function(e){return new ee(e)};ee.prototype._offset=function(e){if(e===0)return [0,0];let r=0;for(let i=0;i<this._bufs.length;i++){let n=r+this._bufs[i].length;if(e<n||i===this._bufs.length-1)return [i,e-r];r=n;}};ee.prototype._reverseOffset=function(t){let e=t[0],r=t[1];for(let i=0;i<e;i++)r+=this._bufs[i].length;return r};ee.prototype.get=function(e){if(e>this.length||e<0)return;let r=this._offset(e);return this._bufs[r[0]][r[1]]};ee.prototype.slice=function(e,r){return typeof e=="number"&&e<0&&(e+=this.length),typeof r=="number"&&r<0&&(r+=this.length),this.copy(null,0,e,r)};ee.prototype.copy=function(e,r,i,n){if((typeof i!="number"||i<0)&&(i=0),(typeof n!="number"||n>this.length)&&(n=this.length),i>=this.length||n<=0)return e||ze.alloc(0);let o=!!e,s=this._offset(i),a=n-i,u=a,c=o&&r||0,h=s[1];if(i===0&&n===this.length){if(!o)return this._bufs.length===1?this._bufs[0]:ze.concat(this._bufs,this.length);for(let d=0;d<this._bufs.length;d++)this._bufs[d].copy(e,c),c+=this._bufs[d].length;return e}if(u<=this._bufs[s[0]].length-h)return o?this._bufs[s[0]].copy(e,r,h,h+u):this._bufs[s[0]].slice(h,h+u);o||(e=ze.allocUnsafe(a));for(let d=s[0];d<this._bufs.length;d++){let g=this._bufs[d].length-h;if(u>g)this._bufs[d].copy(e,c,h),c+=g;else {this._bufs[d].copy(e,c,h,h+u),c+=g;break}u-=g,h&&(h=0);}return e.length>c?e.slice(0,c):e};ee.prototype.shallowSlice=function(e,r){if(e=e||0,r=typeof r!="number"?this.length:r,e<0&&(e+=this.length),r<0&&(r+=this.length),e===r)return this._new();let i=this._offset(e),n=this._offset(r),o=this._bufs.slice(i[0],n[0]+1);return n[1]===0?o.pop():o[o.length-1]=o[o.length-1].slice(0,n[1]),i[1]!==0&&(o[0]=o[0].slice(i[1])),this._new(o)};ee.prototype.toString=function(e,r,i){return this.slice(r,i).toString(e)};ee.prototype.consume=function(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;for(;this._bufs.length;)if(e>=this._bufs[0].length)e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else {this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}return this};ee.prototype.duplicate=function(){let e=this._new();for(let r=0;r<this._bufs.length;r++)e.append(this._bufs[r]);return e};ee.prototype.append=function(e){if(e==null)return this;if(e.buffer)this._appendBuffer(ze.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let r=0;r<e.length;r++)this.append(e[r]);else if(this._isBufferList(e))for(let r=0;r<e._bufs.length;r++)this.append(e._bufs[r]);else typeof e=="number"&&(e=e.toString()),this._appendBuffer(ze.from(e));return this};ee.prototype._appendBuffer=function(e){this._bufs.push(e),this.length+=e.length;};ee.prototype.indexOf=function(t,e,r){if(r===void 0&&typeof e=="string"&&(r=e,e=void 0),typeof t=="function"||Array.isArray(t))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof t=="number"?t=ze.from([t]):typeof t=="string"?t=ze.from(t,r):this._isBufferList(t)?t=t.slice():Array.isArray(t.buffer)?t=ze.from(t.buffer,t.byteOffset,t.byteLength):ze.isBuffer(t)||(t=ze.from(t)),e=Number(e||0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let i=this._offset(e),n=i[0],o=i[1];for(;n<this._bufs.length;n++){let s=this._bufs[n];for(;o<s.length;)if(s.length-o>=t.length){let u=s.indexOf(t,o);if(u!==-1)return this._reverseOffset([n,u]);o=s.length-t.length+1;}else {let u=this._reverseOffset([n,o]);if(this._match(u,t))return u;o++;}o=0;}return -1};ee.prototype._match=function(t,e){if(this.length-t<e.length)return !1;for(let r=0;r<e.length;r++)if(this.get(t+r)!==e[r])return !1;return !0};(function(){let t={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readBigInt64BE:8,readBigInt64LE:8,readBigUInt64BE:8,readBigUInt64LE:8,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(let e in t)(function(r){t[r]===null?ee.prototype[r]=function(i,n){return this.slice(i,i+n)[r](0,n)}:ee.prototype[r]=function(i=0){return this.slice(i,i+t[r])[r](0)};})(e);})();ee.prototype._isBufferList=function(e){return e instanceof ee||ee.isBufferList(e)};ee.isBufferList=function(e){return e!=null&&e[ad]};ld.exports=ee;});var fd=M((kB,In)=>{v();m();_();var jo=jt().Duplex,bm=od(),mi=ud();function Ee(t){if(!(this instanceof Ee))return new Ee(t);if(typeof t=="function"){this._callback=t;let e=function(i){this._callback&&(this._callback(i),this._callback=null);}.bind(this);this.on("pipe",function(i){i.on("error",e);}),this.on("unpipe",function(i){i.removeListener("error",e);}),t=null;}mi._init.call(this,t),jo.call(this);}bm(Ee,jo);Object.assign(Ee.prototype,mi.prototype);Ee.prototype._new=function(e){return new Ee(e)};Ee.prototype._write=function(e,r,i){this._appendBuffer(e),typeof i=="function"&&i();};Ee.prototype._read=function(e){if(!this.length)return this.push(null);e=Math.min(e,this.length),this.push(this.slice(0,e)),this.consume(e);};Ee.prototype.end=function(e){jo.prototype.end.call(this,e),this._callback&&(this._callback(null,this.slice()),this._callback=null);};Ee.prototype._destroy=function(e,r){this._bufs.length=0,this.length=0,r(e);};Ee.prototype._isBufferList=function(e){return e instanceof Ee||e instanceof mi||Ee.isBufferList(e)};Ee.isBufferList=mi.isBufferList;In.exports=Ee;In.exports.BufferListStream=Ee;In.exports.BufferList=mi;});var hd=M((FB,cd)=>{v();m();_();var Fo=class{constructor(){this.cmd=null,this.retain=!1,this.qos=0,this.dup=!1,this.length=-1,this.topic=null,this.payload=null;}};cd.exports=Fo;});var Wo=M((JB,dd)=>{v();m();_();var L=dd.exports,{Buffer:ke}=(ye(),X(_e));L.types={0:"reserved",1:"connect",2:"connack",3:"publish",4:"puback",5:"pubrec",6:"pubrel",7:"pubcomp",8:"subscribe",9:"suback",10:"unsubscribe",11:"unsuback",12:"pingreq",13:"pingresp",14:"disconnect",15:"auth"};L.requiredHeaderFlags={1:0,2:0,4:0,5:0,6:2,7:0,8:2,9:0,10:2,11:0,12:0,13:0,14:0,15:0};L.requiredHeaderFlagsErrors={};for(let t in L.requiredHeaderFlags){let e=L.requiredHeaderFlags[t];L.requiredHeaderFlagsErrors[t]="Invalid header flag bits, must be 0x"+e.toString(16)+" for "+L.types[t]+" packet";}L.codes={};for(let t in L.types){let e=L.types[t];L.codes[e]=t;}L.CMD_SHIFT=4;L.CMD_MASK=240;L.DUP_MASK=8;L.QOS_MASK=3;L.QOS_SHIFT=1;L.RETAIN_MASK=1;L.VARBYTEINT_MASK=127;L.VARBYTEINT_FIN_MASK=128;L.VARBYTEINT_MAX=268435455;L.SESSIONPRESENT_MASK=1;L.SESSIONPRESENT_HEADER=ke.from([L.SESSIONPRESENT_MASK]);L.CONNACK_HEADER=ke.from([L.codes.connack<<L.CMD_SHIFT]);L.USERNAME_MASK=128;L.PASSWORD_MASK=64;L.WILL_RETAIN_MASK=32;L.WILL_QOS_MASK=24;L.WILL_QOS_SHIFT=3;L.WILL_FLAG_MASK=4;L.CLEAN_SESSION_MASK=2;L.CONNECT_HEADER=ke.from([L.codes.connect<<L.CMD_SHIFT]);L.properties={sessionExpiryInterval:17,willDelayInterval:24,receiveMaximum:33,maximumPacketSize:39,topicAliasMaximum:34,requestResponseInformation:25,requestProblemInformation:23,userProperties:38,authenticationMethod:21,authenticationData:22,payloadFormatIndicator:1,messageExpiryInterval:2,contentType:3,responseTopic:8,correlationData:9,maximumQoS:36,retainAvailable:37,assignedClientIdentifier:18,reasonString:31,wildcardSubscriptionAvailable:40,subscriptionIdentifiersAvailable:41,sharedSubscriptionAvailable:42,serverKeepAlive:19,responseInformation:26,serverReference:28,topicAlias:35,subscriptionIdentifier:11};L.propertiesCodes={};for(let t in L.properties){let e=L.properties[t];L.propertiesCodes[e]=t;}L.propertiesTypes={sessionExpiryInterval:"int32",willDelayInterval:"int32",receiveMaximum:"int16",maximumPacketSize:"int32",topicAliasMaximum:"int16",requestResponseInformation:"byte",requestProblemInformation:"byte",userProperties:"pair",authenticationMethod:"string",authenticationData:"binary",payloadFormatIndicator:"byte",messageExpiryInterval:"int32",contentType:"string",responseTopic:"string",correlationData:"binary",maximumQoS:"int8",retainAvailable:"byte",assignedClientIdentifier:"string",reasonString:"string",wildcardSubscriptionAvailable:"byte",subscriptionIdentifiersAvailable:"byte",sharedSubscriptionAvailable:"byte",serverKeepAlive:"int16",responseInformation:"string",serverReference:"string",topicAlias:"int16",subscriptionIdentifier:"var"};function Ft(t){return [0,1,2].map(e=>[0,1].map(r=>[0,1].map(i=>{let n=ke.alloc(1);return n.writeUInt8(L.codes[t]<<L.CMD_SHIFT|(r?L.DUP_MASK:0)|e<<L.QOS_SHIFT|i,0,!0),n})))}L.PUBLISH_HEADER=Ft("publish");L.SUBSCRIBE_HEADER=Ft("subscribe");L.SUBSCRIBE_OPTIONS_QOS_MASK=3;L.SUBSCRIBE_OPTIONS_NL_MASK=1;L.SUBSCRIBE_OPTIONS_NL_SHIFT=2;L.SUBSCRIBE_OPTIONS_RAP_MASK=1;L.SUBSCRIBE_OPTIONS_RAP_SHIFT=3;L.SUBSCRIBE_OPTIONS_RH_MASK=3;L.SUBSCRIBE_OPTIONS_RH_SHIFT=4;L.SUBSCRIBE_OPTIONS_RH=[0,16,32];L.SUBSCRIBE_OPTIONS_NL=4;L.SUBSCRIBE_OPTIONS_RAP=8;L.SUBSCRIBE_OPTIONS_QOS=[0,1,2];L.UNSUBSCRIBE_HEADER=Ft("unsubscribe");L.ACKS={unsuback:Ft("unsuback"),puback:Ft("puback"),pubcomp:Ft("pubcomp"),pubrel:Ft("pubrel"),pubrec:Ft("pubrec")};L.SUBACK_HEADER=ke.from([L.codes.suback<<L.CMD_SHIFT]);L.VERSION3=ke.from([3]);L.VERSION4=ke.from([4]);L.VERSION5=ke.from([5]);L.VERSION131=ke.from([131]);L.VERSION132=ke.from([132]);L.QOS=[0,1,2].map(t=>ke.from([t]));L.EMPTY={pingreq:ke.from([L.codes.pingreq<<4,0]),pingresp:ke.from([L.codes.pingresp<<4,0]),disconnect:ke.from([L.codes.disconnect<<4,0])};L.MQTT5_PUBACK_PUBREC_CODES={0:"Success",16:"No matching subscribers",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",144:"Topic Name invalid",145:"Packet identifier in use",151:"Quota exceeded",153:"Payload format invalid"};L.MQTT5_PUBREL_PUBCOMP_CODES={0:"Success",146:"Packet Identifier not found"};L.MQTT5_SUBACK_CODES={0:"Granted QoS 0",1:"Granted QoS 1",2:"Granted QoS 2",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",143:"Topic Filter invalid",145:"Packet Identifier in use",151:"Quota exceeded",158:"Shared Subscriptions not supported",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"};L.MQTT5_UNSUBACK_CODES={0:"Success",17:"No subscription existed",128:"Unspecified error",131:"Implementation specific error",135:"Not authorized",143:"Topic Filter invalid",145:"Packet Identifier in use"};L.MQTT5_DISCONNECT_CODES={0:"Normal disconnection",4:"Disconnect with Will Message",128:"Unspecified error",129:"Malformed Packet",130:"Protocol Error",131:"Implementation specific error",135:"Not authorized",137:"Server busy",139:"Server shutting down",141:"Keep Alive timeout",142:"Session taken over",143:"Topic Filter invalid",144:"Topic Name invalid",147:"Receive Maximum exceeded",148:"Topic Alias invalid",149:"Packet too large",150:"Message rate too high",151:"Quota exceeded",152:"Administrative action",153:"Payload format invalid",154:"Retain not supported",155:"QoS not supported",156:"Use another server",157:"Server moved",158:"Shared Subscriptions not supported",159:"Connection rate exceeded",160:"Maximum connect time",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"};L.MQTT5_AUTH_CODES={0:"Success",24:"Continue authentication",25:"Re-authenticate"};});var gd=M((aP,pd)=>{v();m();_();var Vr=1e3,zr=Vr*60,Kr=zr*60,gr=Kr*24,wm=gr*7,_m=gr*365.25;pd.exports=function(t,e){e=e||{};var r=typeof t;if(r==="string"&&t.length>0)return mm(t);if(r==="number"&&isFinite(t))return e.long?Em(t):vm(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))};function mm(t){if(t=String(t),!(t.length>100)){var e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(e){var r=parseFloat(e[1]),i=(e[2]||"ms").toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return r*_m;case"weeks":case"week":case"w":return r*wm;case"days":case"day":case"d":return r*gr;case"hours":case"hour":case"hrs":case"hr":case"h":return r*Kr;case"minutes":case"minute":case"mins":case"min":case"m":return r*zr;case"seconds":case"second":case"secs":case"sec":case"s":return r*Vr;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}}}function vm(t){var e=Math.abs(t);return e>=gr?Math.round(t/gr)+"d":e>=Kr?Math.round(t/Kr)+"h":e>=zr?Math.round(t/zr)+"m":e>=Vr?Math.round(t/Vr)+"s":t+"ms"}function Em(t){var e=Math.abs(t);return e>=gr?Tn(t,e,gr,"day"):e>=Kr?Tn(t,e,Kr,"hour"):e>=zr?Tn(t,e,zr,"minute"):e>=Vr?Tn(t,e,Vr,"second"):t+" ms"}function Tn(t,e,r,i){var n=e>=r*1.5;return Math.round(t/r)+" "+i+(n?"s":"")}});var bd=M((bP,yd)=>{v();m();_();function Sm(t){r.debug=r,r.default=r,r.coerce=u,r.disable=o,r.enable=n,r.enabled=s,r.humanize=gd(),r.destroy=c,Object.keys(t).forEach(h=>{r[h]=t[h];}),r.names=[],r.skips=[],r.formatters={};function e(h){let d=0;for(let g=0;g<h.length;g++)d=(d<<5)-d+h.charCodeAt(g),d|=0;return r.colors[Math.abs(d)%r.colors.length]}r.selectColor=e;function r(h){let d,g=null,y,w;function E(...S){if(!E.enabled)return;let I=E,B=Number(new Date),R=B-(d||B);I.diff=R,I.prev=d,I.curr=B,d=B,S[0]=r.coerce(S[0]),typeof S[0]!="string"&&S.unshift("%O");let U=0;S[0]=S[0].replace(/%([a-zA-Z%])/g,(W,K)=>{if(W==="%%")return "%";U++;let z=r.formatters[K];if(typeof z=="function"){let Q=S[U];W=z.call(I,Q),S.splice(U,1),U--;}return W}),r.formatArgs.call(I,S),(I.log||r.log).apply(I,S);}return E.namespace=h,E.useColors=r.useColors(),E.color=r.selectColor(h),E.extend=i,E.destroy=r.destroy,Object.defineProperty(E,"enabled",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(y!==r.namespaces&&(y=r.namespaces,w=r.enabled(h)),w),set:S=>{g=S;}}),typeof r.init=="function"&&r.init(E),E}function i(h,d){let g=r(this.namespace+(typeof d>"u"?":":d)+h);return g.log=this.log,g}function n(h){r.save(h),r.namespaces=h,r.names=[],r.skips=[];let d,g=(typeof h=="string"?h:"").split(/[\s,]+/),y=g.length;for(d=0;d<y;d++)g[d]&&(h=g[d].replace(/\*/g,".*?"),h[0]==="-"?r.skips.push(new RegExp("^"+h.slice(1)+"$")):r.names.push(new RegExp("^"+h+"$")));}function o(){let h=[...r.names.map(a),...r.skips.map(a).map(d=>"-"+d)].join(",");return r.enable(""),h}function s(h){if(h[h.length-1]==="*")return !0;let d,g;for(d=0,g=r.skips.length;d<g;d++)if(r.skips[d].test(h))return !1;for(d=0,g=r.names.length;d<g;d++)if(r.names[d].test(h))return !0;return !1}function a(h){return h.toString().substring(2,h.toString().length-2).replace(/\.\*\?$/,"*")}function u(h){return h instanceof Error?h.stack||h.message:h}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");}return r.enable(r.load()),r}yd.exports=Sm;});var ot=M((xe,Rn)=>{v();m();_();xe.formatArgs=Im;xe.save=Tm;xe.load=Rm;xe.useColors=Am;xe.storage=Cm();xe.destroy=(()=>{let t=!1;return ()=>{t||(t=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));}})();xe.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Am(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof P<"u"&&P.userAgent&&P.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof P<"u"&&P.userAgent&&P.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof P<"u"&&P.userAgent&&P.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function Im(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+Rn.exports.humanize(this.diff),!this.useColors)return;let e="color: "+this.color;t.splice(1,0,e,"color: inherit");let r=0,i=0;t[0].replace(/%[a-zA-Z%]/g,n=>{n!=="%%"&&(r++,n==="%c"&&(i=r));}),t.splice(i,0,e);}xe.log=console.debug||console.log||(()=>{});function Tm(t){try{t?xe.storage.setItem("debug",t):xe.storage.removeItem("debug");}catch{}}function Rm(){let t;try{t=xe.storage.getItem("debug");}catch{}return !t&&typeof C<"u"&&"env"in C&&(t=C.env.DEBUG),t}function Cm(){try{return localStorage}catch{}}Rn.exports=bd()(xe);var{formatters:Bm}=Rn.exports;Bm.j=function(t){try{return JSON.stringify(t)}catch(e){return "[UnexpectedJSONParseError]: "+e.message}};});var md=M((UP,_d)=>{v();m();_();var Pm=fd(),{EventEmitter:km}=(ir(),X(rr)),wd=hd(),V=Wo(),D=ot()("mqtt-packet:parser"),$o=class t extends km{constructor(){super(),this.parser=this.constructor.parser;}static parser(e){return this instanceof t?(this.settings=e||{},this._states=["_parseHeader","_parseLength","_parsePayload","_newPacket"],this._resetState(),this):new t().parser(e)}_resetState(){D("_resetState: resetting packet, error, _list, and _stateCounter"),this.packet=new wd,this.error=null,this._list=Pm(),this._stateCounter=0;}parse(e){for(this.error&&this._resetState(),this._list.append(e),D("parse: current state: %s",this._states[this._stateCounter]);(this.packet.length!==-1||this._list.length>0)&&this[this._states[this._stateCounter]]()&&!this.error;)this._stateCounter++,D("parse: state complete. _stateCounter is now: %d",this._stateCounter),D("parse: packet.length: %d, buffer list length: %d",this.packet.length,this._list.length),this._stateCounter>=this._states.length&&(this._stateCounter=0);return D("parse: exited while loop. packet: %d, buffer list length: %d",this.packet.length,this._list.length),this._list.length}_parseHeader(){let e=this._list.readUInt8(0),r=e>>V.CMD_SHIFT;this.packet.cmd=V.types[r];let i=e&15,n=V.requiredHeaderFlags[r];return n!=null&&i!==n?this._emitError(new Error(V.requiredHeaderFlagsErrors[r])):(this.packet.retain=(e&V.RETAIN_MASK)!==0,this.packet.qos=e>>V.QOS_SHIFT&V.QOS_MASK,this.packet.qos>2?this._emitError(new Error("Packet must not have both QoS bits set to 1")):(this.packet.dup=(e&V.DUP_MASK)!==0,D("_parseHeader: packet: %o",this.packet),this._list.consume(1),!0))}_parseLength(){let e=this._parseVarByteNum(!0);return e&&(this.packet.length=e.value,this._list.consume(e.bytes)),D("_parseLength %d",e.value),!!e}_parsePayload(){D("_parsePayload: payload %O",this._list);let e=!1;if(this.packet.length===0||this._list.length>=this.packet.length){switch(this._pos=0,this.packet.cmd){case"connect":this._parseConnect();break;case"connack":this._parseConnack();break;case"publish":this._parsePublish();break;case"puback":case"pubrec":case"pubrel":case"pubcomp":this._parseConfirmation();break;case"subscribe":this._parseSubscribe();break;case"suback":this._parseSuback();break;case"unsubscribe":this._parseUnsubscribe();break;case"unsuback":this._parseUnsuback();break;case"pingreq":case"pingresp":break;case"disconnect":this._parseDisconnect();break;case"auth":this._parseAuth();break;default:this._emitError(new Error("Not supported"));}e=!0;}return D("_parsePayload complete result: %s",e),e}_parseConnect(){D("_parseConnect");let e,r,i,n,o={},s=this.packet,a=this._parseString();if(a===null)return this._emitError(new Error("Cannot parse protocolId"));if(a!=="MQTT"&&a!=="MQIsdp")return this._emitError(new Error("Invalid protocolId"));if(s.protocolId=a,this._pos>=this._list.length)return this._emitError(new Error("Packet too short"));if(s.protocolVersion=this._list.readUInt8(this._pos),s.protocolVersion>=128&&(s.bridgeMode=!0,s.protocolVersion=s.protocolVersion-128),s.protocolVersion!==3&&s.protocolVersion!==4&&s.protocolVersion!==5)return this._emitError(new Error("Invalid protocol version"));if(this._pos++,this._pos>=this._list.length)return this._emitError(new Error("Packet too short"));if(this._list.readUInt8(this._pos)&1)return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));o.username=this._list.readUInt8(this._pos)&V.USERNAME_MASK,o.password=this._list.readUInt8(this._pos)&V.PASSWORD_MASK,o.will=this._list.readUInt8(this._pos)&V.WILL_FLAG_MASK;let u=!!(this._list.readUInt8(this._pos)&V.WILL_RETAIN_MASK),c=(this._list.readUInt8(this._pos)&V.WILL_QOS_MASK)>>V.WILL_QOS_SHIFT;if(o.will)s.will={},s.will.retain=u,s.will.qos=c;else {if(u)return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));if(c)return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"))}if(s.clean=(this._list.readUInt8(this._pos)&V.CLEAN_SESSION_MASK)!==0,this._pos++,s.keepalive=this._parseNum(),s.keepalive===-1)return this._emitError(new Error("Packet too short"));if(s.protocolVersion===5){let d=this._parseProperties();Object.getOwnPropertyNames(d).length&&(s.properties=d);}let h=this._parseString();if(h===null)return this._emitError(new Error("Packet too short"));if(s.clientId=h,D("_parseConnect: packet.clientId: %s",s.clientId),o.will){if(s.protocolVersion===5){let d=this._parseProperties();Object.getOwnPropertyNames(d).length&&(s.will.properties=d);}if(e=this._parseString(),e===null)return this._emitError(new Error("Cannot parse will topic"));if(s.will.topic=e,D("_parseConnect: packet.will.topic: %s",s.will.topic),r=this._parseBuffer(),r===null)return this._emitError(new Error("Cannot parse will payload"));s.will.payload=r,D("_parseConnect: packet.will.paylaod: %s",s.will.payload);}if(o.username){if(n=this._parseString(),n===null)return this._emitError(new Error("Cannot parse username"));s.username=n,D("_parseConnect: packet.username: %s",s.username);}if(o.password){if(i=this._parseBuffer(),i===null)return this._emitError(new Error("Cannot parse password"));s.password=i;}return this.settings=s,D("_parseConnect: complete"),s}_parseConnack(){D("_parseConnack");let e=this.packet;if(this._list.length<1)return null;let r=this._list.readUInt8(this._pos++);if(r>1)return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));if(e.sessionPresent=!!(r&V.SESSIONPRESENT_MASK),this.settings.protocolVersion===5)this._list.length>=2?e.reasonCode=this._list.readUInt8(this._pos++):e.reasonCode=0;else {if(this._list.length<2)return null;e.returnCode=this._list.readUInt8(this._pos++);}if(e.returnCode===-1||e.reasonCode===-1)return this._emitError(new Error("Cannot parse return code"));if(this.settings.protocolVersion===5){let i=this._parseProperties();Object.getOwnPropertyNames(i).length&&(e.properties=i);}D("_parseConnack: complete");}_parsePublish(){D("_parsePublish");let e=this.packet;if(e.topic=this._parseString(),e.topic===null)return this._emitError(new Error("Cannot parse topic"));if(!(e.qos>0&&!this._parseMessageId())){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r);}e.payload=this._list.slice(this._pos,e.length),D("_parsePublish: payload from buffer list: %o",e.payload);}}_parseSubscribe(){D("_parseSubscribe");let e=this.packet,r,i,n,o,s,a,u;if(e.subscriptions=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let c=this._parseProperties();Object.getOwnPropertyNames(c).length&&(e.properties=c);}if(e.length<=0)return this._emitError(new Error("Malformed subscribe, no payload specified"));for(;this._pos<e.length;){if(r=this._parseString(),r===null)return this._emitError(new Error("Cannot parse topic"));if(this._pos>=e.length)return this._emitError(new Error("Malformed Subscribe Payload"));if(i=this._parseByte(),this.settings.protocolVersion===5){if(i&192)return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"))}else if(i&252)return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));if(n=i&V.SUBSCRIBE_OPTIONS_QOS_MASK,n>2)return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));if(a=(i>>V.SUBSCRIBE_OPTIONS_NL_SHIFT&V.SUBSCRIBE_OPTIONS_NL_MASK)!==0,s=(i>>V.SUBSCRIBE_OPTIONS_RAP_SHIFT&V.SUBSCRIBE_OPTIONS_RAP_MASK)!==0,o=i>>V.SUBSCRIBE_OPTIONS_RH_SHIFT&V.SUBSCRIBE_OPTIONS_RH_MASK,o>2)return this._emitError(new Error("Invalid retain handling, must be <= 2"));u={topic:r,qos:n},this.settings.protocolVersion===5?(u.nl=a,u.rap=s,u.rh=o):this.settings.bridgeMode&&(u.rh=0,u.rap=!0,u.nl=!0),D("_parseSubscribe: push subscription `%s` to subscription",u),e.subscriptions.push(u);}}}_parseSuback(){D("_parseSuback");let e=this.packet;if(this.packet.granted=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r);}if(e.length<=0)return this._emitError(new Error("Malformed suback, no payload specified"));for(;this._pos<this.packet.length;){let r=this._list.readUInt8(this._pos++);if(this.settings.protocolVersion===5){if(!V.MQTT5_SUBACK_CODES[r])return this._emitError(new Error("Invalid suback code"))}else if(r>2&&r!==128)return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));this.packet.granted.push(r);}}}_parseUnsubscribe(){D("_parseUnsubscribe");let e=this.packet;if(e.unsubscriptions=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r);}if(e.length<=0)return this._emitError(new Error("Malformed unsubscribe, no payload specified"));for(;this._pos<e.length;){let r=this._parseString();if(r===null)return this._emitError(new Error("Cannot parse topic"));D("_parseUnsubscribe: push topic `%s` to unsubscriptions",r),e.unsubscriptions.push(r);}}}_parseUnsuback(){D("_parseUnsuback");let e=this.packet;if(!this._parseMessageId())return this._emitError(new Error("Cannot parse messageId"));if((this.settings.protocolVersion===3||this.settings.protocolVersion===4)&&e.length!==2)return this._emitError(new Error("Malformed unsuback, payload length must be 2"));if(e.length<=0)return this._emitError(new Error("Malformed unsuback, no payload specified"));if(this.settings.protocolVersion===5){let r=this._parseProperties();for(Object.getOwnPropertyNames(r).length&&(e.properties=r),e.granted=[];this._pos<this.packet.length;){let i=this._list.readUInt8(this._pos++);if(!V.MQTT5_UNSUBACK_CODES[i])return this._emitError(new Error("Invalid unsuback code"));this.packet.granted.push(i);}}}_parseConfirmation(){D("_parseConfirmation: packet.cmd: `%s`",this.packet.cmd);let e=this.packet;if(this._parseMessageId(),this.settings.protocolVersion===5){if(e.length>2){switch(e.reasonCode=this._parseByte(),this.packet.cmd){case"puback":case"pubrec":if(!V.MQTT5_PUBACK_PUBREC_CODES[e.reasonCode])return this._emitError(new Error("Invalid "+this.packet.cmd+" reason code"));break;case"pubrel":case"pubcomp":if(!V.MQTT5_PUBREL_PUBCOMP_CODES[e.reasonCode])return this._emitError(new Error("Invalid "+this.packet.cmd+" reason code"));break}D("_parseConfirmation: packet.reasonCode `%d`",e.reasonCode);}else e.reasonCode=0;if(e.length>3){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r);}}return !0}_parseDisconnect(){let e=this.packet;if(D("_parseDisconnect"),this.settings.protocolVersion===5){this._list.length>0?(e.reasonCode=this._parseByte(),V.MQTT5_DISCONNECT_CODES[e.reasonCode]||this._emitError(new Error("Invalid disconnect reason code"))):e.reasonCode=0;let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r);}return D("_parseDisconnect result: true"),!0}_parseAuth(){D("_parseAuth");let e=this.packet;if(this.settings.protocolVersion!==5)return this._emitError(new Error("Not supported auth packet for this version MQTT"));if(e.reasonCode=this._parseByte(),!V.MQTT5_AUTH_CODES[e.reasonCode])return this._emitError(new Error("Invalid auth reason code"));let r=this._parseProperties();return Object.getOwnPropertyNames(r).length&&(e.properties=r),D("_parseAuth: result: true"),!0}_parseMessageId(){let e=this.packet;return e.messageId=this._parseNum(),e.messageId===null?(this._emitError(new Error("Cannot parse messageId")),!1):(D("_parseMessageId: packet.messageId %d",e.messageId),!0)}_parseString(e){let r=this._parseNum(),i=r+this._pos;if(r===-1||i>this._list.length||i>this.packet.length)return null;let n=this._list.toString("utf8",this._pos,i);return this._pos+=r,D("_parseString: result: %s",n),n}_parseStringPair(){return D("_parseStringPair"),{name:this._parseString(),value:this._parseString()}}_parseBuffer(){let e=this._parseNum(),r=e+this._pos;if(e===-1||r>this._list.length||r>this.packet.length)return null;let i=this._list.slice(this._pos,r);return this._pos+=e,D("_parseBuffer: result: %o",i),i}_parseNum(){if(this._list.length-this._pos<2)return -1;let e=this._list.readUInt16BE(this._pos);return this._pos+=2,D("_parseNum: result: %s",e),e}_parse4ByteNum(){if(this._list.length-this._pos<4)return -1;let e=this._list.readUInt32BE(this._pos);return this._pos+=4,D("_parse4ByteNum: result: %s",e),e}_parseVarByteNum(e){D("_parseVarByteNum");let r=4,i=0,n=1,o=0,s=!1,a,u=this._pos?this._pos:0;for(;i<r&&u+i<this._list.length;){if(a=this._list.readUInt8(u+i++),o+=n*(a&V.VARBYTEINT_MASK),n*=128,!(a&V.VARBYTEINT_FIN_MASK)){s=!0;break}if(this._list.length<=i)break}return !s&&i===r&&this._list.length>=i&&this._emitError(new Error("Invalid variable byte integer")),u&&(this._pos+=i),s?e?s={bytes:i,value:o}:s=o:s=!1,D("_parseVarByteNum: result: %o",s),s}_parseByte(){let e;return this._pos<this._list.length&&(e=this._list.readUInt8(this._pos),this._pos++),D("_parseByte: result: %o",e),e}_parseByType(e){switch(D("_parseByType: type: %s",e),e){case"byte":return this._parseByte()!==0;case"int8":return this._parseByte();case"int16":return this._parseNum();case"int32":return this._parse4ByteNum();case"var":return this._parseVarByteNum();case"string":return this._parseString();case"pair":return this._parseStringPair();case"binary":return this._parseBuffer()}}_parseProperties(){D("_parseProperties");let e=this._parseVarByteNum(),i=this._pos+e,n={};for(;this._pos<i;){let o=this._parseByte();if(!o)return this._emitError(new Error("Cannot parse property code type")),!1;let s=V.propertiesCodes[o];if(!s)return this._emitError(new Error("Unknown property")),!1;if(s==="userProperties"){n[s]||(n[s]=Object.create(null));let a=this._parseByType(V.propertiesTypes[s]);if(n[s][a.name])if(Array.isArray(n[s][a.name]))n[s][a.name].push(a.value);else {let u=n[s][a.name];n[s][a.name]=[u],n[s][a.name].push(a.value);}else n[s][a.name]=a.value;continue}n[s]?Array.isArray(n[s])?n[s].push(this._parseByType(V.propertiesTypes[s])):(n[s]=[n[s]],n[s].push(this._parseByType(V.propertiesTypes[s]))):n[s]=this._parseByType(V.propertiesTypes[s]);}return n}_newPacket(){return D("_newPacket"),this.packet&&(this._list.consume(this.packet.length),D("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d",this.packet.cmd,this.packet.payload,this.packet.length),this.emit("packet",this.packet)),D("_newPacket: new packet"),this.packet=new wd,this._pos=0,!0}_emitError(e){D("_emitError",e),this.error=e,this.emit("error",e);}};_d.exports=$o;});var Ad=M((zP,Sd)=>{v();m();_();var{Buffer:vi}=(ye(),X(_e)),Om=65536,vd={},xm=vi.isBuffer(vi.from([1,2]).subarray(0,1));function Ed(t){let e=vi.allocUnsafe(2);return e.writeUInt8(t>>8,0),e.writeUInt8(t&255,0+1),e}function Mm(){for(let t=0;t<Om;t++)vd[t]=Ed(t);}function Lm(t){let r=0,i=0,n=vi.allocUnsafe(4);do r=t%128|0,t=t/128|0,t>0&&(r=r|128),n.writeUInt8(r,i++);while(t>0&&i<4);return t>0&&(i=0),xm?n.subarray(0,i):n.slice(0,i)}function Um(t){let e=vi.allocUnsafe(4);return e.writeUInt32BE(t,0),e}Sd.exports={cache:vd,generateCache:Mm,generateNumber:Ed,genBufVariableByteInt:Lm,generate4ByteBuffer:Um};});var Id=M((rk,Ho)=>{v();m();_();typeof C>"u"||!C.version||C.version.indexOf("v0.")===0||C.version.indexOf("v1.")===0&&C.version.indexOf("v1.8.")!==0?Ho.exports={nextTick:Nm}:Ho.exports=C;function Nm(t,e,r,i){if(typeof t!="function")throw new TypeError('"callback" argument must be a function');var n=arguments.length,o,s;switch(n){case 0:case 1:return C.nextTick(t);case 2:return C.nextTick(function(){t.call(null,e);});case 3:return C.nextTick(function(){t.call(null,e,r);});case 4:return C.nextTick(function(){t.call(null,e,r,i);});default:for(o=new Array(n-1),s=0;s<o.length;)o[s++]=arguments[s];return C.nextTick(function(){t.apply(null,o);})}}});var Ko=M((hk,xd)=>{v();m();_();var j=Wo(),{Buffer:q}=(ye(),X(_e)),qm=q.allocUnsafe(0),Dm=q.from([0]),Ei=Ad(),jm=Id().nextTick,qe=ot()("mqtt-packet:writeToStream"),Cn=Ei.cache,Fm=Ei.generateNumber,Wm=Ei.generateCache,Vo=Ei.genBufVariableByteInt,$m=Ei.generate4ByteBuffer,Ie=zo,Bn=!0;function kd(t,e,r){switch(qe("generate called"),e.cork&&(e.cork(),jm(Hm,e)),Bn&&(Bn=!1,Wm()),qe("generate: packet.cmd: %s",t.cmd),t.cmd){case"connect":return Vm(t,e);case"connack":return zm(t,e,r);case"publish":return Km(t,e,r);case"puback":case"pubrec":case"pubrel":case"pubcomp":return Gm(t,e,r);case"subscribe":return Qm(t,e,r);case"suback":return Ym(t,e,r);case"unsubscribe":return Jm(t,e,r);case"unsuback":return Xm(t,e,r);case"pingreq":case"pingresp":return Zm(t,e);case"disconnect":return e1(t,e,r);case"auth":return t1(t,e,r);default:return e.destroy(new Error("Unknown command")),!1}}Object.defineProperty(kd,"cacheNumbers",{get(){return Ie===zo},set(t){t?((!Cn||Object.keys(Cn).length===0)&&(Bn=!0),Ie=zo):(Bn=!1,Ie=r1);}});function Hm(t){t.uncork();}function Vm(t,e,r){let i=t||{},n=i.protocolId||"MQTT",o=i.protocolVersion||4,s=i.will,a=i.clean,u=i.keepalive||0,c=i.clientId||"",h=i.username,d=i.password,g=i.properties;a===void 0&&(a=!0);let y=0;if(!n||typeof n!="string"&&!q.isBuffer(n))return e.destroy(new Error("Invalid protocolId")),!1;if(y+=n.length+2,o!==3&&o!==4&&o!==5)return e.destroy(new Error("Invalid protocol version")),!1;if(y+=1,(typeof c=="string"||q.isBuffer(c))&&(c||o>=4)&&(c||a))y+=q.byteLength(c)+2;else {if(o<4)return e.destroy(new Error("clientId must be supplied before 3.1.1")),!1;if(a*1===0)return e.destroy(new Error("clientId must be given if cleanSession set to 0")),!1}if(typeof u!="number"||u<0||u>65535||u%1!==0)return e.destroy(new Error("Invalid keepalive")),!1;y+=2,y+=1;let w,E;if(o===5){if(w=Wt(e,g),!w)return !1;y+=w.length;}if(s){if(typeof s!="object")return e.destroy(new Error("Invalid will")),!1;if(!s.topic||typeof s.topic!="string")return e.destroy(new Error("Invalid will topic")),!1;if(y+=q.byteLength(s.topic)+2,y+=2,s.payload)if(s.payload.length>=0)typeof s.payload=="string"?y+=q.byteLength(s.payload):y+=s.payload.length;else return e.destroy(new Error("Invalid will payload")),!1;if(E={},o===5){if(E=Wt(e,s.properties),!E)return !1;y+=E.length;}}let S=!1;if(h!=null)if(Pd(h))S=!0,y+=q.byteLength(h)+2;else return e.destroy(new Error("Invalid username")),!1;if(d!=null){if(!S)return e.destroy(new Error("Username is required to use password")),!1;if(Pd(d))y+=Od(d)+2;else return e.destroy(new Error("Invalid password")),!1}e.write(j.CONNECT_HEADER),De(e,y),Gr(e,n),i.bridgeMode&&(o+=128),e.write(o===131?j.VERSION131:o===132?j.VERSION132:o===4?j.VERSION4:o===5?j.VERSION5:j.VERSION3);let I=0;return I|=h!=null?j.USERNAME_MASK:0,I|=d!=null?j.PASSWORD_MASK:0,I|=s&&s.retain?j.WILL_RETAIN_MASK:0,I|=s&&s.qos?s.qos<<j.WILL_QOS_SHIFT:0,I|=s?j.WILL_FLAG_MASK:0,I|=a?j.CLEAN_SESSION_MASK:0,e.write(q.from([I])),Ie(e,u),o===5&&w.write(),Gr(e,c),s&&(o===5&&E.write(),yr(e,s.topic),Gr(e,s.payload)),h!=null&&Gr(e,h),d!=null&&Gr(e,d),!0}function zm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=i===5?n.reasonCode:n.returnCode,s=n.properties,a=2;if(typeof o!="number")return e.destroy(new Error("Invalid return code")),!1;let u=null;if(i===5){if(u=Wt(e,s),!u)return !1;a+=u.length;}return e.write(j.CONNACK_HEADER),De(e,a),e.write(n.sessionPresent?j.SESSIONPRESENT_HEADER:Dm),e.write(q.from([o])),u?.write(),!0}function Km(t,e,r){qe("publish: packet: %o",t);let i=r?r.protocolVersion:4,n=t||{},o=n.qos||0,s=n.retain?j.RETAIN_MASK:0,a=n.topic,u=n.payload||qm,c=n.messageId,h=n.properties,d=0;if(typeof a=="string")d+=q.byteLength(a)+2;else if(q.isBuffer(a))d+=a.length+2;else return e.destroy(new Error("Invalid topic")),!1;if(q.isBuffer(u)?d+=u.length:d+=q.byteLength(u),o&&typeof c!="number")return e.destroy(new Error("Invalid messageId")),!1;o&&(d+=2);let g=null;if(i===5){if(g=Wt(e,h),!g)return !1;d+=g.length;}return e.write(j.PUBLISH_HEADER[o][n.dup?1:0][s?1:0]),De(e,d),Ie(e,Od(a)),e.write(a),o>0&&Ie(e,c),g?.write(),qe("publish: payload: %o",u),e.write(u)}function Gm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.cmd||"puback",s=n.messageId,a=n.dup&&o==="pubrel"?j.DUP_MASK:0,u=0,c=n.reasonCode,h=n.properties,d=i===5?3:2;if(o==="pubrel"&&(u=1),typeof s!="number")return e.destroy(new Error("Invalid messageId")),!1;let g=null;if(i===5&&typeof h=="object"){if(g=Si(e,h,r,d),!g)return !1;d+=g.length;}return e.write(j.ACKS[o][u][a][0]),d===3&&(d+=c!==0?1:-1),De(e,d),Ie(e,s),i===5&&d!==2&&e.write(q.from([c])),g!==null?g.write():d===4&&e.write(q.from([0])),!0}function Qm(t,e,r){qe("subscribe: packet: ");let i=r?r.protocolVersion:4,n=t||{},o=n.dup?j.DUP_MASK:0,s=n.messageId,a=n.subscriptions,u=n.properties,c=0;if(typeof s!="number")return e.destroy(new Error("Invalid messageId")),!1;c+=2;let h=null;if(i===5){if(h=Wt(e,u),!h)return !1;c+=h.length;}if(typeof a=="object"&&a.length)for(let g=0;g<a.length;g+=1){let y=a[g].topic,w=a[g].qos;if(typeof y!="string")return e.destroy(new Error("Invalid subscriptions - invalid topic")),!1;if(typeof w!="number")return e.destroy(new Error("Invalid subscriptions - invalid qos")),!1;if(i===5){if(typeof(a[g].nl||!1)!="boolean")return e.destroy(new Error("Invalid subscriptions - invalid No Local")),!1;if(typeof(a[g].rap||!1)!="boolean")return e.destroy(new Error("Invalid subscriptions - invalid Retain as Published")),!1;let I=a[g].rh||0;if(typeof I!="number"||I>2)return e.destroy(new Error("Invalid subscriptions - invalid Retain Handling")),!1}c+=q.byteLength(y)+2+1;}else return e.destroy(new Error("Invalid subscriptions")),!1;qe("subscribe: writing to stream: %o",j.SUBSCRIBE_HEADER),e.write(j.SUBSCRIBE_HEADER[1][o?1:0][0]),De(e,c),Ie(e,s),h!==null&&h.write();let d=!0;for(let g of a){let y=g.topic,w=g.qos,E=+g.nl,S=+g.rap,I=g.rh,B;yr(e,y),B=j.SUBSCRIBE_OPTIONS_QOS[w],i===5&&(B|=E?j.SUBSCRIBE_OPTIONS_NL:0,B|=S?j.SUBSCRIBE_OPTIONS_RAP:0,B|=I?j.SUBSCRIBE_OPTIONS_RH[I]:0),d=e.write(q.from([B]));}return d}function Ym(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.granted,a=n.properties,u=0;if(typeof o!="number")return e.destroy(new Error("Invalid messageId")),!1;if(u+=2,typeof s=="object"&&s.length)for(let h=0;h<s.length;h+=1){if(typeof s[h]!="number")return e.destroy(new Error("Invalid qos vector")),!1;u+=1;}else return e.destroy(new Error("Invalid qos vector")),!1;let c=null;if(i===5){if(c=Si(e,a,r,u),!c)return !1;u+=c.length;}return e.write(j.SUBACK_HEADER),De(e,u),Ie(e,o),c!==null&&c.write(),e.write(q.from(s))}function Jm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.dup?j.DUP_MASK:0,a=n.unsubscriptions,u=n.properties,c=0;if(typeof o!="number")return e.destroy(new Error("Invalid messageId")),!1;if(c+=2,typeof a=="object"&&a.length)for(let g=0;g<a.length;g+=1){if(typeof a[g]!="string")return e.destroy(new Error("Invalid unsubscriptions")),!1;c+=q.byteLength(a[g])+2;}else return e.destroy(new Error("Invalid unsubscriptions")),!1;let h=null;if(i===5){if(h=Wt(e,u),!h)return !1;c+=h.length;}e.write(j.UNSUBSCRIBE_HEADER[1][s?1:0][0]),De(e,c),Ie(e,o),h!==null&&h.write();let d=!0;for(let g=0;g<a.length;g++)d=yr(e,a[g]);return d}function Xm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.dup?j.DUP_MASK:0,a=n.granted,u=n.properties,c=n.cmd,h=0,d=2;if(typeof o!="number")return e.destroy(new Error("Invalid messageId")),!1;if(i===5)if(typeof a=="object"&&a.length)for(let y=0;y<a.length;y+=1){if(typeof a[y]!="number")return e.destroy(new Error("Invalid qos vector")),!1;d+=1;}else return e.destroy(new Error("Invalid qos vector")),!1;let g=null;if(i===5){if(g=Si(e,u,r,d),!g)return !1;d+=g.length;}return e.write(j.ACKS[c][h][s][0]),De(e,d),Ie(e,o),g!==null&&g.write(),i===5&&e.write(q.from(a)),!0}function Zm(t,e,r){return e.write(j.EMPTY[t.cmd])}function e1(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.reasonCode,s=n.properties,a=i===5?1:0,u=null;if(i===5){if(u=Si(e,s,r,a),!u)return !1;a+=u.length;}return e.write(q.from([j.codes.disconnect<<4])),De(e,a),i===5&&e.write(q.from([o])),u!==null&&u.write(),!0}function t1(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.reasonCode,s=n.properties,a=i===5?1:0;i!==5&&e.destroy(new Error("Invalid mqtt version for auth packet"));let u=Si(e,s,r,a);return u?(a+=u.length,e.write(q.from([j.codes.auth<<4])),De(e,a),e.write(q.from([o])),u!==null&&u.write(),!0):!1}var Td={};function De(t,e){if(e>j.VARBYTEINT_MAX)return t.destroy(new Error(`Invalid variable byte integer: ${e}`)),!1;let r=Td[e];return r||(r=Vo(e),e<16384&&(Td[e]=r)),qe("writeVarByteInt: writing to stream: %o",r),t.write(r)}function yr(t,e){let r=q.byteLength(e);return Ie(t,r),qe("writeString: %s",e),t.write(e,"utf8")}function Rd(t,e,r){yr(t,e),yr(t,r);}function zo(t,e){return qe("writeNumberCached: number: %d",e),qe("writeNumberCached: %o",Cn[e]),t.write(Cn[e])}function r1(t,e){let r=Fm(e);return qe("writeNumberGenerated: %o",r),t.write(r)}function i1(t,e){let r=$m(e);return qe("write4ByteNumber: %o",r),t.write(r)}function Gr(t,e){typeof e=="string"?yr(t,e):e?(Ie(t,e.length),t.write(e)):Ie(t,0);}function Wt(t,e){if(typeof e!="object"||e.length!=null)return {length:1,write(){Bd(t,{},0);}};let r=0;function i(o,s){let a=j.propertiesTypes[o],u=0;switch(a){case"byte":{if(typeof s!="boolean")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+1;break}case"int8":{if(typeof s!="number"||s<0||s>255)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+1;break}case"binary":{if(s&&s===null)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+q.byteLength(s)+2;break}case"int16":{if(typeof s!="number"||s<0||s>65535)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+2;break}case"int32":{if(typeof s!="number"||s<0||s>4294967295)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+4;break}case"var":{if(typeof s!="number"||s<0||s>268435455)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+q.byteLength(Vo(s));break}case"string":{if(typeof s!="string")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+2+q.byteLength(s.toString());break}case"pair":{if(typeof s!="object")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=Object.getOwnPropertyNames(s).reduce((c,h)=>{let d=s[h];return Array.isArray(d)?c+=d.reduce((g,y)=>(g+=1+2+q.byteLength(h.toString())+2+q.byteLength(y.toString()),g),0):c+=1+2+q.byteLength(h.toString())+2+q.byteLength(s[h].toString()),c},0);break}default:return t.destroy(new Error(`Invalid property ${o}: ${s}`)),!1}return u}if(e)for(let o in e){let s=0,a=0,u=e[o];if(Array.isArray(u))for(let c=0;c<u.length;c++){if(a=i(o,u[c]),!a)return !1;s+=a;}else {if(a=i(o,u),!a)return !1;s=a;}if(!s)return !1;r+=s;}return {length:q.byteLength(Vo(r))+r,write(){Bd(t,e,r);}}}function Si(t,e,r,i){let n=["reasonString","userProperties"],o=r&&r.properties&&r.properties.maximumPacketSize?r.properties.maximumPacketSize:0,s=Wt(t,e);if(o)for(;i+s.length>o;){let a=n.shift();if(a&&e[a])delete e[a],s=Wt(t,e);else return !1}return s}function Cd(t,e,r){switch(j.propertiesTypes[e]){case"byte":{t.write(q.from([j.properties[e]])),t.write(q.from([+r]));break}case"int8":{t.write(q.from([j.properties[e]])),t.write(q.from([r]));break}case"binary":{t.write(q.from([j.properties[e]])),Gr(t,r);break}case"int16":{t.write(q.from([j.properties[e]])),Ie(t,r);break}case"int32":{t.write(q.from([j.properties[e]])),i1(t,r);break}case"var":{t.write(q.from([j.properties[e]])),De(t,r);break}case"string":{t.write(q.from([j.properties[e]])),yr(t,r);break}case"pair":{Object.getOwnPropertyNames(r).forEach(n=>{let o=r[n];Array.isArray(o)?o.forEach(s=>{t.write(q.from([j.properties[e]])),Rd(t,n.toString(),s.toString());}):(t.write(q.from([j.properties[e]])),Rd(t,n.toString(),o.toString()));});break}default:return t.destroy(new Error(`Invalid property ${e} value: ${r}`)),!1}}function Bd(t,e,r){De(t,r);for(let i in e)if(Object.prototype.hasOwnProperty.call(e,i)&&e[i]!==null){let n=e[i];if(Array.isArray(n))for(let o=0;o<n.length;o++)Cd(t,i,n[o]);else Cd(t,i,n);}}function Od(t){return t?t instanceof q?t.length:q.byteLength(t):0}function Pd(t){return typeof t=="string"||t instanceof q}xd.exports=kd;});var Ud=M((Ek,Ld)=>{v();m();_();var n1=Ko(),{EventEmitter:s1}=(ir(),X(rr)),{Buffer:Md}=(ye(),X(_e));function o1(t,e){let r=new Go;return n1(t,r,e),r.concat()}var Go=class extends s1{constructor(){super(),this._array=new Array(20),this._i=0;}write(e){return this._array[this._i++]=e,!0}concat(){let e=0,r=new Array(this._array.length),i=this._array,n=0,o;for(o=0;o<i.length&&i[o]!==void 0;o++)typeof i[o]!="string"?r[o]=i[o].length:r[o]=Md.byteLength(i[o]),e+=r[o];let s=Md.allocUnsafe(e);for(o=0;o<i.length&&i[o]!==void 0;o++)typeof i[o]!="string"?(i[o].copy(s,n),n+=r[o]):(s.write(i[o],n),n+=r[o]);return s}destroy(e){e&&this.emit("error",e);}};Ld.exports=o1;});var Nd=M(Pn=>{v();m();_();Pn.parser=md().parser;Pn.generate=Ud();Pn.writeToStream=Ko();});var Jo=M(Yo=>{v();m();_();Object.defineProperty(Yo,"__esModule",{value:!0});var Qo=class{constructor(){this.nextId=Math.max(1,Math.floor(Math.random()*65535));}allocate(){let e=this.nextId++;return this.nextId===65536&&(this.nextId=1),e}getLastAllocated(){return this.nextId===1?65535:this.nextId-1}register(e){return !0}deallocate(e){}clear(){}};Yo.default=Qo;});var Dd=M((Xk,qd)=>{v();m();_();qd.exports=a1;function Qr(t){return t instanceof x?x.from(t):new t.constructor(t.buffer.slice(),t.byteOffset,t.length)}function a1(t){if(t=t||{},t.circles)return l1(t);return t.proto?i:r;function e(n,o){for(var s=Object.keys(n),a=new Array(s.length),u=0;u<s.length;u++){var c=s[u],h=n[c];typeof h!="object"||h===null?a[c]=h:h instanceof Date?a[c]=new Date(h):ArrayBuffer.isView(h)?a[c]=Qr(h):a[c]=o(h);}return a}function r(n){if(typeof n!="object"||n===null)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return e(n,r);if(n instanceof Map)return new Map(e(Array.from(n),r));if(n instanceof Set)return new Set(e(Array.from(n),r));var o={};for(var s in n)if(Object.hasOwnProperty.call(n,s)!==!1){var a=n[s];typeof a!="object"||a===null?o[s]=a:a instanceof Date?o[s]=new Date(a):a instanceof Map?o[s]=new Map(e(Array.from(a),r)):a instanceof Set?o[s]=new Set(e(Array.from(a),r)):ArrayBuffer.isView(a)?o[s]=Qr(a):o[s]=r(a);}return o}function i(n){if(typeof n!="object"||n===null)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return e(n,i);if(n instanceof Map)return new Map(e(Array.from(n),i));if(n instanceof Set)return new Set(e(Array.from(n),i));var o={};for(var s in n){var a=n[s];typeof a!="object"||a===null?o[s]=a:a instanceof Date?o[s]=new Date(a):a instanceof Map?o[s]=new Map(e(Array.from(a),i)):a instanceof Set?o[s]=new Set(e(Array.from(a),i)):ArrayBuffer.isView(a)?o[s]=Qr(a):o[s]=i(a);}return o}}function l1(t){var e=[],r=[];return t.proto?o:n;function i(s,a){for(var u=Object.keys(s),c=new Array(u.length),h=0;h<u.length;h++){var d=u[h],g=s[d];if(typeof g!="object"||g===null)c[d]=g;else if(g instanceof Date)c[d]=new Date(g);else if(ArrayBuffer.isView(g))c[d]=Qr(g);else {var y=e.indexOf(g);y!==-1?c[d]=r[y]:c[d]=a(g);}}return c}function n(s){if(typeof s!="object"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,n);if(s instanceof Map)return new Map(i(Array.from(s),n));if(s instanceof Set)return new Set(i(Array.from(s),n));var a={};e.push(s),r.push(a);for(var u in s)if(Object.hasOwnProperty.call(s,u)!==!1){var c=s[u];if(typeof c!="object"||c===null)a[u]=c;else if(c instanceof Date)a[u]=new Date(c);else if(c instanceof Map)a[u]=new Map(i(Array.from(c),n));else if(c instanceof Set)a[u]=new Set(i(Array.from(c),n));else if(ArrayBuffer.isView(c))a[u]=Qr(c);else {var h=e.indexOf(c);h!==-1?a[u]=r[h]:a[u]=n(c);}}return e.pop(),r.pop(),a}function o(s){if(typeof s!="object"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,o);if(s instanceof Map)return new Map(i(Array.from(s),o));if(s instanceof Set)return new Set(i(Array.from(s),o));var a={};e.push(s),r.push(a);for(var u in s){var c=s[u];if(typeof c!="object"||c===null)a[u]=c;else if(c instanceof Date)a[u]=new Date(c);else if(c instanceof Map)a[u]=new Map(i(Array.from(c),o));else if(c instanceof Set)a[u]=new Set(i(Array.from(c),o));else if(ArrayBuffer.isView(c))a[u]=Qr(c);else {var h=e.indexOf(c);h!==-1?a[u]=r[h]:a[u]=o(c);}}return e.pop(),r.pop(),a}}});var Fd=M((lO,jd)=>{v();m();_();jd.exports=Dd()();});var $d=M(Yr=>{v();m();_();Object.defineProperty(Yr,"__esModule",{value:!0});Yr.validateTopics=Yr.validateTopic=void 0;function Wd(t){let e=t.split("/");for(let r=0;r<e.length;r++)if(e[r]!=="+"){if(e[r]==="#")return r===e.length-1;if(e[r].indexOf("+")!==-1||e[r].indexOf("#")!==-1)return !1}return !0}Yr.validateTopic=Wd;function u1(t){if(t.length===0)return "empty_topic_list";for(let e=0;e<t.length;e++)if(!Wd(t[e]))return t[e];return null}Yr.validateTopics=u1;});var ea=M(Zo=>{v();m();_();Object.defineProperty(Zo,"__esModule",{value:!0});var f1=jt(),c1={objectMode:!0},h1={clean:!0},Xo=class{constructor(e){this.options=e||{},this.options=Object.assign(Object.assign({},h1),e),this._inflights=new Map;}put(e,r){return this._inflights.set(e.messageId,e),r&&r(),this}createStream(){let e=new f1.Readable(c1),r=[],i=!1,n=0;return this._inflights.forEach((o,s)=>{r.push(o);}),e._read=()=>{!i&&n<r.length?e.push(r[n++]):e.push(null);},e.destroy=o=>{if(!i)return i=!0,setTimeout(()=>{e.emit("close");},0),e},e}del(e,r){let i=this._inflights.get(e.messageId);return i?(this._inflights.delete(e.messageId),r(null,i)):r&&r(new Error("missing packet")),this}get(e,r){let i=this._inflights.get(e.messageId);return i?r(null,i):r&&r(new Error("missing packet")),this}close(e){this.options.clean&&(this._inflights=null),e&&e();}};Zo.default=Xo;});var Vd=M(ta=>{v();m();_();Object.defineProperty(ta,"__esModule",{value:!0});var Hd=[0,16,128,131,135,144,145,151,153],d1=(t,e,r)=>{t.log("handlePublish: packet %o",e),r=typeof r<"u"?r:t.noop;let i=e.topic.toString(),n=e.payload,{qos:o}=e,{messageId:s}=e,{options:a}=t;if(t.options.protocolVersion===5){let u;if(e.properties&&(u=e.properties.topicAlias),typeof u<"u")if(i.length===0)if(u>0&&u<=65535){let c=t.topicAliasRecv.getTopicByAlias(u);if(c)i=c,t.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d",i,u);else {t.log("handlePublish :: unregistered topic alias. alias: %d",u),t.emit("error",new Error("Received unregistered Topic Alias"));return}}else {t.log("handlePublish :: topic alias out of range. alias: %d",u),t.emit("error",new Error("Received Topic Alias is out of range"));return}else if(t.topicAliasRecv.put(i,u))t.log("handlePublish :: registered topic: %s - alias: %d",i,u);else {t.log("handlePublish :: topic alias out of range. alias: %d",u),t.emit("error",new Error("Received Topic Alias is out of range"));return}}switch(t.log("handlePublish: qos %d",o),o){case 2:{a.customHandleAcks(i,n,e,(u,c)=>{if(typeof u=="number"&&(c=u,u=null),u)return t.emit("error",u);if(Hd.indexOf(c)===-1)return t.emit("error",new Error("Wrong reason code for pubrec"));c?t._sendPacket({cmd:"pubrec",messageId:s,reasonCode:c},r):t.incomingStore.put(e,()=>{t._sendPacket({cmd:"pubrec",messageId:s},r);});});break}case 1:{a.customHandleAcks(i,n,e,(u,c)=>{if(typeof u=="number"&&(c=u,u=null),u)return t.emit("error",u);if(Hd.indexOf(c)===-1)return t.emit("error",new Error("Wrong reason code for puback"));c||t.emit("message",i,n,e),t.handleMessage(e,h=>{if(h)return r&&r(h);t._sendPacket({cmd:"puback",messageId:s,reasonCode:c},r);});});break}case 0:t.emit("message",i,n,e),t.handleMessage(e,r);break;default:t.log("handlePublish: unknown QoS. Doing nothing.");break}};ta.default=d1;});var zd=M((GO,p1)=>{p1.exports={version:"5.7.0"};});var Jr=M(at=>{v();m();_();Object.defineProperty(at,"__esModule",{value:!0});at.MQTTJS_VERSION=at.nextTick=at.applyMixin=at.ErrorWithReasonCode=void 0;var ra=class t extends Error{constructor(e,r){super(e),this.code=r,Object.setPrototypeOf(this,t.prototype),Object.getPrototypeOf(this).name="ErrorWithReasonCode";}};at.ErrorWithReasonCode=ra;function g1(t,e,r=!1){var i;let n=[e];for(;;){let o=n[0],s=Object.getPrototypeOf(o);if(s?.prototype)n.unshift(s);else break}for(let o of n)for(let s of Object.getOwnPropertyNames(o.prototype))(r||s!=="constructor")&&Object.defineProperty(t.prototype,s,(i=Object.getOwnPropertyDescriptor(o.prototype,s))!==null&&i!==void 0?i:Object.create(null));}at.applyMixin=g1;at.nextTick=typeof(C===null||C===void 0?void 0:C.nextTick)=="function"?C.nextTick:t=>{setTimeout(t,0);};at.MQTTJS_VERSION=zd().version;});var Ai=M(br=>{v();m();_();Object.defineProperty(br,"__esModule",{value:!0});br.ReasonCodes=void 0;br.ReasonCodes={0:"",1:"Unacceptable protocol version",2:"Identifier rejected",3:"Server unavailable",4:"Bad username or password",5:"Not authorized",16:"No matching subscribers",17:"No subscription existed",128:"Unspecified error",129:"Malformed Packet",130:"Protocol Error",131:"Implementation specific error",132:"Unsupported Protocol Version",133:"Client Identifier not valid",134:"Bad User Name or Password",135:"Not authorized",136:"Server unavailable",137:"Server busy",138:"Banned",139:"Server shutting down",140:"Bad authentication method",141:"Keep Alive timeout",142:"Session taken over",143:"Topic Filter invalid",144:"Topic Name invalid",145:"Packet identifier in use",146:"Packet Identifier not found",147:"Receive Maximum exceeded",148:"Topic Alias invalid",149:"Packet too large",150:"Message rate too high",151:"Quota exceeded",152:"Administrative action",153:"Payload format invalid",154:"Retain not supported",155:"QoS not supported",156:"Use another server",157:"Server moved",158:"Shared Subscriptions not supported",159:"Connection rate exceeded",160:"Maximum connect time",161:"Subscription Identifiers not supported",162:"Wildcard Subscriptions not supported"};var y1=(t,e)=>{let{messageId:r}=e,i=e.cmd,n=null,o=t.outgoing[r]?t.outgoing[r].cb:null,s;if(!o){t.log("_handleAck :: Server sent an ack in error. Ignoring.");return}switch(t.log("_handleAck :: packet type",i),i){case"pubcomp":case"puback":{let a=e.reasonCode;a&&a>0&&a!==16?(s=new Error(`Publish error: ${br.ReasonCodes[a]}`),s.code=a,t._removeOutgoingAndStoreMessage(r,()=>{o(s,e);})):t._removeOutgoingAndStoreMessage(r,o);break}case"pubrec":{n={cmd:"pubrel",qos:2,messageId:r};let a=e.reasonCode;a&&a>0&&a!==16?(s=new Error(`Publish error: ${br.ReasonCodes[a]}`),s.code=a,t._removeOutgoingAndStoreMessage(r,()=>{o(s,e);})):t._sendPacket(n);break}case"suback":{delete t.outgoing[r],t.messageIdProvider.deallocate(r);let a=e.granted;for(let u=0;u<a.length;u++)if(a[u]&128){let c=t.messageIdToTopic[r];c&&c.forEach(h=>{delete t._resubscribeTopics[h];});}delete t.messageIdToTopic[r],t._invokeStoreProcessingQueue(),o(null,e);break}case"unsuback":{delete t.outgoing[r],t.messageIdProvider.deallocate(r),t._invokeStoreProcessingQueue(),o(null);break}default:t.emit("error",new Error("unrecognized packet type"));}t.disconnecting&&Object.keys(t.outgoing).length===0&&t.emit("outgoingEmpty");};br.default=y1;});var Gd=M(ia=>{v();m();_();Object.defineProperty(ia,"__esModule",{value:!0});var Kd=Jr(),b1=Ai(),w1=(t,e)=>{let{options:r}=t,i=r.protocolVersion,n=i===5?e.reasonCode:e.returnCode;if(i!==5){let o=new Kd.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${i}`,n);t.emit("error",o);return}t.handleAuth(e,(o,s)=>{if(o){t.emit("error",o);return}if(n===24)t.reconnecting=!1,t._sendPacket(s);else {let a=new Kd.ErrorWithReasonCode(`Connection refused: ${b1.ReasonCodes[n]}`,n);t.emit("error",a);}});};ia.default=w1;});var Zd=M(On=>{v();m();_();Object.defineProperty(On,"__esModule",{value:!0});On.LRUCache=void 0;var Ii=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Yd=new Set,na=typeof C=="object"&&C?C:{},Jd=(t,e,r,i)=>{typeof na.emitWarning=="function"?na.emitWarning(t,e,r,i):console.error(`[${r}] ${e}: ${t}`);},kn=globalThis.AbortController,Qd=globalThis.AbortSignal;if(typeof kn>"u"){Qd=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,n){this._onabort.push(n);}},kn=class{constructor(){e();}signal=new Qd;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(let n of this.signal._onabort)n(i);this.signal.onabort?.(i);}}};let t=na.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",e=()=>{t&&(t=!1,Jd("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e));};}var _1=t=>!Yd.has(t),$t=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),Xd=t=>$t(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?Xr:null:null,Xr=class extends Array{constructor(e){super(e),this.fill(0);}},sa=class t{heap;length;static#l=!1;static create(e){let r=Xd(e);if(!r)return [];t.#l=!0;let i=new t(e,r);return t.#l=!1,i}constructor(e,r){if(!t.#l)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new r(e),this.length=0;}push(e){this.heap[this.length++]=e;}pop(){return this.heap[--this.length]}},oa=class t{#l;#c;#p;#g;#B;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#i;#y;#n;#r;#e;#u;#h;#a;#s;#b;#o;#E;#S;#w;#_;#I;#f;static unsafeExposeInternals(e){return {starts:e.#S,ttls:e.#w,sizes:e.#E,keyMap:e.#n,keyList:e.#r,valList:e.#e,next:e.#u,prev:e.#h,get head(){return e.#a},get tail(){return e.#s},free:e.#b,isBackgroundFetch:r=>e.#t(r),backgroundFetch:(r,i,n,o)=>e.#O(r,i,n,o),moveToTail:r=>e.#C(r),indexes:r=>e.#m(r),rindexes:r=>e.#v(r),isStale:r=>e.#d(r)}}get max(){return this.#l}get maxSize(){return this.#c}get calculatedSize(){return this.#y}get size(){return this.#i}get fetchMethod(){return this.#B}get dispose(){return this.#p}get disposeAfter(){return this.#g}constructor(e){let{max:r=0,ttl:i,ttlResolution:n=1,ttlAutopurge:o,updateAgeOnGet:s,updateAgeOnHas:a,allowStale:u,dispose:c,disposeAfter:h,noDisposeOnSet:d,noUpdateTTL:g,maxSize:y=0,maxEntrySize:w=0,sizeCalculation:E,fetchMethod:S,noDeleteOnFetchRejection:I,noDeleteOnStaleGet:B,allowStaleOnFetchRejection:R,allowStaleOnFetchAbort:U,ignoreFetchAbort:N}=e;if(r!==0&&!$t(r))throw new TypeError("max option must be a nonnegative integer");let W=r?Xd(r):Array;if(!W)throw new Error("invalid max value: "+r);if(this.#l=r,this.#c=y,this.maxEntrySize=w||this.#c,this.sizeCalculation=E,this.sizeCalculation){if(!this.#c&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(S!==void 0&&typeof S!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#B=S,this.#I=!!S,this.#n=new Map,this.#r=new Array(r).fill(void 0),this.#e=new Array(r).fill(void 0),this.#u=new W(r),this.#h=new W(r),this.#a=0,this.#s=0,this.#b=sa.create(r),this.#i=0,this.#y=0,typeof c=="function"&&(this.#p=c),typeof h=="function"?(this.#g=h,this.#o=[]):(this.#g=void 0,this.#o=void 0),this.#_=!!this.#p,this.#f=!!this.#g,this.noDisposeOnSet=!!d,this.noUpdateTTL=!!g,this.noDeleteOnFetchRejection=!!I,this.allowStaleOnFetchRejection=!!R,this.allowStaleOnFetchAbort=!!U,this.ignoreFetchAbort=!!N,this.maxEntrySize!==0){if(this.#c!==0&&!$t(this.#c))throw new TypeError("maxSize must be a positive integer if specified");if(!$t(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#q();}if(this.allowStale=!!u,this.noDeleteOnStaleGet=!!B,this.updateAgeOnGet=!!s,this.updateAgeOnHas=!!a,this.ttlResolution=$t(n)||n===0?n:1,this.ttlAutopurge=!!o,this.ttl=i||0,this.ttl){if(!$t(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#x();}if(this.#l===0&&this.ttl===0&&this.#c===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#l&&!this.#c){let K="LRU_CACHE_UNBOUNDED";_1(K)&&(Yd.add(K),Jd("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",K,t));}}getRemainingTTL(e){return this.#n.has(e)?1/0:0}#x(){let e=new Xr(this.#l),r=new Xr(this.#l);this.#w=e,this.#S=r,this.#M=(o,s,a=Ii.now())=>{if(r[o]=s!==0?a:0,e[o]=s,s!==0&&this.ttlAutopurge){let u=setTimeout(()=>{this.#d(o)&&this.delete(this.#r[o]);},s+1);u.unref&&u.unref();}},this.#T=o=>{r[o]=e[o]!==0?Ii.now():0;},this.#A=(o,s)=>{if(e[s]){let a=e[s],u=r[s];o.ttl=a,o.start=u,o.now=i||n();let c=o.now-u;o.remainingTTL=a-c;}};let i=0,n=()=>{let o=Ii.now();if(this.ttlResolution>0){i=o;let s=setTimeout(()=>i=0,this.ttlResolution);s.unref&&s.unref();}return o};this.getRemainingTTL=o=>{let s=this.#n.get(o);if(s===void 0)return 0;let a=e[s],u=r[s];if(a===0||u===0)return 1/0;let c=(i||n())-u;return a-c},this.#d=o=>e[o]!==0&&r[o]!==0&&(i||n())-r[o]>e[o];}#T=()=>{};#A=()=>{};#M=()=>{};#d=()=>!1;#q(){let e=new Xr(this.#l);this.#y=0,this.#E=e,this.#R=r=>{this.#y-=e[r],e[r]=0;},this.#L=(r,i,n,o)=>{if(this.#t(i))return 0;if(!$t(n))if(o){if(typeof o!="function")throw new TypeError("sizeCalculation must be a function");if(n=o(i,r),!$t(n))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return n},this.#P=(r,i,n)=>{if(e[r]=i,this.#c){let o=this.#c-e[r];for(;this.#y>o;)this.#k(!0);}this.#y+=e[r],n&&(n.entrySize=i,n.totalCalculatedSize=this.#y);};}#R=e=>{};#P=(e,r,i)=>{};#L=(e,r,i,n)=>{if(i||n)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#m({allowStale:e=this.allowStale}={}){if(this.#i)for(let r=this.#s;!(!this.#U(r)||((e||!this.#d(r))&&(yield r),r===this.#a));)r=this.#h[r];}*#v({allowStale:e=this.allowStale}={}){if(this.#i)for(let r=this.#a;!(!this.#U(r)||((e||!this.#d(r))&&(yield r),r===this.#s));)r=this.#u[r];}#U(e){return e!==void 0&&this.#n.get(this.#r[e])===e}*entries(){for(let e of this.#m())this.#e[e]!==void 0&&this.#r[e]!==void 0&&!this.#t(this.#e[e])&&(yield [this.#r[e],this.#e[e]]);}*rentries(){for(let e of this.#v())this.#e[e]!==void 0&&this.#r[e]!==void 0&&!this.#t(this.#e[e])&&(yield [this.#r[e],this.#e[e]]);}*keys(){for(let e of this.#m()){let r=this.#r[e];r!==void 0&&!this.#t(this.#e[e])&&(yield r);}}*rkeys(){for(let e of this.#v()){let r=this.#r[e];r!==void 0&&!this.#t(this.#e[e])&&(yield r);}}*values(){for(let e of this.#m())this.#e[e]!==void 0&&!this.#t(this.#e[e])&&(yield this.#e[e]);}*rvalues(){for(let e of this.#v())this.#e[e]!==void 0&&!this.#t(this.#e[e])&&(yield this.#e[e]);}[Symbol.iterator](){return this.entries()}find(e,r={}){for(let i of this.#m()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;if(o!==void 0&&e(o,this.#r[i],this))return this.get(this.#r[i],r)}}forEach(e,r=this){for(let i of this.#m()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;o!==void 0&&e.call(r,o,this.#r[i],this);}}rforEach(e,r=this){for(let i of this.#v()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;o!==void 0&&e.call(r,o,this.#r[i],this);}}purgeStale(){let e=!1;for(let r of this.#v({allowStale:!0}))this.#d(r)&&(this.delete(this.#r[r]),e=!0);return e}dump(){let e=[];for(let r of this.#m({allowStale:!0})){let i=this.#r[r],n=this.#e[r],o=this.#t(n)?n.__staleWhileFetching:n;if(o===void 0||i===void 0)continue;let s={value:o};if(this.#w&&this.#S){s.ttl=this.#w[r];let a=Ii.now()-this.#S[r];s.start=Math.floor(Date.now()-a);}this.#E&&(s.size=this.#E[r]),e.unshift([i,s]);}return e}load(e){this.clear();for(let[r,i]of e){if(i.start){let n=Date.now()-i.start;i.start=Ii.now()-n;}this.set(r,i.value,i);}}set(e,r,i={}){if(r===void 0)return this.delete(e),this;let{ttl:n=this.ttl,start:o,noDisposeOnSet:s=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:u}=i,{noUpdateTTL:c=this.noUpdateTTL}=i,h=this.#L(e,r,i.size||0,a);if(this.maxEntrySize&&h>this.maxEntrySize)return u&&(u.set="miss",u.maxEntrySizeExceeded=!0),this.delete(e),this;let d=this.#i===0?void 0:this.#n.get(e);if(d===void 0)d=this.#i===0?this.#s:this.#b.length!==0?this.#b.pop():this.#i===this.#l?this.#k(!1):this.#i,this.#r[d]=e,this.#e[d]=r,this.#n.set(e,d),this.#u[this.#s]=d,this.#h[d]=this.#s,this.#s=d,this.#i++,this.#P(d,h,u),u&&(u.set="add"),c=!1;else {this.#C(d);let g=this.#e[d];if(r!==g){if(this.#I&&this.#t(g)){g.__abortController.abort(new Error("replaced"));let{__staleWhileFetching:y}=g;y!==void 0&&!s&&(this.#_&&this.#p?.(y,e,"set"),this.#f&&this.#o?.push([y,e,"set"]));}else s||(this.#_&&this.#p?.(g,e,"set"),this.#f&&this.#o?.push([g,e,"set"]));if(this.#R(d),this.#P(d,h,u),this.#e[d]=r,u){u.set="replace";let y=g&&this.#t(g)?g.__staleWhileFetching:g;y!==void 0&&(u.oldValue=y);}}else u&&(u.set="update");}if(n!==0&&!this.#w&&this.#x(),this.#w&&(c||this.#M(d,n,o),u&&this.#A(u,d)),!s&&this.#f&&this.#o){let g=this.#o,y;for(;y=g?.shift();)this.#g?.(...y);}return this}pop(){try{for(;this.#i;){let e=this.#e[this.#a];if(this.#k(!0),this.#t(e)){if(e.__staleWhileFetching)return e.__staleWhileFetching}else if(e!==void 0)return e}}finally{if(this.#f&&this.#o){let e=this.#o,r;for(;r=e?.shift();)this.#g?.(...r);}}}#k(e){let r=this.#a,i=this.#r[r],n=this.#e[r];return this.#I&&this.#t(n)?n.__abortController.abort(new Error("evicted")):(this.#_||this.#f)&&(this.#_&&this.#p?.(n,i,"evict"),this.#f&&this.#o?.push([n,i,"evict"])),this.#R(r),e&&(this.#r[r]=void 0,this.#e[r]=void 0,this.#b.push(r)),this.#i===1?(this.#a=this.#s=0,this.#b.length=0):this.#a=this.#u[r],this.#n.delete(i),this.#i--,r}has(e,r={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:n}=r,o=this.#n.get(e);if(o!==void 0){let s=this.#e[o];if(this.#t(s)&&s.__staleWhileFetching===void 0)return !1;if(this.#d(o))n&&(n.has="stale",this.#A(n,o));else return i&&this.#T(o),n&&(n.has="hit",this.#A(n,o)),!0}else n&&(n.has="miss");return !1}peek(e,r={}){let{allowStale:i=this.allowStale}=r,n=this.#n.get(e);if(n!==void 0&&(i||!this.#d(n))){let o=this.#e[n];return this.#t(o)?o.__staleWhileFetching:o}}#O(e,r,i,n){let o=r===void 0?void 0:this.#e[r];if(this.#t(o))return o;let s=new kn,{signal:a}=i;a?.addEventListener("abort",()=>s.abort(a.reason),{signal:s.signal});let u={signal:s.signal,options:i,context:n},c=(E,S=!1)=>{let{aborted:I}=s.signal,B=i.ignoreFetchAbort&&E!==void 0;if(i.status&&(I&&!S?(i.status.fetchAborted=!0,i.status.fetchError=s.signal.reason,B&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),I&&!B&&!S)return d(s.signal.reason);let R=y;return this.#e[r]===y&&(E===void 0?R.__staleWhileFetching?this.#e[r]=R.__staleWhileFetching:this.delete(e):(i.status&&(i.status.fetchUpdated=!0),this.set(e,E,u.options))),E},h=E=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=E),d(E)),d=E=>{let{aborted:S}=s.signal,I=S&&i.allowStaleOnFetchAbort,B=I||i.allowStaleOnFetchRejection,R=B||i.noDeleteOnFetchRejection,U=y;if(this.#e[r]===y&&(!R||U.__staleWhileFetching===void 0?this.delete(e):I||(this.#e[r]=U.__staleWhileFetching)),B)return i.status&&U.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),U.__staleWhileFetching;if(U.__returned===U)throw E},g=(E,S)=>{let I=this.#B?.(e,o,u);I&&I instanceof Promise&&I.then(B=>E(B===void 0?void 0:B),S),s.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(E(void 0),i.allowStaleOnFetchAbort&&(E=B=>c(B,!0)));});};i.status&&(i.status.fetchDispatched=!0);let y=new Promise(g).then(c,h),w=Object.assign(y,{__abortController:s,__staleWhileFetching:o,__returned:void 0});return r===void 0?(this.set(e,w,{...u.options,status:void 0}),r=this.#n.get(e)):this.#e[r]=w,w}#t(e){if(!this.#I)return !1;let r=e;return !!r&&r instanceof Promise&&r.hasOwnProperty("__staleWhileFetching")&&r.__abortController instanceof kn}async fetch(e,r={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:s=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:u=0,sizeCalculation:c=this.sizeCalculation,noUpdateTTL:h=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:g=this.allowStaleOnFetchRejection,ignoreFetchAbort:y=this.ignoreFetchAbort,allowStaleOnFetchAbort:w=this.allowStaleOnFetchAbort,context:E,forceRefresh:S=!1,status:I,signal:B}=r;if(!this.#I)return I&&(I.fetch="get"),this.get(e,{allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,status:I});let R={allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,ttl:s,noDisposeOnSet:a,size:u,sizeCalculation:c,noUpdateTTL:h,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:g,allowStaleOnFetchAbort:w,ignoreFetchAbort:y,status:I,signal:B},U=this.#n.get(e);if(U===void 0){I&&(I.fetch="miss");let N=this.#O(e,U,R,E);return N.__returned=N}else {let N=this.#e[U];if(this.#t(N)){let de=i&&N.__staleWhileFetching!==void 0;return I&&(I.fetch="inflight",de&&(I.returnedStale=!0)),de?N.__staleWhileFetching:N.__returned=N}let W=this.#d(U);if(!S&&!W)return I&&(I.fetch="hit"),this.#C(U),n&&this.#T(U),I&&this.#A(I,U),N;let K=this.#O(e,U,R,E),Q=K.__staleWhileFetching!==void 0&&i;return I&&(I.fetch=W?"stale":"refresh",Q&&W&&(I.returnedStale=!0)),Q?K.__staleWhileFetching:K.__returned=K}}get(e,r={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:s}=r,a=this.#n.get(e);if(a!==void 0){let u=this.#e[a],c=this.#t(u);return s&&this.#A(s,a),this.#d(a)?(s&&(s.get="stale"),c?(s&&i&&u.__staleWhileFetching!==void 0&&(s.returnedStale=!0),i?u.__staleWhileFetching:void 0):(o||this.delete(e),s&&i&&(s.returnedStale=!0),i?u:void 0)):(s&&(s.get="hit"),c?u.__staleWhileFetching:(this.#C(a),n&&this.#T(a),u))}else s&&(s.get="miss");}#N(e,r){this.#h[r]=e,this.#u[e]=r;}#C(e){e!==this.#s&&(e===this.#a?this.#a=this.#u[e]:this.#N(this.#h[e],this.#u[e]),this.#N(this.#s,e),this.#s=e);}delete(e){let r=!1;if(this.#i!==0){let i=this.#n.get(e);if(i!==void 0)if(r=!0,this.#i===1)this.clear();else {this.#R(i);let n=this.#e[i];this.#t(n)?n.__abortController.abort(new Error("deleted")):(this.#_||this.#f)&&(this.#_&&this.#p?.(n,e,"delete"),this.#f&&this.#o?.push([n,e,"delete"])),this.#n.delete(e),this.#r[i]=void 0,this.#e[i]=void 0,i===this.#s?this.#s=this.#h[i]:i===this.#a?this.#a=this.#u[i]:(this.#u[this.#h[i]]=this.#u[i],this.#h[this.#u[i]]=this.#h[i]),this.#i--,this.#b.push(i);}}if(this.#f&&this.#o?.length){let i=this.#o,n;for(;n=i?.shift();)this.#g?.(...n);}return r}clear(){for(let e of this.#v({allowStale:!0})){let r=this.#e[e];if(this.#t(r))r.__abortController.abort(new Error("deleted"));else {let i=this.#r[e];this.#_&&this.#p?.(r,i,"delete"),this.#f&&this.#o?.push([r,i,"delete"]);}}if(this.#n.clear(),this.#e.fill(void 0),this.#r.fill(void 0),this.#w&&this.#S&&(this.#w.fill(0),this.#S.fill(0)),this.#E&&this.#E.fill(0),this.#a=0,this.#s=0,this.#b.length=0,this.#y=0,this.#i=0,this.#f&&this.#o){let e=this.#o,r;for(;r=e?.shift();)this.#g?.(...r);}}};On.LRUCache=oa;});var lt=M(Ht=>{v();m();_();Object.defineProperty(Ht,"t",{value:!0});Ht.ContainerIterator=Ht.Container=Ht.Base=void 0;var aa=class{constructor(e=0){this.iteratorType=e;}equals(e){return this.o===e.o}};Ht.ContainerIterator=aa;var xn=class{constructor(){this.i=0;}get length(){return this.i}size(){return this.i}empty(){return this.i===0}};Ht.Base=xn;var la=class extends xn{};Ht.Container=la;});var ep=M(Mn=>{v();m();_();Object.defineProperty(Mn,"t",{value:!0});Mn.default=void 0;var m1=lt(),ua=class extends m1.Base{constructor(e=[]){super(),this.S=[];let r=this;e.forEach(function(i){r.push(i);});}clear(){this.i=0,this.S=[];}push(e){return this.S.push(e),this.i+=1,this.i}pop(){if(this.i!==0)return this.i-=1,this.S.pop()}top(){return this.S[this.i-1]}},v1=ua;Mn.default=v1;});var tp=M(Ln=>{v();m();_();Object.defineProperty(Ln,"t",{value:!0});Ln.default=void 0;var E1=lt(),fa=class extends E1.Base{constructor(e=[]){super(),this.j=0,this.q=[];let r=this;e.forEach(function(i){r.push(i);});}clear(){this.q=[],this.i=this.j=0;}push(e){let r=this.q.length;if(this.j/r>.5&&this.j+this.i>=r&&r>4096){let i=this.i;for(let n=0;n<i;++n)this.q[n]=this.q[this.j+n];this.j=0,this.q[this.i]=e;}else this.q[this.j+this.i]=e;return ++this.i}pop(){if(this.i===0)return;let e=this.q[this.j++];return this.i-=1,e}front(){if(this.i!==0)return this.q[this.j]}},S1=fa;Ln.default=S1;});var rp=M(Un=>{v();m();_();Object.defineProperty(Un,"t",{value:!0});Un.default=void 0;var A1=lt(),ca=class extends A1.Base{constructor(e=[],r=function(n,o){return n>o?-1:n<o?1:0},i=!0){if(super(),this.v=r,Array.isArray(e))this.C=i?[...e]:e;else {this.C=[];let o=this;e.forEach(function(s){o.C.push(s);});}this.i=this.C.length;let n=this.i>>1;for(let o=this.i-1>>1;o>=0;--o)this.k(o,n);}m(e){let r=this.C[e];for(;e>0;){let i=e-1>>1,n=this.C[i];if(this.v(n,r)<=0)break;this.C[e]=n,e=i;}this.C[e]=r;}k(e,r){let i=this.C[e];for(;e<r;){let n=e<<1|1,o=n+1,s=this.C[n];if(o<this.i&&this.v(s,this.C[o])>0&&(n=o,s=this.C[o]),this.v(s,i)>=0)break;this.C[e]=s,e=n;}this.C[e]=i;}clear(){this.i=0,this.C.length=0;}push(e){this.C.push(e),this.m(this.i),this.i+=1;}pop(){if(this.i===0)return;let e=this.C[0],r=this.C.pop();return this.i-=1,this.i&&(this.C[0]=r,this.k(0,this.i>>1)),e}top(){return this.C[0]}find(e){return this.C.indexOf(e)>=0}remove(e){let r=this.C.indexOf(e);return r<0?!1:(r===0?this.pop():r===this.i-1?(this.C.pop(),this.i-=1):(this.C.splice(r,1,this.C.pop()),this.i-=1,this.m(r),this.k(r,this.i>>1)),!0)}updateItem(e){let r=this.C.indexOf(e);return r<0?!1:(this.m(r),this.k(r,this.i>>1),!0)}toArray(){return [...this.C]}},I1=ca;Un.default=I1;});var qn=M(Nn=>{v();m();_();Object.defineProperty(Nn,"t",{value:!0});Nn.default=void 0;var T1=lt(),ha=class extends T1.Container{},R1=ha;Nn.default=R1;});var ut=M(da=>{v();m();_();Object.defineProperty(da,"t",{value:!0});da.throwIteratorAccessError=C1;function C1(){throw new RangeError("Iterator access denied!")}});var ga=M(jn=>{v();m();_();Object.defineProperty(jn,"t",{value:!0});jn.RandomIterator=void 0;var B1=lt(),Dn=ut(),pa=class extends B1.ContainerIterator{constructor(e,r){super(r),this.o=e,this.iteratorType===0?(this.pre=function(){return this.o===0&&(0, Dn.throwIteratorAccessError)(),this.o-=1,this},this.next=function(){return this.o===this.container.size()&&(0, Dn.throwIteratorAccessError)(),this.o+=1,this}):(this.pre=function(){return this.o===this.container.size()-1&&(0, Dn.throwIteratorAccessError)(),this.o+=1,this},this.next=function(){return this.o===-1&&(0, Dn.throwIteratorAccessError)(),this.o-=1,this});}get pointer(){return this.container.getElementByPos(this.o)}set pointer(e){this.container.setElementByPos(this.o,e);}};jn.RandomIterator=pa;});var ip=M(Fn=>{v();m();_();Object.defineProperty(Fn,"t",{value:!0});Fn.default=void 0;var P1=O1(qn()),k1=ga();function O1(t){return t&&t.t?t:{default:t}}var wr=class t extends k1.RandomIterator{constructor(e,r,i){super(e,i),this.container=r;}copy(){return new t(this.o,this.container,this.iteratorType)}},ya=class extends P1.default{constructor(e=[],r=!0){if(super(),Array.isArray(e))this.J=r?[...e]:e,this.i=e.length;else {this.J=[];let i=this;e.forEach(function(n){i.pushBack(n);});}}clear(){this.i=0,this.J.length=0;}begin(){return new wr(0,this)}end(){return new wr(this.i,this)}rBegin(){return new wr(this.i-1,this,1)}rEnd(){return new wr(-1,this,1)}front(){return this.J[0]}back(){return this.J[this.i-1]}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J[e]}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J.splice(e,1),this.i-=1,this.i}eraseElementByValue(e){let r=0;for(let i=0;i<this.i;++i)this.J[i]!==e&&(this.J[r++]=this.J[i]);return this.i=this.J.length=r,this.i}eraseElementByIterator(e){let r=e.o;return e=e.next(),this.eraseElementByPos(r),e}pushBack(e){return this.J.push(e),this.i+=1,this.i}popBack(){if(this.i!==0)return this.i-=1,this.J.pop()}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;this.J[e]=r;}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;return this.J.splice(e,0,...new Array(i).fill(r)),this.i+=i,this.i}find(e){for(let r=0;r<this.i;++r)if(this.J[r]===e)return new wr(r,this);return this.end()}reverse(){this.J.reverse();}unique(){let e=1;for(let r=1;r<this.i;++r)this.J[r]!==this.J[r-1]&&(this.J[e++]=this.J[r]);return this.i=this.J.length=e,this.i}sort(e){this.J.sort(e);}forEach(e){for(let r=0;r<this.i;++r)e(this.J[r],r,this);}[Symbol.iterator](){return function*(){yield*this.J;}.bind(this)()}},x1=ya;Fn.default=x1;});var np=M(Wn=>{v();m();_();Object.defineProperty(Wn,"t",{value:!0});Wn.default=void 0;var M1=U1(qn()),L1=lt(),_r=ut();function U1(t){return t&&t.t?t:{default:t}}var mr=class t extends L1.ContainerIterator{constructor(e,r,i,n){super(n),this.o=e,this.h=r,this.container=i,this.iteratorType===0?(this.pre=function(){return this.o.L===this.h&&(0, _r.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0, _r.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0, _r.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0, _r.throwIteratorAccessError)(),this.o=this.o.L,this});}get pointer(){return this.o===this.h&&(0, _r.throwIteratorAccessError)(),this.o.l}set pointer(e){this.o===this.h&&(0, _r.throwIteratorAccessError)(),this.o.l=e;}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},ba=class extends M1.default{constructor(e=[]){super(),this.h={},this.p=this._=this.h.L=this.h.B=this.h;let r=this;e.forEach(function(i){r.pushBack(i);});}V(e){let{L:r,B:i}=e;r.B=i,i.L=r,e===this.p&&(this.p=i),e===this._&&(this._=r),this.i-=1;}G(e,r){let i=r.B,n={l:e,L:r,B:i};r.B=n,i.L=n,r===this.h&&(this.p=n),i===this.h&&(this._=n),this.i+=1;}clear(){this.i=0,this.p=this._=this.h.L=this.h.B=this.h;}begin(){return new mr(this.p,this.h,this)}end(){return new mr(this.h,this.h,this)}rBegin(){return new mr(this._,this.h,this,1)}rEnd(){return new mr(this.h,this.h,this,1)}front(){return this.p.l}back(){return this._.l}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return r.l}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return this.V(r),this.i}eraseElementByValue(e){let r=this.p;for(;r!==this.h;)r.l===e&&this.V(r),r=r.B;return this.i}eraseElementByIterator(e){let r=e.o;return r===this.h&&(0, _r.throwIteratorAccessError)(),e=e.next(),this.V(r),e}pushBack(e){return this.G(e,this._),this.i}popBack(){if(this.i===0)return;let e=this._.l;return this.V(this._),e}pushFront(e){return this.G(e,this.h),this.i}popFront(){if(this.i===0)return;let e=this.p.l;return this.V(this.p),e}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;let i=this.p;for(;e--;)i=i.B;i.l=r;}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;if(i<=0)return this.i;if(e===0)for(;i--;)this.pushFront(r);else if(e===this.i)for(;i--;)this.pushBack(r);else {let n=this.p;for(let s=1;s<e;++s)n=n.B;let o=n.B;for(this.i+=i;i--;)n.B={l:r,L:n},n.B.L=n,n=n.B;n.B=o,o.L=n;}return this.i}find(e){let r=this.p;for(;r!==this.h;){if(r.l===e)return new mr(r,this.h,this);r=r.B;}return this.end()}reverse(){if(this.i<=1)return;let e=this.p,r=this._,i=0;for(;i<<1<this.i;){let n=e.l;e.l=r.l,r.l=n,e=e.B,r=r.L,i+=1;}}unique(){if(this.i<=1)return this.i;let e=this.p;for(;e!==this.h;){let r=e;for(;r.B!==this.h&&r.l===r.B.l;)r=r.B,this.i-=1;e.B=r.B,e.B.L=e,e=e.B;}return this.i}sort(e){if(this.i<=1)return;let r=[];this.forEach(function(n){r.push(n);}),r.sort(e);let i=this.p;r.forEach(function(n){i.l=n,i=i.B;});}merge(e){let r=this;if(this.i===0)e.forEach(function(i){r.pushBack(i);});else {let i=this.p;e.forEach(function(n){for(;i!==r.h&&i.l<=n;)i=i.B;r.G(n,i.L);});}return this.i}forEach(e){let r=this.p,i=0;for(;r!==this.h;)e(r.l,i++,this),r=r.B;}[Symbol.iterator](){return function*(){if(this.i===0)return;let e=this.p;for(;e!==this.h;)yield e.l,e=e.B;}.bind(this)()}},N1=ba;Wn.default=N1;});var sp=M($n=>{v();m();_();Object.defineProperty($n,"t",{value:!0});$n.default=void 0;var q1=j1(qn()),D1=ga();function j1(t){return t&&t.t?t:{default:t}}var vr=class t extends D1.RandomIterator{constructor(e,r,i){super(e,i),this.container=r;}copy(){return new t(this.o,this.container,this.iteratorType)}},wa=class extends q1.default{constructor(e=[],r=4096){super(),this.j=0,this.D=0,this.R=0,this.N=0,this.P=0,this.A=[];let i=(()=>{if(typeof e.length=="number")return e.length;if(typeof e.size=="number")return e.size;if(typeof e.size=="function")return e.size();throw new TypeError("Cannot get the length or size of the container")})();this.F=r,this.P=Math.max(Math.ceil(i/this.F),1);for(let s=0;s<this.P;++s)this.A.push(new Array(this.F));let n=Math.ceil(i/this.F);this.j=this.R=(this.P>>1)-(n>>1),this.D=this.N=this.F-i%this.F>>1;let o=this;e.forEach(function(s){o.pushBack(s);});}T(){let e=[],r=Math.max(this.P>>1,1);for(let i=0;i<r;++i)e[i]=new Array(this.F);for(let i=this.j;i<this.P;++i)e[e.length]=this.A[i];for(let i=0;i<this.R;++i)e[e.length]=this.A[i];e[e.length]=[...this.A[this.R]],this.j=r,this.R=e.length-1;for(let i=0;i<r;++i)e[e.length]=new Array(this.F);this.A=e,this.P=e.length;}O(e){let r=this.D+e+1,i=r%this.F,n=i-1,o=this.j+(r-i)/this.F;return i===0&&(o-=1),o%=this.P,n<0&&(n+=this.F),{curNodeBucketIndex:o,curNodePointerIndex:n}}clear(){this.A=[new Array(this.F)],this.P=1,this.j=this.R=this.i=0,this.D=this.N=this.F>>1;}begin(){return new vr(0,this)}end(){return new vr(this.i,this)}rBegin(){return new vr(this.i-1,this,1)}rEnd(){return new vr(-1,this,1)}front(){if(this.i!==0)return this.A[this.j][this.D]}back(){if(this.i!==0)return this.A[this.R][this.N]}pushBack(e){return this.i&&(this.N<this.F-1?this.N+=1:this.R<this.P-1?(this.R+=1,this.N=0):(this.R=0,this.N=0),this.R===this.j&&this.N===this.D&&this.T()),this.i+=1,this.A[this.R][this.N]=e,this.i}popBack(){if(this.i===0)return;let e=this.A[this.R][this.N];return this.i!==1&&(this.N>0?this.N-=1:this.R>0?(this.R-=1,this.N=this.F-1):(this.R=this.P-1,this.N=this.F-1)),this.i-=1,e}pushFront(e){return this.i&&(this.D>0?this.D-=1:this.j>0?(this.j-=1,this.D=this.F-1):(this.j=this.P-1,this.D=this.F-1),this.j===this.R&&this.D===this.N&&this.T()),this.i+=1,this.A[this.j][this.D]=e,this.i}popFront(){if(this.i===0)return;let e=this.A[this.j][this.D];return this.i!==1&&(this.D<this.F-1?this.D+=1:this.j<this.P-1?(this.j+=1,this.D=0):(this.j=0,this.D=0)),this.i-=1,e}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let{curNodeBucketIndex:r,curNodePointerIndex:i}=this.O(e);return this.A[r][i]}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;let{curNodeBucketIndex:i,curNodePointerIndex:n}=this.O(e);this.A[i][n]=r;}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;if(e===0)for(;i--;)this.pushFront(r);else if(e===this.i)for(;i--;)this.pushBack(r);else {let n=[];for(let o=e;o<this.i;++o)n.push(this.getElementByPos(o));this.cut(e-1);for(let o=0;o<i;++o)this.pushBack(r);for(let o=0;o<n.length;++o)this.pushBack(n[o]);}return this.i}cut(e){if(e<0)return this.clear(),0;let{curNodeBucketIndex:r,curNodePointerIndex:i}=this.O(e);return this.R=r,this.N=i,this.i=e+1,this.i}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;if(e===0)this.popFront();else if(e===this.i-1)this.popBack();else {let r=[];for(let n=e+1;n<this.i;++n)r.push(this.getElementByPos(n));this.cut(e),this.popBack();let i=this;r.forEach(function(n){i.pushBack(n);});}return this.i}eraseElementByValue(e){if(this.i===0)return 0;let r=[];for(let n=0;n<this.i;++n){let o=this.getElementByPos(n);o!==e&&r.push(o);}let i=r.length;for(let n=0;n<i;++n)this.setElementByPos(n,r[n]);return this.cut(i-1)}eraseElementByIterator(e){let r=e.o;return this.eraseElementByPos(r),e=e.next(),e}find(e){for(let r=0;r<this.i;++r)if(this.getElementByPos(r)===e)return new vr(r,this);return this.end()}reverse(){let e=0,r=this.i-1;for(;e<r;){let i=this.getElementByPos(e);this.setElementByPos(e,this.getElementByPos(r)),this.setElementByPos(r,i),e+=1,r-=1;}}unique(){if(this.i<=1)return this.i;let e=1,r=this.getElementByPos(0);for(let i=1;i<this.i;++i){let n=this.getElementByPos(i);n!==r&&(r=n,this.setElementByPos(e++,n));}for(;this.i>e;)this.popBack();return this.i}sort(e){let r=[];for(let i=0;i<this.i;++i)r.push(this.getElementByPos(i));r.sort(e);for(let i=0;i<this.i;++i)this.setElementByPos(i,r[i]);}shrinkToFit(){if(this.i===0)return;let e=[];this.forEach(function(r){e.push(r);}),this.P=Math.max(Math.ceil(this.i/this.F),1),this.i=this.j=this.R=this.D=this.N=0,this.A=[];for(let r=0;r<this.P;++r)this.A.push(new Array(this.F));for(let r=0;r<e.length;++r)this.pushBack(e[r]);}forEach(e){for(let r=0;r<this.i;++r)e(this.getElementByPos(r),r,this);}[Symbol.iterator](){return function*(){for(let e=0;e<this.i;++e)yield this.getElementByPos(e);}.bind(this)()}},F1=wa;$n.default=F1;});var op=M(Zr=>{v();m();_();Object.defineProperty(Zr,"t",{value:!0});Zr.TreeNodeEnableIndex=Zr.TreeNode=void 0;var Hn=class{constructor(e,r){this.ee=1,this.u=void 0,this.l=void 0,this.U=void 0,this.W=void 0,this.tt=void 0,this.u=e,this.l=r;}L(){let e=this;if(e.ee===1&&e.tt.tt===e)e=e.W;else if(e.U)for(e=e.U;e.W;)e=e.W;else {let r=e.tt;for(;r.U===e;)e=r,r=e.tt;e=r;}return e}B(){let e=this;if(e.W){for(e=e.W;e.U;)e=e.U;return e}else {let r=e.tt;for(;r.W===e;)e=r,r=e.tt;return e.W!==r?r:e}}te(){let e=this.tt,r=this.W,i=r.U;return e.tt===this?e.tt=r:e.U===this?e.U=r:e.W=r,r.tt=e,r.U=this,this.tt=r,this.W=i,i&&(i.tt=this),r}se(){let e=this.tt,r=this.U,i=r.W;return e.tt===this?e.tt=r:e.U===this?e.U=r:e.W=r,r.tt=e,r.W=this,this.tt=r,this.U=i,i&&(i.tt=this),r}};Zr.TreeNode=Hn;var _a=class extends Hn{constructor(){super(...arguments),this.rt=1;}te(){let e=super.te();return this.ie(),e.ie(),e}se(){let e=super.se();return this.ie(),e.ie(),e}ie(){this.rt=1,this.U&&(this.rt+=this.U.rt),this.W&&(this.rt+=this.W.rt);}};Zr.TreeNodeEnableIndex=_a;});var va=M(Vn=>{v();m();_();Object.defineProperty(Vn,"t",{value:!0});Vn.default=void 0;var ap=op(),W1=lt(),lp=ut(),ma=class extends W1.Container{constructor(e=function(i,n){return i<n?-1:i>n?1:0},r=!1){super(),this.Y=void 0,this.v=e,r?(this.re=ap.TreeNodeEnableIndex,this.M=function(i,n,o){let s=this.ne(i,n,o);if(s){let a=s.tt;for(;a!==this.h;)a.rt+=1,a=a.tt;let u=this.he(s);if(u){let{parentNode:c,grandParent:h,curNode:d}=u;c.ie(),h.ie(),d.ie();}}return this.i},this.V=function(i){let n=this.fe(i);for(;n!==this.h;)n.rt-=1,n=n.tt;}):(this.re=ap.TreeNode,this.M=function(i,n,o){let s=this.ne(i,n,o);return s&&this.he(s),this.i},this.V=this.fe),this.h=new this.re;}X(e,r){let i=this.h;for(;e;){let n=this.v(e.u,r);if(n<0)e=e.W;else if(n>0)i=e,e=e.U;else return e}return i}Z(e,r){let i=this.h;for(;e;)this.v(e.u,r)<=0?e=e.W:(i=e,e=e.U);return i}$(e,r){let i=this.h;for(;e;){let n=this.v(e.u,r);if(n<0)i=e,e=e.W;else if(n>0)e=e.U;else return e}return i}rr(e,r){let i=this.h;for(;e;)this.v(e.u,r)<0?(i=e,e=e.W):e=e.U;return i}ue(e){for(;;){let r=e.tt;if(r===this.h)return;if(e.ee===1){e.ee=0;return}if(e===r.U){let i=r.W;if(i.ee===1)i.ee=0,r.ee=1,r===this.Y?this.Y=r.te():r.te();else if(i.W&&i.W.ee===1){i.ee=r.ee,r.ee=0,i.W.ee=0,r===this.Y?this.Y=r.te():r.te();return}else i.U&&i.U.ee===1?(i.ee=1,i.U.ee=0,i.se()):(i.ee=1,e=r);}else {let i=r.U;if(i.ee===1)i.ee=0,r.ee=1,r===this.Y?this.Y=r.se():r.se();else if(i.U&&i.U.ee===1){i.ee=r.ee,r.ee=0,i.U.ee=0,r===this.Y?this.Y=r.se():r.se();return}else i.W&&i.W.ee===1?(i.ee=1,i.W.ee=0,i.te()):(i.ee=1,e=r);}}}fe(e){if(this.i===1)return this.clear(),this.h;let r=e;for(;r.U||r.W;){if(r.W)for(r=r.W;r.U;)r=r.U;else r=r.U;[e.u,r.u]=[r.u,e.u],[e.l,r.l]=[r.l,e.l],e=r;}this.h.U===r?this.h.U=r.tt:this.h.W===r&&(this.h.W=r.tt),this.ue(r);let i=r.tt;return r===i.U?i.U=void 0:i.W=void 0,this.i-=1,this.Y.ee=0,i}oe(e,r){return e===void 0?!1:this.oe(e.U,r)||r(e)?!0:this.oe(e.W,r)}he(e){for(;;){let r=e.tt;if(r.ee===0)return;let i=r.tt;if(r===i.U){let n=i.W;if(n&&n.ee===1){if(n.ee=r.ee=0,i===this.Y)return;i.ee=1,e=i;continue}else if(e===r.W){if(e.ee=0,e.U&&(e.U.tt=r),e.W&&(e.W.tt=i),r.W=e.U,i.U=e.W,e.U=r,e.W=i,i===this.Y)this.Y=e,this.h.tt=e;else {let o=i.tt;o.U===i?o.U=e:o.W=e;}return e.tt=i.tt,r.tt=e,i.tt=e,i.ee=1,{parentNode:r,grandParent:i,curNode:e}}else r.ee=0,i===this.Y?this.Y=i.se():i.se(),i.ee=1;}else {let n=i.U;if(n&&n.ee===1){if(n.ee=r.ee=0,i===this.Y)return;i.ee=1,e=i;continue}else if(e===r.U){if(e.ee=0,e.U&&(e.U.tt=i),e.W&&(e.W.tt=r),i.W=e.U,r.U=e.W,e.U=i,e.W=r,i===this.Y)this.Y=e,this.h.tt=e;else {let o=i.tt;o.U===i?o.U=e:o.W=e;}return e.tt=i.tt,r.tt=e,i.tt=e,i.ee=1,{parentNode:r,grandParent:i,curNode:e}}else r.ee=0,i===this.Y?this.Y=i.te():i.te(),i.ee=1;}return}}ne(e,r,i){if(this.Y===void 0){this.i+=1,this.Y=new this.re(e,r),this.Y.ee=0,this.Y.tt=this.h,this.h.tt=this.Y,this.h.U=this.Y,this.h.W=this.Y;return}let n,o=this.h.U,s=this.v(o.u,e);if(s===0){o.l=r;return}else if(s>0)o.U=new this.re(e,r),o.U.tt=o,n=o.U,this.h.U=n;else {let a=this.h.W,u=this.v(a.u,e);if(u===0){a.l=r;return}else if(u<0)a.W=new this.re(e,r),a.W.tt=a,n=a.W,this.h.W=n;else {if(i!==void 0){let c=i.o;if(c!==this.h){let h=this.v(c.u,e);if(h===0){c.l=r;return}else if(h>0){let d=c.L(),g=this.v(d.u,e);if(g===0){d.l=r;return}else g<0&&(n=new this.re(e,r),d.W===void 0?(d.W=n,n.tt=d):(c.U=n,n.tt=c));}}}if(n===void 0)for(n=this.Y;;){let c=this.v(n.u,e);if(c>0){if(n.U===void 0){n.U=new this.re(e,r),n.U.tt=n,n=n.U;break}n=n.U;}else if(c<0){if(n.W===void 0){n.W=new this.re(e,r),n.W.tt=n,n=n.W;break}n=n.W;}else {n.l=r;return}}}}return this.i+=1,n}I(e,r){for(;e;){let i=this.v(e.u,r);if(i<0)e=e.W;else if(i>0)e=e.U;else return e}return e||this.h}clear(){this.i=0,this.Y=void 0,this.h.tt=void 0,this.h.U=this.h.W=void 0;}updateKeyByIterator(e,r){let i=e.o;if(i===this.h&&(0, lp.throwIteratorAccessError)(),this.i===1)return i.u=r,!0;if(i===this.h.U)return this.v(i.B().u,r)>0?(i.u=r,!0):!1;if(i===this.h.W)return this.v(i.L().u,r)<0?(i.u=r,!0):!1;let n=i.L().u;if(this.v(n,r)>=0)return !1;let o=i.B().u;return this.v(o,r)<=0?!1:(i.u=r,!0)}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=0,i=this;return this.oe(this.Y,function(n){return e===r?(i.V(n),!0):(r+=1,!1)}),this.i}eraseElementByKey(e){if(this.i===0)return !1;let r=this.I(this.Y,e);return r===this.h?!1:(this.V(r),!0)}eraseElementByIterator(e){let r=e.o;r===this.h&&(0, lp.throwIteratorAccessError)();let i=r.W===void 0;return e.iteratorType===0?i&&e.next():(!i||r.U===void 0)&&e.next(),this.V(r),e}forEach(e){let r=0;for(let i of this)e(i,r++,this);}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r,i=0;for(let n of this){if(i===e){r=n;break}i+=1;}return r}getHeight(){if(this.i===0)return 0;let e=function(r){return r?Math.max(e(r.U),e(r.W))+1:0};return e(this.Y)}},$1=ma;Vn.default=$1;});var Sa=M(Kn=>{v();m();_();Object.defineProperty(Kn,"t",{value:!0});Kn.default=void 0;var H1=lt(),zn=ut(),Ea=class extends H1.ContainerIterator{constructor(e,r,i){super(i),this.o=e,this.h=r,this.iteratorType===0?(this.pre=function(){return this.o===this.h.U&&(0, zn.throwIteratorAccessError)(),this.o=this.o.L(),this},this.next=function(){return this.o===this.h&&(0, zn.throwIteratorAccessError)(),this.o=this.o.B(),this}):(this.pre=function(){return this.o===this.h.W&&(0, zn.throwIteratorAccessError)(),this.o=this.o.B(),this},this.next=function(){return this.o===this.h&&(0, zn.throwIteratorAccessError)(),this.o=this.o.L(),this});}get index(){let e=this.o,r=this.h.tt;if(e===this.h)return r?r.rt-1:0;let i=0;for(e.U&&(i+=e.U.rt);e!==r;){let n=e.tt;e===n.W&&(i+=1,n.U&&(i+=n.U.rt)),e=n;}return i}},V1=Ea;Kn.default=V1;});var fp=M(Gn=>{v();m();_();Object.defineProperty(Gn,"t",{value:!0});Gn.default=void 0;var z1=up(va()),K1=up(Sa()),G1=ut();function up(t){return t&&t.t?t:{default:t}}var Ke=class t extends K1.default{constructor(e,r,i,n){super(e,r,n),this.container=i;}get pointer(){return this.o===this.h&&(0, G1.throwIteratorAccessError)(),this.o.u}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Aa=class extends z1.default{constructor(e=[],r,i){super(r,i);let n=this;e.forEach(function(o){n.insert(o);});}*K(e){e!==void 0&&(yield*this.K(e.U),yield e.u,yield*this.K(e.W));}begin(){return new Ke(this.h.U||this.h,this.h,this)}end(){return new Ke(this.h,this.h,this)}rBegin(){return new Ke(this.h.W||this.h,this.h,this,1)}rEnd(){return new Ke(this.h,this.h,this,1)}front(){return this.h.U?this.h.U.u:void 0}back(){return this.h.W?this.h.W.u:void 0}insert(e,r){return this.M(e,void 0,r)}find(e){let r=this.I(this.Y,e);return new Ke(r,this.h,this)}lowerBound(e){let r=this.X(this.Y,e);return new Ke(r,this.h,this)}upperBound(e){let r=this.Z(this.Y,e);return new Ke(r,this.h,this)}reverseLowerBound(e){let r=this.$(this.Y,e);return new Ke(r,this.h,this)}reverseUpperBound(e){let r=this.rr(this.Y,e);return new Ke(r,this.h,this)}union(e){let r=this;return e.forEach(function(i){r.insert(i);}),this.i}[Symbol.iterator](){return this.K(this.Y)}},Q1=Aa;Gn.default=Q1;});var hp=M(Qn=>{v();m();_();Object.defineProperty(Qn,"t",{value:!0});Qn.default=void 0;var Y1=cp(va()),J1=cp(Sa()),X1=ut();function cp(t){return t&&t.t?t:{default:t}}var Ge=class t extends J1.default{constructor(e,r,i,n){super(e,r,n),this.container=i;}get pointer(){this.o===this.h&&(0, X1.throwIteratorAccessError)();let e=this;return new Proxy([],{get(r,i){if(i==="0")return e.o.u;if(i==="1")return e.o.l},set(r,i,n){if(i!=="1")throw new TypeError("props must be 1");return e.o.l=n,!0}})}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Ia=class extends Y1.default{constructor(e=[],r,i){super(r,i);let n=this;e.forEach(function(o){n.setElement(o[0],o[1]);});}*K(e){e!==void 0&&(yield*this.K(e.U),yield [e.u,e.l],yield*this.K(e.W));}begin(){return new Ge(this.h.U||this.h,this.h,this)}end(){return new Ge(this.h,this.h,this)}rBegin(){return new Ge(this.h.W||this.h,this.h,this,1)}rEnd(){return new Ge(this.h,this.h,this,1)}front(){if(this.i===0)return;let e=this.h.U;return [e.u,e.l]}back(){if(this.i===0)return;let e=this.h.W;return [e.u,e.l]}lowerBound(e){let r=this.X(this.Y,e);return new Ge(r,this.h,this)}upperBound(e){let r=this.Z(this.Y,e);return new Ge(r,this.h,this)}reverseLowerBound(e){let r=this.$(this.Y,e);return new Ge(r,this.h,this)}reverseUpperBound(e){let r=this.rr(this.Y,e);return new Ge(r,this.h,this)}setElement(e,r,i){return this.M(e,r,i)}find(e){let r=this.I(this.Y,e);return new Ge(r,this.h,this)}getElementByKey(e){return this.I(this.Y,e).l}union(e){let r=this;return e.forEach(function(i){r.setElement(i[0],i[1]);}),this.i}[Symbol.iterator](){return this.K(this.Y)}},Z1=Ia;Qn.default=Z1;});var Ra=M(Ta=>{v();m();_();Object.defineProperty(Ta,"t",{value:!0});Ta.default=ev;function ev(t){let e=typeof t;return e==="object"&&t!==null||e==="function"}});var ka=M(ei=>{v();m();_();Object.defineProperty(ei,"t",{value:!0});ei.HashContainerIterator=ei.HashContainer=void 0;var dp=lt(),Ca=tv(Ra()),Ti=ut();function tv(t){return t&&t.t?t:{default:t}}var Ba=class extends dp.ContainerIterator{constructor(e,r,i){super(i),this.o=e,this.h=r,this.iteratorType===0?(this.pre=function(){return this.o.L===this.h&&(0, Ti.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0, Ti.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0, Ti.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0, Ti.throwIteratorAccessError)(),this.o=this.o.L,this});}};ei.HashContainerIterator=Ba;var Pa=class extends dp.Container{constructor(){super(),this.H=[],this.g={},this.HASH_TAG=Symbol("@@HASH_TAG"),Object.setPrototypeOf(this.g,null),this.h={},this.h.L=this.h.B=this.p=this._=this.h;}V(e){let{L:r,B:i}=e;r.B=i,i.L=r,e===this.p&&(this.p=i),e===this._&&(this._=r),this.i-=1;}M(e,r,i){i===void 0&&(i=(0, Ca.default)(e));let n;if(i){let o=e[this.HASH_TAG];if(o!==void 0)return this.H[o].l=r,this.i;Object.defineProperty(e,this.HASH_TAG,{value:this.H.length,configurable:!0}),n={u:e,l:r,L:this._,B:this.h},this.H.push(n);}else {let o=this.g[e];if(o)return o.l=r,this.i;n={u:e,l:r,L:this._,B:this.h},this.g[e]=n;}return this.i===0?(this.p=n,this.h.B=n):this._.B=n,this._=n,this.h.L=n,++this.i}I(e,r){if(r===void 0&&(r=(0, Ca.default)(e)),r){let i=e[this.HASH_TAG];return i===void 0?this.h:this.H[i]}else return this.g[e]||this.h}clear(){let e=this.HASH_TAG;this.H.forEach(function(r){delete r.u[e];}),this.H=[],this.g={},Object.setPrototypeOf(this.g,null),this.i=0,this.p=this._=this.h.L=this.h.B=this.h;}eraseElementByKey(e,r){let i;if(r===void 0&&(r=(0, Ca.default)(e)),r){let n=e[this.HASH_TAG];if(n===void 0)return !1;delete e[this.HASH_TAG],i=this.H[n],delete this.H[n];}else {if(i=this.g[e],i===void 0)return !1;delete this.g[e];}return this.V(i),!0}eraseElementByIterator(e){let r=e.o;return r===this.h&&(0, Ti.throwIteratorAccessError)(),this.V(r),e.next()}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return this.V(r),this.i}};ei.HashContainer=Pa;});var gp=M(Yn=>{v();m();_();Object.defineProperty(Yn,"t",{value:!0});Yn.default=void 0;var pp=ka(),rv=ut(),Er=class t extends pp.HashContainerIterator{constructor(e,r,i,n){super(e,r,n),this.container=i;}get pointer(){return this.o===this.h&&(0, rv.throwIteratorAccessError)(),this.o.u}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Oa=class extends pp.HashContainer{constructor(e=[]){super();let r=this;e.forEach(function(i){r.insert(i);});}begin(){return new Er(this.p,this.h,this)}end(){return new Er(this.h,this.h,this)}rBegin(){return new Er(this._,this.h,this,1)}rEnd(){return new Er(this.h,this.h,this,1)}front(){return this.p.u}back(){return this._.u}insert(e,r){return this.M(e,void 0,r)}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return r.u}find(e,r){let i=this.I(e,r);return new Er(i,this.h,this)}forEach(e){let r=0,i=this.p;for(;i!==this.h;)e(i.u,r++,this),i=i.B;}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield e.u,e=e.B;}.bind(this)()}},iv=Oa;Yn.default=iv;});var bp=M(Jn=>{v();m();_();Object.defineProperty(Jn,"t",{value:!0});Jn.default=void 0;var yp=ka(),nv=ov(Ra()),sv=ut();function ov(t){return t&&t.t?t:{default:t}}var Sr=class t extends yp.HashContainerIterator{constructor(e,r,i,n){super(e,r,n),this.container=i;}get pointer(){this.o===this.h&&(0, sv.throwIteratorAccessError)();let e=this;return new Proxy([],{get(r,i){if(i==="0")return e.o.u;if(i==="1")return e.o.l},set(r,i,n){if(i!=="1")throw new TypeError("props must be 1");return e.o.l=n,!0}})}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},xa=class extends yp.HashContainer{constructor(e=[]){super();let r=this;e.forEach(function(i){r.setElement(i[0],i[1]);});}begin(){return new Sr(this.p,this.h,this)}end(){return new Sr(this.h,this.h,this)}rBegin(){return new Sr(this._,this.h,this,1)}rEnd(){return new Sr(this.h,this.h,this,1)}front(){if(this.i!==0)return [this.p.u,this.p.l]}back(){if(this.i!==0)return [this._.u,this._.l]}setElement(e,r,i){return this.M(e,r,i)}getElementByKey(e,r){if(r===void 0&&(r=(0, nv.default)(e)),r){let n=e[this.HASH_TAG];return n!==void 0?this.H[n].l:void 0}let i=this.g[e];return i?i.l:void 0}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return [r.u,r.l]}find(e,r){let i=this.I(e,r);return new Sr(i,this.h,this)}forEach(e){let r=0,i=this.p;for(;i!==this.h;)e([i.u,i.l],r++,this),i=i.B;}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield [e.u,e.l],e=e.B;}.bind(this)()}},av=xa;Jn.default=av;});var wp=M(je=>{v();m();_();Object.defineProperty(je,"t",{value:!0});Object.defineProperty(je,"Deque",{enumerable:!0,get:function(){return dv.default}});Object.defineProperty(je,"HashMap",{enumerable:!0,get:function(){return bv.default}});Object.defineProperty(je,"HashSet",{enumerable:!0,get:function(){return yv.default}});Object.defineProperty(je,"LinkList",{enumerable:!0,get:function(){return hv.default}});Object.defineProperty(je,"OrderedMap",{enumerable:!0,get:function(){return gv.default}});Object.defineProperty(je,"OrderedSet",{enumerable:!0,get:function(){return pv.default}});Object.defineProperty(je,"PriorityQueue",{enumerable:!0,get:function(){return fv.default}});Object.defineProperty(je,"Queue",{enumerable:!0,get:function(){return uv.default}});Object.defineProperty(je,"Stack",{enumerable:!0,get:function(){return lv.default}});Object.defineProperty(je,"Vector",{enumerable:!0,get:function(){return cv.default}});var lv=ft(ep()),uv=ft(tp()),fv=ft(rp()),cv=ft(ip()),hv=ft(np()),dv=ft(sp()),pv=ft(fp()),gv=ft(hp()),yv=ft(gp()),bv=ft(bp());function ft(t){return t&&t.t?t:{default:t}}});var mp=M((SN,_p)=>{v();m();_();var wv=wp().OrderedSet,ct=ot()("number-allocator:trace"),_v=ot()("number-allocator:error");function Te(t,e){this.low=t,this.high=e;}Te.prototype.equals=function(t){return this.low===t.low&&this.high===t.high};Te.prototype.compare=function(t){return this.low<t.low&&this.high<t.low?-1:t.low<this.low&&t.high<this.low?1:0};function ht(t,e){if(!(this instanceof ht))return new ht(t,e);this.min=t,this.max=e,this.ss=new wv([],(r,i)=>r.compare(i)),ct("Create"),this.clear();}ht.prototype.firstVacant=function(){return this.ss.size()===0?null:this.ss.front().low};ht.prototype.alloc=function(){if(this.ss.size()===0)return ct("alloc():empty"),null;let t=this.ss.begin(),e=t.pointer.low,r=t.pointer.high,i=e;return i+1<=r?this.ss.updateKeyByIterator(t,new Te(e+1,r)):this.ss.eraseElementByPos(0),ct("alloc():"+i),i};ht.prototype.use=function(t){let e=new Te(t,t),r=this.ss.lowerBound(e);if(!r.equals(this.ss.end())){let i=r.pointer.low,n=r.pointer.high;return r.pointer.equals(e)?(this.ss.eraseElementByIterator(r),ct("use():"+t),!0):i>t?!1:i===t?(this.ss.updateKeyByIterator(r,new Te(i+1,n)),ct("use():"+t),!0):n===t?(this.ss.updateKeyByIterator(r,new Te(i,n-1)),ct("use():"+t),!0):(this.ss.updateKeyByIterator(r,new Te(t+1,n)),this.ss.insert(new Te(i,t-1)),ct("use():"+t),!0)}return ct("use():failed"),!1};ht.prototype.free=function(t){if(t<this.min||t>this.max){_v("free():"+t+" is out of range");return}let e=new Te(t,t),r=this.ss.upperBound(e);if(r.equals(this.ss.end())){if(r.equals(this.ss.begin())){this.ss.insert(e);return}r.pre();let i=r.pointer.high;r.pointer.high+1===t?this.ss.updateKeyByIterator(r,new Te(i,t)):this.ss.insert(e);}else if(r.equals(this.ss.begin()))if(t+1===r.pointer.low){let i=r.pointer.high;this.ss.updateKeyByIterator(r,new Te(t,i));}else this.ss.insert(e);else {let i=r.pointer.low,n=r.pointer.high;r.pre();let o=r.pointer.low;r.pointer.high+1===t?t+1===i?(this.ss.eraseElementByIterator(r),this.ss.updateKeyByIterator(r,new Te(o,n))):this.ss.updateKeyByIterator(r,new Te(o,t)):t+1===i?(this.ss.eraseElementByIterator(r.next()),this.ss.insert(new Te(t,n))):this.ss.insert(e);}ct("free():"+t);};ht.prototype.clear=function(){ct("clear()"),this.ss.clear(),this.ss.insert(new Te(this.min,this.max));};ht.prototype.intervalCount=function(){return this.ss.size()};ht.prototype.dump=function(){console.log("length:"+this.ss.size());for(let t of this.ss)console.log(t);};_p.exports=ht;});var Ma=M((xN,vp)=>{v();m();_();var mv=mp();vp.exports.NumberAllocator=mv;});var Ep=M(Ua=>{v();m();_();Object.defineProperty(Ua,"__esModule",{value:!0});var vv=Zd(),Ev=Ma(),La=class{constructor(e){e>0&&(this.aliasToTopic=new vv.LRUCache({max:e}),this.topicToAlias={},this.numberAllocator=new Ev.NumberAllocator(1,e),this.max=e,this.length=0);}put(e,r){if(r===0||r>this.max)return !1;let i=this.aliasToTopic.get(r);return i&&delete this.topicToAlias[i],this.aliasToTopic.set(r,e),this.topicToAlias[e]=r,this.numberAllocator.use(r),this.length=this.aliasToTopic.size,!0}getTopicByAlias(e){return this.aliasToTopic.get(e)}getAliasByTopic(e){let r=this.topicToAlias[e];return typeof r<"u"&&this.aliasToTopic.get(r),r}clear(){this.aliasToTopic.clear(),this.topicToAlias={},this.numberAllocator.clear(),this.length=0;}getLruAlias(){let e=this.numberAllocator.firstVacant();return e||[...this.aliasToTopic.keys()][this.aliasToTopic.size-1]}};Ua.default=La;});var Sp=M(Ri=>{v();m();_();var Sv=Ri&&Ri.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ri,"__esModule",{value:!0});var Av=Ai(),Iv=Sv(Ep()),Tv=Jr(),Rv=(t,e)=>{t.log("_handleConnack");let{options:r}=t,n=r.protocolVersion===5?e.reasonCode:e.returnCode;if(clearTimeout(t.connackTimer),delete t.topicAliasSend,e.properties){if(e.properties.topicAliasMaximum){if(e.properties.topicAliasMaximum>65535){t.emit("error",new Error("topicAliasMaximum from broker is out of range"));return}e.properties.topicAliasMaximum>0&&(t.topicAliasSend=new Iv.default(e.properties.topicAliasMaximum));}e.properties.serverKeepAlive&&r.keepalive&&(r.keepalive=e.properties.serverKeepAlive),e.properties.maximumPacketSize&&(r.properties||(r.properties={}),r.properties.maximumPacketSize=e.properties.maximumPacketSize);}if(n===0)t.reconnecting=!1,t._onConnect(e);else if(n>0){let o=new Tv.ErrorWithReasonCode(`Connection refused: ${Av.ReasonCodes[n]}`,n);t.emit("error",o);}};Ri.default=Rv;});var Ap=M(Na=>{v();m();_();Object.defineProperty(Na,"__esModule",{value:!0});var Cv=(t,e,r)=>{t.log("handling pubrel packet");let i=typeof r<"u"?r:t.noop,{messageId:n}=e,o={cmd:"pubcomp",messageId:n};t.incomingStore.get(e,(s,a)=>{s?t._sendPacket(o,i):(t.emit("message",a.topic,a.payload,a),t.handleMessage(a,u=>{if(u)return i(u);t.incomingStore.del(a,t.noop),t._sendPacket(o,i);}));});};Na.default=Cv;});var Ip=M(Ci=>{v();m();_();var Bi=Ci&&Ci.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ci,"__esModule",{value:!0});var Bv=Bi(Vd()),Pv=Bi(Gd()),kv=Bi(Sp()),Ov=Bi(Ai()),xv=Bi(Ap()),Mv=(t,e,r)=>{let{options:i}=t;if(i.protocolVersion===5&&i.properties&&i.properties.maximumPacketSize&&i.properties.maximumPacketSize<e.length)return t.emit("error",new Error(`exceeding packets size ${e.cmd}`)),t.end({reasonCode:149,properties:{reasonString:"Maximum packet size was exceeded"}}),t;switch(t.log("_handlePacket :: emitting packetreceive"),t.emit("packetreceive",e),e.cmd){case"publish":(0, Bv.default)(t,e,r);break;case"puback":case"pubrec":case"pubcomp":case"suback":case"unsuback":t.reschedulePing(),(0, Ov.default)(t,e),r();break;case"pubrel":t.reschedulePing(),(0, xv.default)(t,e,r);break;case"connack":(0, kv.default)(t,e),r();break;case"auth":t.reschedulePing(),(0, Pv.default)(t,e),r();break;case"pingresp":t.log("_handlePacket :: received pingresp"),t.reschedulePing(),r();break;case"disconnect":t.emit("disconnect",e),r();break;default:t.log("_handlePacket :: unknown command"),r();break}};Ci.default=Mv;});var Tp=M(ti=>{v();m();_();var Lv=ti&&ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(ti,"__esModule",{value:!0});ti.TypedEventEmitter=void 0;var Uv=Lv((ir(),X(rr))),Nv=Jr(),Xn=class{};ti.TypedEventEmitter=Xn;(0, Nv.applyMixin)(Xn,Uv.default);});var Pi=M(Ar=>{v();m();_();Object.defineProperty(Ar,"__esModule",{value:!0});Ar.isReactNativeBrowser=Ar.isWebWorker=void 0;var qv=()=>{var t;return typeof window<"u"?typeof P<"u"&&((t=P.userAgent)===null||t===void 0?void 0:t.toLowerCase().indexOf(" electron/"))>-1&&(!(C===null||C===void 0)&&C.versions)?!Object.prototype.hasOwnProperty.call(C.versions,"electron"):typeof window.document<"u":!1},Rp=()=>{var t,e;return !!(typeof self=="object"&&(!((e=(t=self?.constructor)===null||t===void 0?void 0:t.name)===null||e===void 0)&&e.includes("WorkerGlobalScope")))},Cp=()=>typeof P<"u"&&P.product==="ReactNative",Dv=qv()||Rp()||Cp();Ar.isWebWorker=Rp();Ar.isReactNativeBrowser=Cp();Ar.default=Dv;});var Pp=M((Zn,Bp)=>{v();m();_();(function(t,e){typeof Zn=="object"&&typeof Bp<"u"?e(Zn):typeof define=="function"&&define.amd?define(["exports"],e):(t=typeof globalThis<"u"?globalThis:t||self,e(t.fastUniqueNumbers={}));})(Zn,function(t){var e=function(g){return function(y){var w=g(y);return y.add(w),w}},r=function(g){return function(y,w){return g.set(y,w),w}},i=Number.MAX_SAFE_INTEGER===void 0?9007199254740991:Number.MAX_SAFE_INTEGER,n=536870912,o=n*2,s=function(g,y){return function(w){var E=y.get(w),S=E===void 0?w.size:E<o?E+1:0;if(!w.has(S))return g(w,S);if(w.size<n){for(;w.has(S);)S=Math.floor(Math.random()*o);return g(w,S)}if(w.size>i)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;w.has(S);)S=Math.floor(Math.random()*i);return g(w,S)}},a=new WeakMap,u=r(a),c=s(u,a),h=e(c);t.addUniqueNumber=h,t.generateUniqueNumber=c;});});var Op=M((es,kp)=>{v();m();_();(function(t,e){typeof es=="object"&&typeof kp<"u"?e(es,Pp()):typeof define=="function"&&define.amd?define(["exports","fast-unique-numbers"],e):(t=typeof globalThis<"u"?globalThis:t||self,e(t.workerTimersBroker={},t.fastUniqueNumbers));})(es,function(t,e){var r=function(s){return s.method!==void 0&&s.method==="call"},i=function(s){return s.error===null&&typeof s.id=="number"},n=function(s){var a=new Map([[0,function(){}]]),u=new Map([[0,function(){}]]),c=new Map,h=new Worker(s);h.addEventListener("message",function(E){var S=E.data;if(r(S)){var I=S.params,B=I.timerId,R=I.timerType;if(R==="interval"){var U=a.get(B);if(typeof U=="number"){var N=c.get(U);if(N===void 0||N.timerId!==B||N.timerType!==R)throw new Error("The timer is in an undefined state.")}else if(typeof U<"u")U();else throw new Error("The timer is in an undefined state.")}else if(R==="timeout"){var W=u.get(B);if(typeof W=="number"){var K=c.get(W);if(K===void 0||K.timerId!==B||K.timerType!==R)throw new Error("The timer is in an undefined state.")}else if(typeof W<"u")W(),u.delete(B);else throw new Error("The timer is in an undefined state.")}}else if(i(S)){var z=S.id,Q=c.get(z);if(Q===void 0)throw new Error("The timer is in an undefined state.");var de=Q.timerId,Gt=Q.timerType;c.delete(z),Gt==="interval"?a.delete(de):u.delete(de);}else {var pe=S.error.message;throw new Error(pe)}});var d=function(S){var I=e.generateUniqueNumber(c);c.set(I,{timerId:S,timerType:"interval"}),a.set(S,I),h.postMessage({id:I,method:"clear",params:{timerId:S,timerType:"interval"}});},g=function(S){var I=e.generateUniqueNumber(c);c.set(I,{timerId:S,timerType:"timeout"}),u.set(S,I),h.postMessage({id:I,method:"clear",params:{timerId:S,timerType:"timeout"}});},y=function(S){var I=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,B=e.generateUniqueNumber(a);return a.set(B,function(){S(),typeof a.get(B)=="function"&&h.postMessage({id:null,method:"set",params:{delay:I,now:performance.now(),timerId:B,timerType:"interval"}});}),h.postMessage({id:null,method:"set",params:{delay:I,now:performance.now(),timerId:B,timerType:"interval"}}),B},w=function(S){var I=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,B=e.generateUniqueNumber(u);return u.set(B,S),h.postMessage({id:null,method:"set",params:{delay:I,now:performance.now(),timerId:B,timerType:"timeout"}}),B};return {clearInterval:d,clearTimeout:g,setInterval:y,setTimeout:w}};t.load=n;});});var Mp=M((ts,xp)=>{v();m();_();(function(t,e){typeof ts=="object"&&typeof xp<"u"?e(ts,Op()):typeof define=="function"&&define.amd?define(["exports","worker-timers-broker"],e):(t=typeof globalThis<"u"?globalThis:t||self,e(t.workerTimers={},t.workerTimersBroker));})(ts,function(t,e){var r=function(h,d){var g=null;return function(){if(g!==null)return g;var y=new Blob([d],{type:"application/javascript; charset=utf-8"}),w=URL.createObjectURL(y);return g=h(w),setTimeout(function(){return URL.revokeObjectURL(w)}),g}},i=`(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error('The given type "'.concat(c,'" is not supported'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error('The given method "'.concat(t.method,'" is not supported'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error('The given type "'.concat(v,'" is not supported'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();`,n=r(e.load,i),o=function(h){return n().clearInterval(h)},s=function(h){return n().clearTimeout(h)},a=function(){var h;return (h=n()).setInterval.apply(h,arguments)},u=function(){var h;return (h=n()).setTimeout.apply(h,arguments)};t.clearInterval=o,t.clearTimeout=s,t.setInterval=a,t.setTimeout=u;});});var qp=M(Ct=>{v();m();_();var jv=Ct&&Ct.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n);}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r];}),Fv=Ct&&Ct.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e});}:function(t,e){t.default=e;}),Wv=Ct&&Ct.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!=="default"&&Object.prototype.hasOwnProperty.call(t,r)&&jv(e,t,r);return Fv(e,t),e};Object.defineProperty(Ct,"__esModule",{value:!0});var qa=Wv(Pi()),Lp=Mp(),Up={set:Lp.setInterval,clear:Lp.clearInterval},Np={set:(t,e)=>setInterval(t,e),clear:t=>clearInterval(t)},$v=t=>{switch(t){case"native":return Np;case"worker":return Up;case"auto":default:return qa.default&&!qa.isWebWorker&&!qa.isReactNativeBrowser?Up:Np}};Ct.default=$v;});var ja=M(ki=>{v();m();_();var Hv=ki&&ki.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(ki,"__esModule",{value:!0});var Vv=Hv(qp()),Da=class{get keepaliveTimeoutTimestamp(){return this._keepaliveTimeoutTimestamp}get intervalEvery(){return this._intervalEvery}get keepalive(){return this._keepalive}constructor(e,r){this.destroyed=!1,this.client=e,this.timer=(0, Vv.default)(r),this.setKeepalive(e.options.keepalive);}clear(){this.timerId&&(this.timer.clear(this.timerId),this.timerId=null);}setKeepalive(e){if(e*=1e3,isNaN(e)||e<=0||e>2147483647)throw new Error(`Keepalive value must be an integer between 0 and 2147483647. Provided value is ${e}`);this._keepalive=e,this.reschedule(),this.client.log(`KeepaliveManager: set keepalive to ${e}ms`);}destroy(){this.clear(),this.destroyed=!0;}reschedule(){if(this.destroyed)return;this.clear(),this.counter=0;let e=Math.ceil(this._keepalive*1.5);this._keepaliveTimeoutTimestamp=Date.now()+e,this._intervalEvery=Math.ceil(this._keepalive/2),this.timerId=this.timer.set(()=>{this.destroyed||(this.counter+=1,this.counter===2?this.client.sendPing():this.counter>2&&this.client.onKeepaliveTimeout());},this._intervalEvery);}};ki.default=Da;});var ss=M(Qe=>{v();m();_();var zv=Qe&&Qe.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n);}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r];}),Kv=Qe&&Qe.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e});}:function(t,e){t.default=e;}),$p=Qe&&Qe.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!=="default"&&Object.prototype.hasOwnProperty.call(t,r)&&zv(e,t,r);return Kv(e,t),e},Vt=Qe&&Qe.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Qe,"__esModule",{value:!0});var Gv=Vt(Gu()),Fa=Vt(Nd()),Qv=Vt(Jo()),Yv=jt(),Dp=Vt(Fd()),jp=$p($d()),Jv=Vt(ot()),rs=Vt(ea()),Xv=Vt(Ip()),is=Jr(),Zv=Tp(),eE=Vt(ja()),Fp=$p(Pi()),Wa=globalThis.setImmediate||((...t)=>{let e=t.shift();(0, is.nextTick)(()=>{e(...t);});}),Wp={keepalive:60,reschedulePings:!0,protocolId:"MQTT",protocolVersion:4,reconnectPeriod:1e3,connectTimeout:30*1e3,clean:!0,resubscribe:!0,writeCache:!0,timerVariant:"auto"},ns=class t extends Zv.TypedEventEmitter{static defaultId(){return `mqttjs_${Math.random().toString(16).substr(2,8)}`}constructor(e,r){super(),this.options=r||{};for(let i in Wp)typeof this.options[i]>"u"?this.options[i]=Wp[i]:this.options[i]=r[i];this.log=this.options.log||(0, Jv.default)("mqttjs:client"),this.noop=this._noop.bind(this),this.log("MqttClient :: version:",t.VERSION),Fp.isWebWorker?this.log("MqttClient :: environment","webworker"):this.log("MqttClient :: environment",Fp.default?"browser":"node"),this.log("MqttClient :: options.protocol",r.protocol),this.log("MqttClient :: options.protocolVersion",r.protocolVersion),this.log("MqttClient :: options.username",r.username),this.log("MqttClient :: options.keepalive",r.keepalive),this.log("MqttClient :: options.reconnectPeriod",r.reconnectPeriod),this.log("MqttClient :: options.rejectUnauthorized",r.rejectUnauthorized),this.log("MqttClient :: options.properties.topicAliasMaximum",r.properties?r.properties.topicAliasMaximum:void 0),this.options.clientId=typeof r.clientId=="string"?r.clientId:t.defaultId(),this.log("MqttClient :: clientId",this.options.clientId),this.options.customHandleAcks=r.protocolVersion===5&&r.customHandleAcks?r.customHandleAcks:(...i)=>{i[3](null,0);},this.options.writeCache||(Fa.default.writeToStream.cacheNumbers=!1),this.streamBuilder=e,this.messageIdProvider=typeof this.options.messageIdProvider>"u"?new Qv.default:this.options.messageIdProvider,this.outgoingStore=r.outgoingStore||new rs.default,this.incomingStore=r.incomingStore||new rs.default,this.queueQoSZero=r.queueQoSZero===void 0?!0:r.queueQoSZero,this._resubscribeTopics={},this.messageIdToTopic={},this.keepaliveManager=null,this.connected=!1,this.disconnecting=!1,this.reconnecting=!1,this.queue=[],this.connackTimer=null,this.reconnectTimer=null,this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={},this._storeProcessingQueue=[],this.outgoing={},this._firstConnection=!0,r.properties&&r.properties.topicAliasMaximum>0&&(r.properties.topicAliasMaximum>65535?this.log("MqttClient :: options.properties.topicAliasMaximum is out of range"):this.topicAliasRecv=new Gv.default(r.properties.topicAliasMaximum)),this.on("connect",()=>{let{queue:i}=this,n=()=>{let o=i.shift();this.log("deliver :: entry %o",o);let s=null;if(!o){this._resubscribe();return}s=o.packet,this.log("deliver :: call _sendPacket for %o",s);let a=!0;s.messageId&&s.messageId!==0&&(this.messageIdProvider.register(s.messageId)||(a=!1)),a?this._sendPacket(s,u=>{o.cb&&o.cb(u),n();}):(this.log("messageId: %d has already used. The message is skipped and removed.",s.messageId),n());};this.log("connect :: sending queued packets"),n();}),this.on("close",()=>{this.log("close :: connected set to `false`"),this.connected=!1,this.log("close :: clearing connackTimer"),clearTimeout(this.connackTimer),this._destroyKeepaliveManager(),this.topicAliasRecv&&this.topicAliasRecv.clear(),this.log("close :: calling _setupReconnect"),this._setupReconnect();}),this.options.manualConnect||(this.log("MqttClient :: setting up stream"),this.connect());}handleAuth(e,r){r();}handleMessage(e,r){r();}_nextId(){return this.messageIdProvider.allocate()}getLastMessageId(){return this.messageIdProvider.getLastAllocated()}connect(){var e;let r=new Yv.Writable,i=Fa.default.parser(this.options),n=null,o=[];this.log("connect :: calling method to clear reconnect"),this._clearReconnect(),this.log("connect :: using streamBuilder provided to client to create stream"),this.stream=this.streamBuilder(this),i.on("packet",h=>{this.log("parser :: on packet push to packets array."),o.push(h);});let s=()=>{this.log("work :: getting next packet in queue");let h=o.shift();if(h)this.log("work :: packet pulled from queue"),(0, Xv.default)(this,h,a);else {this.log("work :: no packets in queue");let d=n;n=null,this.log("work :: done flag is %s",!!d),d&&d();}},a=()=>{if(o.length)(0, is.nextTick)(s);else {let h=n;n=null,h();}};r._write=(h,d,g)=>{n=g,this.log("writable stream :: parsing buffer"),i.parse(h),s();};let u=h=>{this.log("streamErrorHandler :: error",h.message),h.code?(this.log("streamErrorHandler :: emitting error"),this.emit("error",h)):this.noop(h);};this.log("connect :: pipe stream to writable stream"),this.stream.pipe(r),this.stream.on("error",u),this.stream.on("close",()=>{this.log("(%s)stream :: on close",this.options.clientId),this._flushVolatile(),this.log("stream: emit close to MqttClient"),this.emit("close");}),this.log("connect: sending packet `connect`");let c={cmd:"connect",protocolId:this.options.protocolId,protocolVersion:this.options.protocolVersion,clean:this.options.clean,clientId:this.options.clientId,keepalive:this.options.keepalive,username:this.options.username,password:this.options.password,properties:this.options.properties};if(this.options.will&&(c.will=Object.assign(Object.assign({},this.options.will),{payload:(e=this.options.will)===null||e===void 0?void 0:e.payload})),this.topicAliasRecv&&(c.properties||(c.properties={}),this.topicAliasRecv&&(c.properties.topicAliasMaximum=this.topicAliasRecv.max)),this._writePacket(c),i.on("error",this.emit.bind(this,"error")),this.options.properties){if(!this.options.properties.authenticationMethod&&this.options.properties.authenticationData)return this.end(()=>this.emit("error",new Error("Packet has no Authentication Method"))),this;if(this.options.properties.authenticationMethod&&this.options.authPacket&&typeof this.options.authPacket=="object"){let h=Object.assign({cmd:"auth",reasonCode:0},this.options.authPacket);this._writePacket(h);}}return this.stream.setMaxListeners(1e3),clearTimeout(this.connackTimer),this.connackTimer=setTimeout(()=>{this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`"),this.emit("error",new Error("connack timeout")),this._cleanUp(!0);},this.options.connectTimeout),this}publish(e,r,i,n){this.log("publish :: message `%s` to topic `%s`",r,e);let{options:o}=this;typeof i=="function"&&(n=i,i=null),i=i||{},i=Object.assign(Object.assign({},{qos:0,retain:!1,dup:!1}),i);let{qos:a,retain:u,dup:c,properties:h,cbStorePut:d}=i;if(this._checkDisconnecting(n))return this;let g=()=>{let y=0;if((a===1||a===2)&&(y=this._nextId(),y===null))return this.log("No messageId left"),!1;let w={cmd:"publish",topic:e,payload:r,qos:a,retain:u,messageId:y,dup:c};switch(o.protocolVersion===5&&(w.properties=h),this.log("publish :: qos",a),a){case 1:case 2:this.outgoing[w.messageId]={volatile:!1,cb:n||this.noop},this.log("MqttClient:publish: packet cmd: %s",w.cmd),this._sendPacket(w,void 0,d);break;default:this.log("MqttClient:publish: packet cmd: %s",w.cmd),this._sendPacket(w,n,d);break}return !0};return (this._storeProcessing||this._storeProcessingQueue.length>0||!g())&&this._storeProcessingQueue.push({invoke:g,cbStorePut:i.cbStorePut,callback:n}),this}publishAsync(e,r,i){return new Promise((n,o)=>{this.publish(e,r,i,(s,a)=>{s?o(s):n(a);});})}subscribe(e,r,i){let n=this.options.protocolVersion;typeof r=="function"&&(i=r),i=i||this.noop;let o=!1,s=[];typeof e=="string"?(e=[e],s=e):Array.isArray(e)?s=e:typeof e=="object"&&(o=e.resubscribe,delete e.resubscribe,s=Object.keys(e));let a=jp.validateTopics(s);if(a!==null)return Wa(i,new Error(`Invalid topic ${a}`)),this;if(this._checkDisconnecting(i))return this.log("subscribe: discconecting true"),this;let u={qos:0};n===5&&(u.nl=!1,u.rap=!1,u.rh=0),r=Object.assign(Object.assign({},u),r);let c=r.properties,h=[],d=(y,w)=>{if(w=w||r,!Object.prototype.hasOwnProperty.call(this._resubscribeTopics,y)||this._resubscribeTopics[y].qos<w.qos||o){let E={topic:y,qos:w.qos};n===5&&(E.nl=w.nl,E.rap=w.rap,E.rh=w.rh,E.properties=c),this.log("subscribe: pushing topic `%s` and qos `%s` to subs list",E.topic,E.qos),h.push(E);}};if(Array.isArray(e)?e.forEach(y=>{this.log("subscribe: array topic %s",y),d(y);}):Object.keys(e).forEach(y=>{this.log("subscribe: object topic %s, %o",y,e[y]),d(y,e[y]);}),!h.length)return i(null,[]),this;let g=()=>{let y=this._nextId();if(y===null)return this.log("No messageId left"),!1;let w={cmd:"subscribe",subscriptions:h,messageId:y};if(c&&(w.properties=c),this.options.resubscribe){this.log("subscribe :: resubscribe true");let E=[];h.forEach(S=>{if(this.options.reconnectPeriod>0){let I={qos:S.qos};n===5&&(I.nl=S.nl||!1,I.rap=S.rap||!1,I.rh=S.rh||0,I.properties=S.properties),this._resubscribeTopics[S.topic]=I,E.push(S.topic);}}),this.messageIdToTopic[w.messageId]=E;}return this.outgoing[w.messageId]={volatile:!0,cb(E,S){if(!E){let{granted:I}=S;for(let B=0;B<I.length;B+=1)h[B].qos=I[B];}i(E,h);}},this.log("subscribe :: call _sendPacket"),this._sendPacket(w),!0};return (this._storeProcessing||this._storeProcessingQueue.length>0||!g())&&this._storeProcessingQueue.push({invoke:g,callback:i}),this}subscribeAsync(e,r){return new Promise((i,n)=>{this.subscribe(e,r,(o,s)=>{o?n(o):i(s);});})}unsubscribe(e,r,i){typeof e=="string"&&(e=[e]),typeof r=="function"&&(i=r),i=i||this.noop;let n=jp.validateTopics(e);if(n!==null)return Wa(i,new Error(`Invalid topic ${n}`)),this;if(this._checkDisconnecting(i))return this;let o=()=>{let s=this._nextId();if(s===null)return this.log("No messageId left"),!1;let a={cmd:"unsubscribe",messageId:s,unsubscriptions:[]};return typeof e=="string"?a.unsubscriptions=[e]:Array.isArray(e)&&(a.unsubscriptions=e),this.options.resubscribe&&a.unsubscriptions.forEach(u=>{delete this._resubscribeTopics[u];}),typeof r=="object"&&r.properties&&(a.properties=r.properties),this.outgoing[a.messageId]={volatile:!0,cb:i},this.log("unsubscribe: call _sendPacket"),this._sendPacket(a),!0};return (this._storeProcessing||this._storeProcessingQueue.length>0||!o())&&this._storeProcessingQueue.push({invoke:o,callback:i}),this}unsubscribeAsync(e,r){return new Promise((i,n)=>{this.unsubscribe(e,r,(o,s)=>{o?n(o):i(s);});})}end(e,r,i){this.log("end :: (%s)",this.options.clientId),(e==null||typeof e!="boolean")&&(i=i||r,r=e,e=!1),typeof r!="object"&&(i=i||r,r=null),this.log("end :: cb? %s",!!i),(!i||typeof i!="function")&&(i=this.noop);let n=()=>{this.log("end :: closeStores: closing incoming and outgoing stores"),this.disconnected=!0,this.incomingStore.close(s=>{this.outgoingStore.close(a=>{if(this.log("end :: closeStores: emitting end"),this.emit("end"),i){let u=s||a;this.log("end :: closeStores: invoking callback with args"),i(u);}});}),this._deferredReconnect&&this._deferredReconnect();},o=()=>{this.log("end :: (%s) :: finish :: calling _cleanUp with force %s",this.options.clientId,e),this._cleanUp(e,()=>{this.log("end :: finish :: calling process.nextTick on closeStores"),(0, is.nextTick)(n);},r);};return this.disconnecting?(i(),this):(this._clearReconnect(),this.disconnecting=!0,!e&&Object.keys(this.outgoing).length>0?(this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty",this.options.clientId),this.once("outgoingEmpty",setTimeout.bind(null,o,10))):(this.log("end :: (%s) :: immediately calling finish",this.options.clientId),o()),this)}endAsync(e,r){return new Promise((i,n)=>{this.end(e,r,o=>{o?n(o):i();});})}removeOutgoingMessage(e){if(this.outgoing[e]){let{cb:r}=this.outgoing[e];this._removeOutgoingAndStoreMessage(e,()=>{r(new Error("Message removed"));});}return this}reconnect(e){this.log("client reconnect");let r=()=>{e?(this.options.incomingStore=e.incomingStore,this.options.outgoingStore=e.outgoingStore):(this.options.incomingStore=null,this.options.outgoingStore=null),this.incomingStore=this.options.incomingStore||new rs.default,this.outgoingStore=this.options.outgoingStore||new rs.default,this.disconnecting=!1,this.disconnected=!1,this._deferredReconnect=null,this._reconnect();};return this.disconnecting&&!this.disconnected?this._deferredReconnect=r:r(),this}_flushVolatile(){this.outgoing&&(this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"),Object.keys(this.outgoing).forEach(e=>{this.outgoing[e].volatile&&typeof this.outgoing[e].cb=="function"&&(this.outgoing[e].cb(new Error("Connection closed")),delete this.outgoing[e]);}));}_flush(){this.outgoing&&(this.log("_flush: queue exists? %b",!!this.outgoing),Object.keys(this.outgoing).forEach(e=>{typeof this.outgoing[e].cb=="function"&&(this.outgoing[e].cb(new Error("Connection closed")),delete this.outgoing[e]);}));}_removeTopicAliasAndRecoverTopicName(e){let r;e.properties&&(r=e.properties.topicAlias);let i=e.topic.toString();if(this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o",r,i),i.length===0){if(typeof r>"u")return new Error("Unregistered Topic Alias");if(i=this.topicAliasSend.getTopicByAlias(r),typeof i>"u")return new Error("Unregistered Topic Alias");e.topic=i;}r&&delete e.properties.topicAlias;}_checkDisconnecting(e){return this.disconnecting&&(e&&e!==this.noop?e(new Error("client disconnecting")):this.emit("error",new Error("client disconnecting"))),this.disconnecting}_reconnect(){this.log("_reconnect: emitting reconnect to client"),this.emit("reconnect"),this.connected?(this.end(()=>{this.connect();}),this.log("client already connected. disconnecting first.")):(this.log("_reconnect: calling connect"),this.connect());}_setupReconnect(){!this.disconnecting&&!this.reconnectTimer&&this.options.reconnectPeriod>0?(this.reconnecting||(this.log("_setupReconnect :: emit `offline` state"),this.emit("offline"),this.log("_setupReconnect :: set `reconnecting` to `true`"),this.reconnecting=!0),this.log("_setupReconnect :: setting reconnectTimer for %d ms",this.options.reconnectPeriod),this.reconnectTimer=setInterval(()=>{this.log("reconnectTimer :: reconnect triggered!"),this._reconnect();},this.options.reconnectPeriod)):this.log("_setupReconnect :: doing nothing...");}_clearReconnect(){this.log("_clearReconnect : clearing reconnect timer"),this.reconnectTimer&&(clearInterval(this.reconnectTimer),this.reconnectTimer=null);}_cleanUp(e,r,i={}){if(r&&(this.log("_cleanUp :: done callback provided for on stream close"),this.stream.on("close",r)),this.log("_cleanUp :: forced? %s",e),e)this.options.reconnectPeriod===0&&this.options.clean&&this._flush(),this.log("_cleanUp :: (%s) :: destroying stream",this.options.clientId),this.stream.destroy();else {let n=Object.assign({cmd:"disconnect"},i);this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet",this.options.clientId),this._sendPacket(n,()=>{this.log("_cleanUp :: (%s) :: destroying stream",this.options.clientId),Wa(()=>{this.stream.end(()=>{this.log("_cleanUp :: (%s) :: stream destroyed",this.options.clientId);});});});}!this.disconnecting&&!this.reconnecting&&(this.log("_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect."),this._clearReconnect(),this._setupReconnect()),this._destroyKeepaliveManager(),r&&!this.connected&&(this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener",this.options.clientId),this.stream.removeListener("close",r),r());}_storeAndSend(e,r,i){this.log("storeAndSend :: store packet with cmd %s to outgoingStore",e.cmd);let n=e,o;if(n.cmd==="publish"&&(n=(0, Dp.default)(e),o=this._removeTopicAliasAndRecoverTopicName(n),o))return r&&r(o);this.outgoingStore.put(n,s=>{if(s)return r&&r(s);i(),this._writePacket(e,r);});}_applyTopicAlias(e){if(this.options.protocolVersion===5&&e.cmd==="publish"){let r;e.properties&&(r=e.properties.topicAlias);let i=e.topic.toString();if(this.topicAliasSend)if(r){if(i.length!==0&&(this.log("applyTopicAlias :: register topic: %s - alias: %d",i,r),!this.topicAliasSend.put(i,r)))return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d",i,r),new Error("Sending Topic Alias out of range")}else i.length!==0&&(this.options.autoAssignTopicAlias?(r=this.topicAliasSend.getAliasByTopic(i),r?(e.topic="",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d",i,r)):(r=this.topicAliasSend.getLruAlias(),this.topicAliasSend.put(i,r),e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log("applyTopicAlias :: auto assign topic: %s - alias: %d",i,r))):this.options.autoUseTopicAlias&&(r=this.topicAliasSend.getAliasByTopic(i),r&&(e.topic="",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log("applyTopicAlias :: auto use topic: %s - alias: %d",i,r))));else if(r)return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d",i,r),new Error("Sending Topic Alias out of range")}}_noop(e){this.log("noop ::",e);}_writePacket(e,r){this.log("_writePacket :: packet: %O",e),this.log("_writePacket :: emitting `packetsend`"),this.emit("packetsend",e),this.log("_writePacket :: writing to stream");let i=Fa.default.writeToStream(e,this.stream,this.options);this.log("_writePacket :: writeToStream result %s",i),!i&&r&&r!==this.noop?(this.log("_writePacket :: handle events on `drain` once through callback."),this.stream.once("drain",r)):r&&(this.log("_writePacket :: invoking cb"),r());}_sendPacket(e,r,i,n){this.log("_sendPacket :: (%s) ::  start",this.options.clientId),i=i||this.noop,r=r||this.noop;let o=this._applyTopicAlias(e);if(o){r(o);return}if(!this.connected){if(e.cmd==="auth"){this._writePacket(e,r);return}this.log("_sendPacket :: client not connected. Storing packet offline."),this._storePacket(e,r,i);return}if(n){this._writePacket(e,r);return}switch(e.cmd){case"publish":break;case"pubrel":this._storeAndSend(e,r,i);return;default:this._writePacket(e,r);return}switch(e.qos){case 2:case 1:this._storeAndSend(e,r,i);break;case 0:default:this._writePacket(e,r);break}this.log("_sendPacket :: (%s) ::  end",this.options.clientId);}_storePacket(e,r,i){this.log("_storePacket :: packet: %o",e),this.log("_storePacket :: cb? %s",!!r),i=i||this.noop;let n=e;if(n.cmd==="publish"){n=(0, Dp.default)(e);let s=this._removeTopicAliasAndRecoverTopicName(n);if(s)return r&&r(s)}let o=n.qos||0;o===0&&this.queueQoSZero||n.cmd!=="publish"?this.queue.push({packet:n,cb:r}):o>0?(r=this.outgoing[n.messageId]?this.outgoing[n.messageId].cb:null,this.outgoingStore.put(n,s=>{if(s)return r&&r(s);i();})):r&&r(new Error("No connection to broker"));}_setupKeepaliveManager(){this.log("_setupKeepaliveManager :: keepalive %d (seconds)",this.options.keepalive),!this.keepaliveManager&&this.options.keepalive&&(this.keepaliveManager=new eE.default(this,this.options.timerVariant));}_destroyKeepaliveManager(){this.keepaliveManager&&(this.log("_destroyKeepaliveManager :: destroying keepalive manager"),this.keepaliveManager.destroy(),this.keepaliveManager=null);}reschedulePing(){this.keepaliveManager&&this.options.keepalive&&this.options.reschedulePings&&this._reschedulePing();}_reschedulePing(){this.log("_reschedulePing :: rescheduling ping"),this.keepaliveManager.reschedule();}sendPing(){this.log("_sendPing :: sending pingreq"),this._sendPacket({cmd:"pingreq"});}onKeepaliveTimeout(){this.emit("error",new Error("Keepalive timeout")),this.log("onKeepaliveTimeout :: calling _cleanUp with force true"),this._cleanUp(!0);}_resubscribe(){this.log("_resubscribe");let e=Object.keys(this._resubscribeTopics);if(!this._firstConnection&&(this.options.clean||this.options.protocolVersion>=4&&!this.connackPacket.sessionPresent)&&e.length>0)if(this.options.resubscribe)if(this.options.protocolVersion===5){this.log("_resubscribe: protocolVersion 5");for(let r=0;r<e.length;r++){let i={};i[e[r]]=this._resubscribeTopics[e[r]],i.resubscribe=!0,this.subscribe(i,{properties:i[e[r]].properties});}}else this._resubscribeTopics.resubscribe=!0,this.subscribe(this._resubscribeTopics);else this._resubscribeTopics={};this._firstConnection=!1;}_onConnect(e){if(this.disconnected){this.emit("connect",e);return}this.connackPacket=e,this.messageIdProvider.clear(),this._setupKeepaliveManager(),this.connected=!0;let r=()=>{let i=this.outgoingStore.createStream(),n=()=>{i.destroy(),i=null,this._flushStoreProcessingQueue(),o();},o=()=>{this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={};};this.once("close",n),i.on("error",a=>{o(),this._flushStoreProcessingQueue(),this.removeListener("close",n),this.emit("error",a);});let s=()=>{if(!i)return;let a=i.read(1),u;if(!a){i.once("readable",s);return}if(this._storeProcessing=!0,this._packetIdsDuringStoreProcessing[a.messageId]){s();return}!this.disconnecting&&!this.reconnectTimer?(u=this.outgoing[a.messageId]?this.outgoing[a.messageId].cb:null,this.outgoing[a.messageId]={volatile:!1,cb(c,h){u&&u(c,h),s();}},this._packetIdsDuringStoreProcessing[a.messageId]=!0,this.messageIdProvider.register(a.messageId)?this._sendPacket(a,void 0,void 0,!0):this.log("messageId: %d has already used.",a.messageId)):i.destroy&&i.destroy();};i.on("end",()=>{let a=!0;for(let u in this._packetIdsDuringStoreProcessing)if(!this._packetIdsDuringStoreProcessing[u]){a=!1;break}this.removeListener("close",n),a?(o(),this._invokeAllStoreProcessingQueue(),this.emit("connect",e)):r();}),s();};r();}_invokeStoreProcessingQueue(){if(!this._storeProcessing&&this._storeProcessingQueue.length>0){let e=this._storeProcessingQueue[0];if(e&&e.invoke())return this._storeProcessingQueue.shift(),!0}return !1}_invokeAllStoreProcessingQueue(){for(;this._invokeStoreProcessingQueue(););}_flushStoreProcessingQueue(){for(let e of this._storeProcessingQueue)e.cbStorePut&&e.cbStorePut(new Error("Connection closed")),e.callback&&e.callback(new Error("Connection closed"));this._storeProcessingQueue.splice(0);}_removeOutgoingAndStoreMessage(e,r){delete this.outgoing[e],this.outgoingStore.del({messageId:e},(i,n)=>{r(i,n),this.messageIdProvider.deallocate(e),this._invokeStoreProcessingQueue();});}};ns.VERSION=is.MQTTJS_VERSION;Qe.default=ns;});var Hp=M(Ha=>{v();m();_();Object.defineProperty(Ha,"__esModule",{value:!0});var tE=Ma(),$a=class{constructor(){this.numberAllocator=new tE.NumberAllocator(1,65535);}allocate(){return this.lastId=this.numberAllocator.alloc(),this.lastId}getLastAllocated(){return this.lastId}register(e){return this.numberAllocator.use(e)}deallocate(e){this.numberAllocator.free(e);}clear(){this.numberAllocator.clear();}};Ha.default=$a;});function Ir(t){throw new RangeError(sE[t])}function Vp(t,e){let r=t.split("@"),i="";r.length>1&&(i=r[0]+"@",t=r[1]);let n=function(o,s){let a=[],u=o.length;for(;u--;)a[u]=s(o[u]);return a}((t=t.replace(nE,".")).split("."),e).join(".");return i+n}function Qp(t){let e=[],r=0,i=t.length;for(;r<i;){let n=t.charCodeAt(r++);if(n>=55296&&n<=56319&&r<i){let o=t.charCodeAt(r++);(64512&o)==56320?e.push(((1023&n)<<10)+(1023&o)+65536):(e.push(n),r--);}else e.push(n);}return e}var rE,iE,nE,sE,dt,Va,zp,Yp,Kp,Gp,zt,Jp=we(()=>{v();m();_();rE=/^xn--/,iE=/[^\0-\x7E]/,nE=/[\x2E\u3002\uFF0E\uFF61]/g,sE={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},dt=Math.floor,Va=String.fromCharCode;zp=function(t,e){return t+22+75*(t<26)-((e!=0)<<5)},Yp=function(t,e,r){let i=0;for(t=r?dt(t/700):t>>1,t+=dt(t/e);t>455;i+=36)t=dt(t/35);return dt(i+36*t/(t+38))},Kp=function(t){let e=[],r=t.length,i=0,n=128,o=72,s=t.lastIndexOf("-");s<0&&(s=0);for(let u=0;u<s;++u)t.charCodeAt(u)>=128&&Ir("not-basic"),e.push(t.charCodeAt(u));for(let u=s>0?s+1:0;u<r;){let c=i;for(let d=1,g=36;;g+=36){u>=r&&Ir("invalid-input");let y=(a=t.charCodeAt(u++))-48<10?a-22:a-65<26?a-65:a-97<26?a-97:36;(y>=36||y>dt((2147483647-i)/d))&&Ir("overflow"),i+=y*d;let w=g<=o?1:g>=o+26?26:g-o;if(y<w)break;let E=36-w;d>dt(2147483647/E)&&Ir("overflow"),d*=E;}let h=e.length+1;o=Yp(i-c,h,c==0),dt(i/h)>2147483647-n&&Ir("overflow"),n+=dt(i/h),i%=h,e.splice(i++,0,n);}var a;return String.fromCodePoint(...e)},Gp=function(t){let e=[],r=(t=Qp(t)).length,i=128,n=0,o=72;for(let u of t)u<128&&e.push(Va(u));let s=e.length,a=s;for(s&&e.push("-");a<r;){let u=2147483647;for(let h of t)h>=i&&h<u&&(u=h);let c=a+1;u-i>dt((2147483647-n)/c)&&Ir("overflow"),n+=(u-i)*c,i=u;for(let h of t)if(h<i&&++n>2147483647&&Ir("overflow"),h==i){let d=n;for(let g=36;;g+=36){let y=g<=o?1:g>=o+26?26:g-o;if(d<y)break;let w=d-y,E=36-y;e.push(Va(zp(y+w%E,0))),d=dt(w/E);}e.push(Va(zp(d,0))),o=Yp(n,c,a==s),n=0,++a;}++n,++i;}return e.join("")},zt={version:"2.1.0",ucs2:{decode:Qp,encode:t=>String.fromCodePoint(...t)},decode:Kp,encode:Gp,toASCII:function(t){return Vp(t,function(e){return iE.test(e)?"xn--"+Gp(e):e})},toUnicode:function(t){return Vp(t,function(e){return rE.test(e)?Kp(e.slice(4).toLowerCase()):e})}};zt.decode;zt.encode;zt.toASCII;zt.toUnicode;zt.ucs2;zt.version;});function oE(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var aE,Oi,lE,pt,Xp=we(()=>{v();m();_();aE=function(t,e,r,i){e=e||"&",r=r||"=";var n={};if(typeof t!="string"||t.length===0)return n;var o=/\+/g;t=t.split(e);var s=1e3;i&&typeof i.maxKeys=="number"&&(s=i.maxKeys);var a=t.length;s>0&&a>s&&(a=s);for(var u=0;u<a;++u){var c,h,d,g,y=t[u].replace(o,"%20"),w=y.indexOf(r);w>=0?(c=y.substr(0,w),h=y.substr(w+1)):(c=y,h=""),d=decodeURIComponent(c),g=decodeURIComponent(h),oE(n,d)?Array.isArray(n[d])?n[d].push(g):n[d]=[n[d],g]:n[d]=g;}return n},Oi=function(t){switch(typeof t){case"string":return t;case"boolean":return t?"true":"false";case"number":return isFinite(t)?t:"";default:return ""}},lE=function(t,e,r,i){return e=e||"&",r=r||"=",t===null&&(t=void 0),typeof t=="object"?Object.keys(t).map(function(n){var o=encodeURIComponent(Oi(n))+r;return Array.isArray(t[n])?t[n].map(function(s){return o+encodeURIComponent(Oi(s))}).join(e):o+encodeURIComponent(Oi(t[n]))}).join(e):i?encodeURIComponent(Oi(i))+r+encodeURIComponent(Oi(t)):""},pt={};pt.decode=pt.parse=aE,pt.encode=pt.stringify=lE;pt.decode;pt.encode;pt.parse;pt.stringify;});function za(){throw new Error("setTimeout has not been defined")}function Ka(){throw new Error("clearTimeout has not been defined")}function tg(t){if(Pt===setTimeout)return setTimeout(t,0);if((Pt===za||!Pt)&&setTimeout)return Pt=setTimeout,setTimeout(t,0);try{return Pt(t,0)}catch{try{return Pt.call(null,t,0)}catch{return Pt.call(this||ii,t,0)}}}function uE(){ri&&Tr&&(ri=!1,Tr.length?Ot=Tr.concat(Ot):os=-1,Ot.length&&rg());}function rg(){if(!ri){var t=tg(uE);ri=!0;for(var e=Ot.length;e;){for(Tr=Ot,Ot=[];++os<e;)Tr&&Tr[os].run();os=-1,e=Ot.length;}Tr=null,ri=!1,function(r){if(kt===clearTimeout)return clearTimeout(r);if((kt===Ka||!kt)&&clearTimeout)return kt=clearTimeout,clearTimeout(r);try{kt(r);}catch{try{return kt.call(null,r)}catch{return kt.call(this||ii,r)}}}(t);}}function Zp(t,e){(this||ii).fun=t,(this||ii).array=e;}function Bt(){}var eg,Pt,kt,ii,fe,Tr,Ot,ri,os,ne,ig=we(()=>{v();m();_();ii=typeof globalThis<"u"?globalThis:typeof self<"u"?self:global,fe=eg={};(function(){try{Pt=typeof setTimeout=="function"?setTimeout:za;}catch{Pt=za;}try{kt=typeof clearTimeout=="function"?clearTimeout:Ka;}catch{kt=Ka;}})();Ot=[],ri=!1,os=-1;fe.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];Ot.push(new Zp(t,e)),Ot.length!==1||ri||tg(rg);},Zp.prototype.run=function(){(this||ii).fun.apply(null,(this||ii).array);},fe.title="browser",fe.browser=!0,fe.env={},fe.argv=[],fe.version="",fe.versions={},fe.on=Bt,fe.addListener=Bt,fe.once=Bt,fe.off=Bt,fe.removeListener=Bt,fe.removeAllListeners=Bt,fe.emit=Bt,fe.prependListener=Bt,fe.prependOnceListener=Bt,fe.listeners=function(t){return []},fe.binding=function(t){throw new Error("process.binding is not supported")},fe.cwd=function(){return "/"},fe.chdir=function(t){throw new Error("process.chdir is not supported")},fe.umask=function(){return 0};ne=eg;ne.addListener;ne.argv;ne.binding;ne.browser;ne.chdir;ne.cwd;ne.emit;ne.env;ne.listeners;ne.nextTick;ne.off;ne.on;ne.once;ne.prependListener;ne.prependOnceListener;ne.removeAllListeners;ne.removeListener;ne.title;ne.umask;ne.version;ne.versions;});function fE(){if(ng)return Ga;ng=!0;var t=Ga={},e,r;function i(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?e=setTimeout:e=i;}catch{e=i;}try{typeof clearTimeout=="function"?r=clearTimeout:r=n;}catch{r=n;}})();function o(E){if(e===setTimeout)return setTimeout(E,0);if((e===i||!e)&&setTimeout)return e=setTimeout,setTimeout(E,0);try{return e(E,0)}catch{try{return e.call(null,E,0)}catch{return e.call(this||ni,E,0)}}}function s(E){if(r===clearTimeout)return clearTimeout(E);if((r===n||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(E);try{return r(E)}catch{try{return r.call(null,E)}catch{return r.call(this||ni,E)}}}var a=[],u=!1,c,h=-1;function d(){!u||!c||(u=!1,c.length?a=c.concat(a):h=-1,a.length&&g());}function g(){if(!u){var E=o(d);u=!0;for(var S=a.length;S;){for(c=a,a=[];++h<S;)c&&c[h].run();h=-1,S=a.length;}c=null,u=!1,s(E);}}t.nextTick=function(E){var S=new Array(arguments.length-1);if(arguments.length>1)for(var I=1;I<arguments.length;I++)S[I-1]=arguments[I];a.push(new y(E,S)),a.length===1&&!u&&o(g);};function y(E,S){(this||ni).fun=E,(this||ni).array=S;}y.prototype.run=function(){(this||ni).fun.apply(null,(this||ni).array);},t.title="browser",t.browser=!0,t.env={},t.argv=[],t.version="",t.versions={};function w(){}return t.on=w,t.addListener=w,t.once=w,t.off=w,t.removeListener=w,t.removeAllListeners=w,t.emit=w,t.prependListener=w,t.prependOnceListener=w,t.listeners=function(E){return []},t.binding=function(E){throw new Error("process.binding is not supported")},t.cwd=function(){return "/"},t.chdir=function(E){throw new Error("process.chdir is not supported")},t.umask=function(){return 0},Ga}var Ga,ng,ni,re,Qa=we(()=>{v();m();_();Ga={},ng=!1,ni=typeof globalThis<"u"?globalThis:typeof self<"u"?self:global;re=fE();re.platform="browser";re.addListener;re.argv;re.binding;re.browser;re.chdir;re.cwd;re.emit;re.env;re.listeners;re.nextTick;re.off;re.on;re.once;re.prependListener;re.prependOnceListener;re.removeAllListeners;re.removeListener;re.title;re.umask;re.version;re.versions;});function cE(){if(sg)return Ya;sg=!0;var t=re;function e(o){if(typeof o!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(o))}function r(o,s){for(var a="",u=0,c=-1,h=0,d,g=0;g<=o.length;++g){if(g<o.length)d=o.charCodeAt(g);else {if(d===47)break;d=47;}if(d===47){if(!(c===g-1||h===1))if(c!==g-1&&h===2){if(a.length<2||u!==2||a.charCodeAt(a.length-1)!==46||a.charCodeAt(a.length-2)!==46){if(a.length>2){var y=a.lastIndexOf("/");if(y!==a.length-1){y===-1?(a="",u=0):(a=a.slice(0,y),u=a.length-1-a.lastIndexOf("/")),c=g,h=0;continue}}else if(a.length===2||a.length===1){a="",u=0,c=g,h=0;continue}}s&&(a.length>0?a+="/..":a="..",u=2);}else a.length>0?a+="/"+o.slice(c+1,g):a=o.slice(c+1,g),u=g-c-1;c=g,h=0;}else d===46&&h!==-1?++h:h=-1;}return a}function i(o,s){var a=s.dir||s.root,u=s.base||(s.name||"")+(s.ext||"");return a?a===s.root?a+u:a+o+u:u}var n={resolve:function(){for(var s="",a=!1,u,c=arguments.length-1;c>=-1&&!a;c--){var h;c>=0?h=arguments[c]:(u===void 0&&(u=t.cwd()),h=u),e(h),h.length!==0&&(s=h+"/"+s,a=h.charCodeAt(0)===47);}return s=r(s,!a),a?s.length>0?"/"+s:"/":s.length>0?s:"."},normalize:function(s){if(e(s),s.length===0)return ".";var a=s.charCodeAt(0)===47,u=s.charCodeAt(s.length-1)===47;return s=r(s,!a),s.length===0&&!a&&(s="."),s.length>0&&u&&(s+="/"),a?"/"+s:s},isAbsolute:function(s){return e(s),s.length>0&&s.charCodeAt(0)===47},join:function(){if(arguments.length===0)return ".";for(var s,a=0;a<arguments.length;++a){var u=arguments[a];e(u),u.length>0&&(s===void 0?s=u:s+="/"+u);}return s===void 0?".":n.normalize(s)},relative:function(s,a){if(e(s),e(a),s===a||(s=n.resolve(s),a=n.resolve(a),s===a))return "";for(var u=1;u<s.length&&s.charCodeAt(u)===47;++u);for(var c=s.length,h=c-u,d=1;d<a.length&&a.charCodeAt(d)===47;++d);for(var g=a.length,y=g-d,w=h<y?h:y,E=-1,S=0;S<=w;++S){if(S===w){if(y>w){if(a.charCodeAt(d+S)===47)return a.slice(d+S+1);if(S===0)return a.slice(d+S)}else h>w&&(s.charCodeAt(u+S)===47?E=S:S===0&&(E=0));break}var I=s.charCodeAt(u+S),B=a.charCodeAt(d+S);if(I!==B)break;I===47&&(E=S);}var R="";for(S=u+E+1;S<=c;++S)(S===c||s.charCodeAt(S)===47)&&(R.length===0?R+="..":R+="/..");return R.length>0?R+a.slice(d+E):(d+=E,a.charCodeAt(d)===47&&++d,a.slice(d))},_makeLong:function(s){return s},dirname:function(s){if(e(s),s.length===0)return ".";for(var a=s.charCodeAt(0),u=a===47,c=-1,h=!0,d=s.length-1;d>=1;--d)if(a=s.charCodeAt(d),a===47){if(!h){c=d;break}}else h=!1;return c===-1?u?"/":".":u&&c===1?"//":s.slice(0,c)},basename:function(s,a){if(a!==void 0&&typeof a!="string")throw new TypeError('"ext" argument must be a string');e(s);var u=0,c=-1,h=!0,d;if(a!==void 0&&a.length>0&&a.length<=s.length){if(a.length===s.length&&a===s)return "";var g=a.length-1,y=-1;for(d=s.length-1;d>=0;--d){var w=s.charCodeAt(d);if(w===47){if(!h){u=d+1;break}}else y===-1&&(h=!1,y=d+1),g>=0&&(w===a.charCodeAt(g)?--g===-1&&(c=d):(g=-1,c=y));}return u===c?c=y:c===-1&&(c=s.length),s.slice(u,c)}else {for(d=s.length-1;d>=0;--d)if(s.charCodeAt(d)===47){if(!h){u=d+1;break}}else c===-1&&(h=!1,c=d+1);return c===-1?"":s.slice(u,c)}},extname:function(s){e(s);for(var a=-1,u=0,c=-1,h=!0,d=0,g=s.length-1;g>=0;--g){var y=s.charCodeAt(g);if(y===47){if(!h){u=g+1;break}continue}c===-1&&(h=!1,c=g+1),y===46?a===-1?a=g:d!==1&&(d=1):a!==-1&&(d=-1);}return a===-1||c===-1||d===0||d===1&&a===c-1&&a===u+1?"":s.slice(a,c)},format:function(s){if(s===null||typeof s!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof s);return i("/",s)},parse:function(s){e(s);var a={root:"",dir:"",base:"",ext:"",name:""};if(s.length===0)return a;var u=s.charCodeAt(0),c=u===47,h;c?(a.root="/",h=1):h=0;for(var d=-1,g=0,y=-1,w=!0,E=s.length-1,S=0;E>=h;--E){if(u=s.charCodeAt(E),u===47){if(!w){g=E+1;break}continue}y===-1&&(w=!1,y=E+1),u===46?d===-1?d=E:S!==1&&(S=1):d!==-1&&(S=-1);}return d===-1||y===-1||S===0||S===1&&d===y-1&&d===g+1?y!==-1&&(g===0&&c?a.base=a.name=s.slice(1,y):a.base=a.name=s.slice(g,y)):(g===0&&c?(a.name=s.slice(1,d),a.base=s.slice(1,y)):(a.name=s.slice(g,d),a.base=s.slice(g,y)),a.ext=s.slice(d,y)),g>0?a.dir=s.slice(0,g-1):c&&(a.dir="/"),a},sep:"/",delimiter:":",win32:null,posix:null};return n.posix=n,Ya=n,Ya}var Ya,sg,Ja,og=we(()=>{v();m();_();Qa();Ya={},sg=!1;Ja=cE();});var pg={};Qt(pg,{URL:()=>FE,Url:()=>UE,default:()=>Z,fileURLToPath:()=>hg,format:()=>NE,parse:()=>jE,pathToFileURL:()=>dg,resolve:()=>qE,resolveObject:()=>DE});function Fe(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null;}function xi(t,e,r){if(t&&gt.isObject(t)&&t instanceof Fe)return t;var i=new Fe;return i.parse(t,e,r),i}function _E(){if(fg)return el;fg=!0;var t=ne;function e(o){if(typeof o!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(o))}function r(o,s){for(var a="",u=0,c=-1,h=0,d,g=0;g<=o.length;++g){if(g<o.length)d=o.charCodeAt(g);else {if(d===47)break;d=47;}if(d===47){if(!(c===g-1||h===1))if(c!==g-1&&h===2){if(a.length<2||u!==2||a.charCodeAt(a.length-1)!==46||a.charCodeAt(a.length-2)!==46){if(a.length>2){var y=a.lastIndexOf("/");if(y!==a.length-1){y===-1?(a="",u=0):(a=a.slice(0,y),u=a.length-1-a.lastIndexOf("/")),c=g,h=0;continue}}else if(a.length===2||a.length===1){a="",u=0,c=g,h=0;continue}}s&&(a.length>0?a+="/..":a="..",u=2);}else a.length>0?a+="/"+o.slice(c+1,g):a=o.slice(c+1,g),u=g-c-1;c=g,h=0;}else d===46&&h!==-1?++h:h=-1;}return a}function i(o,s){var a=s.dir||s.root,u=s.base||(s.name||"")+(s.ext||"");return a?a===s.root?a+u:a+o+u:u}var n={resolve:function(){for(var s="",a=!1,u,c=arguments.length-1;c>=-1&&!a;c--){var h;c>=0?h=arguments[c]:(u===void 0&&(u=t.cwd()),h=u),e(h),h.length!==0&&(s=h+"/"+s,a=h.charCodeAt(0)===47);}return s=r(s,!a),a?s.length>0?"/"+s:"/":s.length>0?s:"."},normalize:function(s){if(e(s),s.length===0)return ".";var a=s.charCodeAt(0)===47,u=s.charCodeAt(s.length-1)===47;return s=r(s,!a),s.length===0&&!a&&(s="."),s.length>0&&u&&(s+="/"),a?"/"+s:s},isAbsolute:function(s){return e(s),s.length>0&&s.charCodeAt(0)===47},join:function(){if(arguments.length===0)return ".";for(var s,a=0;a<arguments.length;++a){var u=arguments[a];e(u),u.length>0&&(s===void 0?s=u:s+="/"+u);}return s===void 0?".":n.normalize(s)},relative:function(s,a){if(e(s),e(a),s===a||(s=n.resolve(s),a=n.resolve(a),s===a))return "";for(var u=1;u<s.length&&s.charCodeAt(u)===47;++u);for(var c=s.length,h=c-u,d=1;d<a.length&&a.charCodeAt(d)===47;++d);for(var g=a.length,y=g-d,w=h<y?h:y,E=-1,S=0;S<=w;++S){if(S===w){if(y>w){if(a.charCodeAt(d+S)===47)return a.slice(d+S+1);if(S===0)return a.slice(d+S)}else h>w&&(s.charCodeAt(u+S)===47?E=S:S===0&&(E=0));break}var I=s.charCodeAt(u+S),B=a.charCodeAt(d+S);if(I!==B)break;I===47&&(E=S);}var R="";for(S=u+E+1;S<=c;++S)(S===c||s.charCodeAt(S)===47)&&(R.length===0?R+="..":R+="/..");return R.length>0?R+a.slice(d+E):(d+=E,a.charCodeAt(d)===47&&++d,a.slice(d))},_makeLong:function(s){return s},dirname:function(s){if(e(s),s.length===0)return ".";for(var a=s.charCodeAt(0),u=a===47,c=-1,h=!0,d=s.length-1;d>=1;--d)if(a=s.charCodeAt(d),a===47){if(!h){c=d;break}}else h=!1;return c===-1?u?"/":".":u&&c===1?"//":s.slice(0,c)},basename:function(s,a){if(a!==void 0&&typeof a!="string")throw new TypeError('"ext" argument must be a string');e(s);var u=0,c=-1,h=!0,d;if(a!==void 0&&a.length>0&&a.length<=s.length){if(a.length===s.length&&a===s)return "";var g=a.length-1,y=-1;for(d=s.length-1;d>=0;--d){var w=s.charCodeAt(d);if(w===47){if(!h){u=d+1;break}}else y===-1&&(h=!1,y=d+1),g>=0&&(w===a.charCodeAt(g)?--g===-1&&(c=d):(g=-1,c=y));}return u===c?c=y:c===-1&&(c=s.length),s.slice(u,c)}else {for(d=s.length-1;d>=0;--d)if(s.charCodeAt(d)===47){if(!h){u=d+1;break}}else c===-1&&(h=!1,c=d+1);return c===-1?"":s.slice(u,c)}},extname:function(s){e(s);for(var a=-1,u=0,c=-1,h=!0,d=0,g=s.length-1;g>=0;--g){var y=s.charCodeAt(g);if(y===47){if(!h){u=g+1;break}continue}c===-1&&(h=!1,c=g+1),y===46?a===-1?a=g:d!==1&&(d=1):a!==-1&&(d=-1);}return a===-1||c===-1||d===0||d===1&&a===c-1&&a===u+1?"":s.slice(a,c)},format:function(s){if(s===null||typeof s!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof s);return i("/",s)},parse:function(s){e(s);var a={root:"",dir:"",base:"",ext:"",name:""};if(s.length===0)return a;var u=s.charCodeAt(0),c=u===47,h;c?(a.root="/",h=1):h=0;for(var d=-1,g=0,y=-1,w=!0,E=s.length-1,S=0;E>=h;--E){if(u=s.charCodeAt(E),u===47){if(!w){g=E+1;break}continue}y===-1&&(w=!1,y=E+1),u===46?d===-1?d=E:S!==1&&(S=1):d!==-1&&(S=-1);}return d===-1||y===-1||S===0||S===1&&d===y-1&&d===g+1?y!==-1&&(g===0&&c?a.base=a.name=s.slice(1,y):a.base=a.name=s.slice(g,y)):(g===0&&c?(a.name=s.slice(1,d),a.base=s.slice(1,y)):(a.name=s.slice(g,d),a.base=s.slice(g,y)),a.ext=s.slice(d,y)),g>0?a.dir=s.slice(0,g-1):c&&(a.dir="/"),a},sep:"/",delimiter:":",win32:null,posix:null};return n.posix=n,el=n,el}function kE(t){if(typeof t=="string")t=new URL(t);else if(!(t instanceof URL))throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");if(t.protocol!=="file:")throw new Deno.errors.InvalidData("invalid url scheme");return rl?OE(t):xE(t)}function OE(t){let e=t.hostname,r=t.pathname;for(let i=0;i<r.length;i++)if(r[i]==="%"){let n=r.codePointAt(i+2)||32;if(r[i+1]==="2"&&n===102||r[i+1]==="5"&&n===99)throw new Deno.errors.InvalidData("must not include encoded \\ or / characters")}if(r=r.replace(IE,"\\"),r=decodeURIComponent(r),e!=="")return `\\\\${e}${r}`;{let i=r.codePointAt(1)|32,n=r[2];if(i<SE||i>AE||n!==":")throw new Deno.errors.InvalidData("file url path must be absolute");return r.slice(1)}}function xE(t){if(t.hostname!=="")throw new Deno.errors.InvalidData("invalid file url hostname");let e=t.pathname;for(let r=0;r<e.length;r++)if(e[r]==="%"){let i=e.codePointAt(r+2)||32;if(e[r+1]==="2"&&i===102)throw new Deno.errors.InvalidData("must not include encoded / characters")}return decodeURIComponent(e)}function ME(t){let e=cg.resolve(t),r=t.charCodeAt(t.length-1);(r===EE||rl&&r===vE)&&e[e.length-1]!==cg.sep&&(e+="/");let i=new URL("file://");return e.includes("%")&&(e=e.replace(TE,"%25")),!rl&&e.includes("\\")&&(e=e.replace(RE,"%5C")),e.includes(`
`)&&(e=e.replace(CE,"%0A")),e.includes("\r")&&(e=e.replace(BE,"%0D")),e.includes("	")&&(e=e.replace(PE,"%09")),i.pathname=e,i}function hg(t){if(typeof t=="string")t=new URL(t);else if(!(t instanceof URL))throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");if(t.protocol!=="file:")throw new Deno.errors.InvalidData("invalid url scheme");return il?XE(t):ZE(t)}function XE(t){let e=t.hostname,r=t.pathname;for(let i=0;i<r.length;i++)if(r[i]==="%"){let n=r.codePointAt(i+2)||32;if(r[i+1]==="2"&&n===102||r[i+1]==="5"&&n===99)throw new Deno.errors.InvalidData("must not include encoded \\ or / characters")}if(r=r.replace(zE,"\\"),r=decodeURIComponent(r),e!=="")return `\\\\${e}${r}`;{let i=r.codePointAt(1)|32,n=r[2];if(i<HE||i>VE||n!==":")throw new Deno.errors.InvalidData("file url path must be absolute");return r.slice(1)}}function ZE(t){if(t.hostname!=="")throw new Deno.errors.InvalidData("invalid file url hostname");let e=t.pathname;for(let r=0;r<e.length;r++)if(e[r]==="%"){let i=e.codePointAt(r+2)||32;if(e[r+1]==="2"&&i===102)throw new Deno.errors.InvalidData("must not include encoded / characters")}return decodeURIComponent(e)}function dg(t){let e=Ja.resolve(t),r=t.charCodeAt(t.length-1);(r===$E||il&&r===WE)&&e[e.length-1]!==Ja.sep&&(e+="/");let i=new URL("file://");return e.includes("%")&&(e=e.replace(KE,"%25")),!il&&e.includes("\\")&&(e=e.replace(GE,"%5C")),e.includes(`
`)&&(e=e.replace(QE,"%0A")),e.includes("\r")&&(e=e.replace(YE,"%0D")),e.includes("	")&&(e=e.replace(JE,"%09")),i.pathname=e,i}var Z,hE,gt,dE,pE,gE,yE,tl,ag,lg,ug,bE,wE,Xa,si,Za,el,fg,cg,mE,vE,EE,SE,AE,rl,IE,TE,RE,CE,BE,PE,LE,UE,NE,qE,DE,jE,FE,WE,$E,HE,VE,il,zE,KE,GE,QE,YE,JE,gg=we(()=>{v();m();_();Jp();Xp();ig();og();Qa();Z={},hE=zt,gt={isString:function(t){return typeof t=="string"},isObject:function(t){return typeof t=="object"&&t!==null},isNull:function(t){return t===null},isNullOrUndefined:function(t){return t==null}};Z.parse=xi,Z.resolve=function(t,e){return xi(t,!1,!0).resolve(e)},Z.resolveObject=function(t,e){return t?xi(t,!1,!0).resolveObject(e):e},Z.format=function(t){return gt.isString(t)&&(t=xi(t)),t instanceof Fe?t.format():Fe.prototype.format.call(t)},Z.Url=Fe;dE=/^([a-z0-9.+-]+:)/i,pE=/:[0-9]*$/,gE=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,yE=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r",`
`,"	"]),tl=["'"].concat(yE),ag=["%","/","?",";","#"].concat(tl),lg=["/","?","#"],ug=/^[+a-z0-9A-Z_-]{0,63}$/,bE=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,wE={javascript:!0,"javascript:":!0},Xa={javascript:!0,"javascript:":!0},si={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},Za=pt;Fe.prototype.parse=function(t,e,r){if(!gt.isString(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var i=t.indexOf("?"),n=i!==-1&&i<t.indexOf("#")?"?":"#",o=t.split(n);o[0]=o[0].replace(/\\/g,"/");var s=t=o.join(n);if(s=s.trim(),!r&&t.split("#").length===1){var a=gE.exec(s);if(a)return this.path=s,this.href=s,this.pathname=a[1],a[2]?(this.search=a[2],this.query=e?Za.parse(this.search.substr(1)):this.search.substr(1)):e&&(this.search="",this.query={}),this}var u=dE.exec(s);if(u){var c=(u=u[0]).toLowerCase();this.protocol=c,s=s.substr(u.length);}if(r||u||s.match(/^\/\/[^@\/]+@[^@\/]+/)){var h=s.substr(0,2)==="//";!h||u&&Xa[u]||(s=s.substr(2),this.slashes=!0);}if(!Xa[u]&&(h||u&&!si[u])){for(var d,g,y=-1,w=0;w<lg.length;w++)(E=s.indexOf(lg[w]))!==-1&&(y===-1||E<y)&&(y=E);for((g=y===-1?s.lastIndexOf("@"):s.lastIndexOf("@",y))!==-1&&(d=s.slice(0,g),s=s.slice(g+1),this.auth=decodeURIComponent(d)),y=-1,w=0;w<ag.length;w++){var E;(E=s.indexOf(ag[w]))!==-1&&(y===-1||E<y)&&(y=E);}y===-1&&(y=s.length),this.host=s.slice(0,y),s=s.slice(y),this.parseHost(),this.hostname=this.hostname||"";var S=this.hostname[0]==="["&&this.hostname[this.hostname.length-1]==="]";if(!S)for(var I=this.hostname.split(/\./),B=(w=0,I.length);w<B;w++){var R=I[w];if(R&&!R.match(ug)){for(var U="",N=0,W=R.length;N<W;N++)R.charCodeAt(N)>127?U+="x":U+=R[N];if(!U.match(ug)){var K=I.slice(0,w),z=I.slice(w+1),Q=R.match(bE);Q&&(K.push(Q[1]),z.unshift(Q[2])),z.length&&(s="/"+z.join(".")+s),this.hostname=K.join(".");break}}}this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),S||(this.hostname=hE.toASCII(this.hostname));var de=this.port?":"+this.port:"",Gt=this.hostname||"";this.host=Gt+de,this.href+=this.host,S&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),s[0]!=="/"&&(s="/"+s));}if(!wE[c])for(w=0,B=tl.length;w<B;w++){var pe=tl[w];if(s.indexOf(pe)!==-1){var Cr=encodeURIComponent(pe);Cr===pe&&(Cr=escape(pe)),s=s.split(pe).join(Cr);}}var Br=s.indexOf("#");Br!==-1&&(this.hash=s.substr(Br),s=s.slice(0,Br));var Pr=s.indexOf("?");if(Pr!==-1?(this.search=s.substr(Pr),this.query=s.substr(Pr+1),e&&(this.query=Za.parse(this.query)),s=s.slice(0,Pr)):e&&(this.search="",this.query={}),s&&(this.pathname=s),si[c]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){de=this.pathname||"";var fs=this.search||"";this.path=de+fs;}return this.href=this.format(),this},Fe.prototype.format=function(){var t=this.auth||"";t&&(t=(t=encodeURIComponent(t)).replace(/%3A/i,":"),t+="@");var e=this.protocol||"",r=this.pathname||"",i=this.hash||"",n=!1,o="";this.host?n=t+this.host:this.hostname&&(n=t+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(n+=":"+this.port)),this.query&&gt.isObject(this.query)&&Object.keys(this.query).length&&(o=Za.stringify(this.query));var s=this.search||o&&"?"+o||"";return e&&e.substr(-1)!==":"&&(e+=":"),this.slashes||(!e||si[e])&&n!==!1?(n="//"+(n||""),r&&r.charAt(0)!=="/"&&(r="/"+r)):n||(n=""),i&&i.charAt(0)!=="#"&&(i="#"+i),s&&s.charAt(0)!=="?"&&(s="?"+s),e+n+(r=r.replace(/[?#]/g,function(a){return encodeURIComponent(a)}))+(s=s.replace("#","%23"))+i},Fe.prototype.resolve=function(t){return this.resolveObject(xi(t,!1,!0)).format()},Fe.prototype.resolveObject=function(t){if(gt.isString(t)){var e=new Fe;e.parse(t,!1,!0),t=e;}for(var r=new Fe,i=Object.keys(this),n=0;n<i.length;n++){var o=i[n];r[o]=this[o];}if(r.hash=t.hash,t.href==="")return r.href=r.format(),r;if(t.slashes&&!t.protocol){for(var s=Object.keys(t),a=0;a<s.length;a++){var u=s[a];u!=="protocol"&&(r[u]=t[u]);}return si[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname="/"),r.href=r.format(),r}if(t.protocol&&t.protocol!==r.protocol){if(!si[t.protocol]){for(var c=Object.keys(t),h=0;h<c.length;h++){var d=c[h];r[d]=t[d];}return r.href=r.format(),r}if(r.protocol=t.protocol,t.host||Xa[t.protocol])r.pathname=t.pathname;else {for(var g=(t.pathname||"").split("/");g.length&&!(t.host=g.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),g[0]!==""&&g.unshift(""),g.length<2&&g.unshift(""),r.pathname=g.join("/");}if(r.search=t.search,r.query=t.query,r.host=t.host||"",r.auth=t.auth,r.hostname=t.hostname||t.host,r.port=t.port,r.pathname||r.search){var y=r.pathname||"",w=r.search||"";r.path=y+w;}return r.slashes=r.slashes||t.slashes,r.href=r.format(),r}var E=r.pathname&&r.pathname.charAt(0)==="/",S=t.host||t.pathname&&t.pathname.charAt(0)==="/",I=S||E||r.host&&t.pathname,B=I,R=r.pathname&&r.pathname.split("/")||[],U=(g=t.pathname&&t.pathname.split("/")||[],r.protocol&&!si[r.protocol]);if(U&&(r.hostname="",r.port=null,r.host&&(R[0]===""?R[0]=r.host:R.unshift(r.host)),r.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(g[0]===""?g[0]=t.host:g.unshift(t.host)),t.host=null),I=I&&(g[0]===""||R[0]==="")),S)r.host=t.host||t.host===""?t.host:r.host,r.hostname=t.hostname||t.hostname===""?t.hostname:r.hostname,r.search=t.search,r.query=t.query,R=g;else if(g.length)R||(R=[]),R.pop(),R=R.concat(g),r.search=t.search,r.query=t.query;else if(!gt.isNullOrUndefined(t.search))return U&&(r.hostname=r.host=R.shift(),(Q=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=Q.shift(),r.host=r.hostname=Q.shift())),r.search=t.search,r.query=t.query,gt.isNull(r.pathname)&&gt.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.href=r.format(),r;if(!R.length)return r.pathname=null,r.search?r.path="/"+r.search:r.path=null,r.href=r.format(),r;for(var N=R.slice(-1)[0],W=(r.host||t.host||R.length>1)&&(N==="."||N==="..")||N==="",K=0,z=R.length;z>=0;z--)(N=R[z])==="."?R.splice(z,1):N===".."?(R.splice(z,1),K++):K&&(R.splice(z,1),K--);if(!I&&!B)for(;K--;K)R.unshift("..");!I||R[0]===""||R[0]&&R[0].charAt(0)==="/"||R.unshift(""),W&&R.join("/").substr(-1)!=="/"&&R.push("");var Q,de=R[0]===""||R[0]&&R[0].charAt(0)==="/";return U&&(r.hostname=r.host=de?"":R.length?R.shift():"",(Q=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=Q.shift(),r.host=r.hostname=Q.shift())),(I=I||r.host&&R.length)&&!de&&R.unshift(""),R.length?r.pathname=R.join("/"):(r.pathname=null,r.path=null),gt.isNull(r.pathname)&&gt.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.auth=t.auth||r.auth,r.slashes=r.slashes||t.slashes,r.href=r.format(),r},Fe.prototype.parseHost=function(){var t=this.host,e=pE.exec(t);e&&((e=e[0])!==":"&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t);};Z.Url;Z.format;Z.resolve;Z.resolveObject;el={},fg=!1;cg=_E(),mE=typeof Deno<"u"?Deno.build.os==="windows"?"win32":Deno.build.os:void 0;Z.URL=typeof URL<"u"?URL:null;Z.pathToFileURL=ME;Z.fileURLToPath=kE;Z.Url;Z.format;Z.resolve;Z.resolveObject;Z.URL;vE=92,EE=47,SE=97,AE=122,rl=mE==="win32",IE=/\//g,TE=/%/g,RE=/\\/g,CE=/\n/g,BE=/\r/g,PE=/\t/g;LE=typeof Deno<"u"?Deno.build.os==="windows"?"win32":Deno.build.os:void 0;Z.URL=typeof URL<"u"?URL:null;Z.pathToFileURL=dg;Z.fileURLToPath=hg;UE=Z.Url,NE=Z.format,qE=Z.resolve,DE=Z.resolveObject,jE=Z.parse,FE=Z.URL,WE=92,$E=47,HE=97,VE=122,il=LE==="win32",zE=/\//g,KE=/%/g,GE=/\\/g,QE=/\n/g,YE=/\r/g,JE=/\t/g;});var nl={};Qt(nl,{Server:()=>Me,Socket:()=>Me,Stream:()=>Me,_createServerHandle:()=>Me,_normalizeArgs:()=>Me,_setSimultaneousAccepts:()=>Me,connect:()=>Me,createConnection:()=>Me,createServer:()=>Me,default:()=>eS,isIP:()=>Me,isIPv4:()=>Me,isIPv6:()=>Me});function Me(){throw new Error("Node.js net module is not supported by JSPM core outside of Node.js")}var eS,sl=we(()=>{v();m();_();eS={_createServerHandle:Me,_normalizeArgs:Me,_setSimultaneousAccepts:Me,connect:Me,createConnection:Me,createServer:Me,isIP:Me,isIPv4:Me,isIPv6:Me,Server:Me,Socket:Me,Stream:Me};});var ol=M(Mi=>{v();m();_();var yg=Mi&&Mi.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Mi,"__esModule",{value:!0});var tS=yg((sl(),X(nl))),rS=yg(ot()),iS=(0, rS.default)("mqttjs:tcp"),nS=(t,e)=>{e.port=e.port||1883,e.hostname=e.hostname||e.host||"localhost";let{port:r,path:i}=e,n=e.hostname;return iS("port %d and host %s",r,n),tS.default.createConnection({port:r,host:n,path:i})};Mi.default=nS;});var bg={};Qt(bg,{default:()=>sS});var sS,wg=we(()=>{v();m();_();sS={};});var ll=M(Li=>{v();m();_();var al=Li&&Li.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Li,"__esModule",{value:!0});var oS=al((wg(),X(bg))),aS=al((sl(),X(nl))),lS=al(ot()),uS=(0, lS.default)("mqttjs:tls"),fS=(t,e)=>{e.port=e.port||8883,e.host=e.hostname||e.host||"localhost",aS.default.isIP(e.host)===0&&(e.servername=e.host),e.rejectUnauthorized=e.rejectUnauthorized!==!1,delete e.path,uS("port %d host %s rejectUnauthorized %b",e.port,e.host,e.rejectUnauthorized);let r=oS.default.connect(e);r.on("secureConnect",()=>{e.rejectUnauthorized&&!r.authorized?r.emit("error",new Error("TLS not authorized")):r.removeListener("error",i);});function i(n){e.rejectUnauthorized&&t.emit("error",n),r.end();}return r.on("error",i),r};Li.default=fS;});var as=M(oi=>{v();m();_();Object.defineProperty(oi,"__esModule",{value:!0});oi.BufferedDuplex=oi.writev=void 0;var cS=jt(),_g=(ye(),X(_e));function mg(t,e){let r=new Array(t.length);for(let i=0;i<t.length;i++)typeof t[i].chunk=="string"?r[i]=_g.Buffer.from(t[i].chunk,"utf8"):r[i]=t[i].chunk;this._write(_g.Buffer.concat(r),"binary",e);}oi.writev=mg;var ul=class extends cS.Duplex{constructor(e,r,i){super({objectMode:!0}),this.proxy=r,this.socket=i,this.writeQueue=[],e.objectMode||(this._writev=mg.bind(this)),this.isSocketOpen=!1,this.proxy.on("data",n=>{this.push(n);});}_read(e){this.proxy.read(e);}_write(e,r,i){this.isSocketOpen?this.writeToProxy(e,r,i):this.writeQueue.push({chunk:e,encoding:r,cb:i});}_final(e){this.writeQueue=[],this.proxy.end(e);}_destroy(e,r){this.writeQueue=[],this.proxy.destroy(),r(e);}socketReady(){this.emit("connect"),this.isSocketOpen=!0,this.processWriteQueue();}writeToProxy(e,r,i){this.proxy.write(e,r)===!1?this.proxy.once("drain",i):i();}processWriteQueue(){for(;this.writeQueue.length>0;){let{chunk:e,encoding:r,cb:i}=this.writeQueue.shift();this.writeToProxy(e,r,i);}}};oi.BufferedDuplex=ul;});var hl=M(cl=>{v();m();_();Object.defineProperty(cl,"__esModule",{value:!0});var vg=(ye(),X(_e)),hS=jt(),dS=as(),yt,fl,Le;function pS(){let t=new hS.Transform;return t._write=(e,r,i)=>{yt.send({data:e.buffer,success(){i();},fail(n){i(new Error(n));}});},t._flush=e=>{yt.close({success(){e();}});},t}function gS(t){t.hostname||(t.hostname="localhost"),t.path||(t.path="/"),t.wsOptions||(t.wsOptions={});}function yS(t,e){let r=t.protocol==="wxs"?"wss":"ws",i=`${r}://${t.hostname}${t.path}`;return t.port&&t.port!==80&&t.port!==443&&(i=`${r}://${t.hostname}:${t.port}${t.path}`),typeof t.transformWsUrl=="function"&&(i=t.transformWsUrl(i,t,e)),i}function bS(){yt.onOpen(()=>{Le.socketReady();}),yt.onMessage(t=>{let{data:e}=t;e instanceof ArrayBuffer?e=vg.Buffer.from(e):e=vg.Buffer.from(e,"utf8"),fl.push(e);}),yt.onClose(()=>{Le.emit("close"),Le.end(),Le.destroy();}),yt.onError(t=>{let e=new Error(t.errMsg);Le.destroy(e);});}var wS=(t,e)=>{if(e.hostname=e.hostname||e.host,!e.hostname)throw new Error("Could not determine host. Specify host manually.");let r=e.protocolId==="MQIsdp"&&e.protocolVersion===3?"mqttv3.1":"mqtt";gS(e);let i=yS(e,t);yt=wx.connectSocket({url:i,protocols:[r]}),fl=pS(),Le=new dS.BufferedDuplex(e,fl,yt),Le._destroy=(o,s)=>{yt.close({success(){s&&s(o);}});};let n=Le.destroy;return Le.destroy=(o,s)=>(Le.destroy=n,setTimeout(()=>{yt.close({fail(){Le._destroy(o,s);}});},0),Le),bS(),Le};cl.default=wS;});var gl=M(pl=>{v();m();_();Object.defineProperty(pl,"__esModule",{value:!0});var dl=(ye(),X(_e)),_S=jt(),mS=as(),xt,ls,ai,Eg=!1;function vS(){let t=new _S.Transform;return t._write=(e,r,i)=>{xt.sendSocketMessage({data:e.buffer,success(){i();},fail(){i(new Error);}});},t._flush=e=>{xt.closeSocket({success(){e();}});},t}function ES(t){t.hostname||(t.hostname="localhost"),t.path||(t.path="/"),t.wsOptions||(t.wsOptions={});}function SS(t,e){let r=t.protocol==="alis"?"wss":"ws",i=`${r}://${t.hostname}${t.path}`;return t.port&&t.port!==80&&t.port!==443&&(i=`${r}://${t.hostname}:${t.port}${t.path}`),typeof t.transformWsUrl=="function"&&(i=t.transformWsUrl(i,t,e)),i}function AS(){Eg||(Eg=!0,xt.onSocketOpen(()=>{ai.socketReady();}),xt.onSocketMessage(t=>{if(typeof t.data=="string"){let e=dl.Buffer.from(t.data,"base64");ls.push(e);}else {let e=new FileReader;e.addEventListener("load",()=>{let r=e.result;r instanceof ArrayBuffer?r=dl.Buffer.from(r):r=dl.Buffer.from(r,"utf8"),ls.push(r);}),e.readAsArrayBuffer(t.data);}}),xt.onSocketClose(()=>{ai.end(),ai.destroy();}),xt.onSocketError(t=>{ai.destroy(t);}));}var IS=(t,e)=>{if(e.hostname=e.hostname||e.host,!e.hostname)throw new Error("Could not determine host. Specify host manually.");let r=e.protocolId==="MQIsdp"&&e.protocolVersion===3?"mqttv3.1":"mqtt";ES(e);let i=SS(e,t);return xt=e.my,xt.connectSocket({url:i,protocols:r}),ls=vS(),ai=new mS.BufferedDuplex(e,ls,xt),AS(),ai};pl.default=IS;});var Ag=M((x4,Sg)=>{v();m();_();Sg.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")};});var _l=M(Ui=>{v();m();_();var wl=Ui&&Ui.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ui,"__esModule",{value:!0});var yl=(ye(),X(_e)),Ig=wl(Ag()),TS=wl(ot()),RS=jt(),Tg=wl(Pi()),bl=as(),Kt=(0, TS.default)("mqttjs:ws"),CS=["rejectUnauthorized","ca","cert","key","pfx","passphrase"];function Rg(t,e){let r=`${t.protocol}://${t.hostname}:${t.port}${t.path}`;return typeof t.transformWsUrl=="function"&&(r=t.transformWsUrl(r,t,e)),r}function Cg(t){let e=t;return t.port||(t.protocol==="wss"?e.port=443:e.port=80),t.path||(e.path="/"),t.wsOptions||(e.wsOptions={}),!Tg.default&&t.protocol==="wss"&&CS.forEach(r=>{Object.prototype.hasOwnProperty.call(t,r)&&!Object.prototype.hasOwnProperty.call(t.wsOptions,r)&&(e.wsOptions[r]=t[r]);}),e}function BS(t){let e=Cg(t);if(e.hostname||(e.hostname=e.host),!e.hostname){if(typeof document>"u")throw new Error("Could not determine host. Specify host manually.");let r=new URL(document.URL);e.hostname=r.hostname,e.port||(e.port=Number(r.port));}return e.objectMode===void 0&&(e.objectMode=!(e.binary===!0||e.binary===void 0)),e}function PS(t,e,r){Kt("createWebSocket"),Kt(`protocol: ${r.protocolId} ${r.protocolVersion}`);let i=r.protocolId==="MQIsdp"&&r.protocolVersion===3?"mqttv3.1":"mqtt";Kt(`creating new Websocket for url: ${e} and protocol: ${i}`);let n;return r.createWebsocket?n=r.createWebsocket(e,[i],r):n=new Ig.default(e,[i],r.wsOptions),n}function kS(t,e){let r=e.protocolId==="MQIsdp"&&e.protocolVersion===3?"mqttv3.1":"mqtt",i=Rg(e,t),n;return e.createWebsocket?n=e.createWebsocket(i,[r],e):n=new WebSocket(i,[r]),n.binaryType="arraybuffer",n}var OS=(t,e)=>{Kt("streamBuilder");let r=Cg(e);r.hostname=r.hostname||r.host||"localhost";let i=Rg(r,t),n=PS(t,i,r),o=Ig.default.createWebSocketStream(n,r.wsOptions);return o.url=i,n.on("close",()=>{o.destroy();}),o},xS=(t,e)=>{Kt("browserStreamBuilder");let r,n=BS(e).browserBufferSize||1024*512,o=e.browserBufferTimeout||1e3,s=!e.objectMode,a=kS(t,e),u=h(e,E,S);e.objectMode||(u._writev=bl.writev.bind(u)),u.on("close",()=>{a.close();});let c=typeof a.addEventListener<"u";a.readyState===a.OPEN?(r=u,r.socket=a):(r=new bl.BufferedDuplex(e,u,a),c?a.addEventListener("open",d):a.onopen=d),c?(a.addEventListener("close",g),a.addEventListener("error",y),a.addEventListener("message",w)):(a.onclose=g,a.onerror=y,a.onmessage=w);function h(I,B,R){let U=new RS.Transform({objectMode:I.objectMode});return U._write=B,U._flush=R,U}function d(){Kt("WebSocket onOpen"),r instanceof bl.BufferedDuplex&&r.socketReady();}function g(I){Kt("WebSocket onClose",I),r.end(),r.destroy();}function y(I){Kt("WebSocket onError",I);let B=new Error("WebSocket error");B.event=I,r.destroy(B);}function w(I){let{data:B}=I;B instanceof ArrayBuffer?B=yl.Buffer.from(B):B=yl.Buffer.from(B,"utf8"),u.push(B);}function E(I,B,R){if(a.bufferedAmount>n){setTimeout(E,o,I,B,R);return}s&&typeof I=="string"&&(I=yl.Buffer.from(I,"utf8"));try{a.send(I);}catch(U){return R(U)}R();}function S(I){a.close(),I();}return r};Ui.default=Tg.default?xS:OS;});var kg=M(Rr=>{v();m();_();var us=Rr&&Rr.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Rr,"__esModule",{value:!0});Rr.connectAsync=void 0;var MS=us(ot()),LS=us((gg(),X(pg))),US=us(ss()),NS=us(Pi());typeof(C===null||C===void 0?void 0:C.nextTick)!="function"&&(C.nextTick=setImmediate);var Bg=(0, MS.default)("mqttjs"),Re={};NS.default?(Re.wx=hl().default,Re.wxs=hl().default,Re.ali=gl().default,Re.alis=gl().default):(Re.mqtt=ol().default,Re.tcp=ol().default,Re.ssl=ll().default,Re.tls=Re.ssl,Re.mqtts=ll().default);Re.ws=_l().default;Re.wss=_l().default;function qS(t){let e;t.auth&&(e=t.auth.match(/^(.+):(.+)$/),e?(t.username=e[1],t.password=e[2]):t.username=t.auth);}function Pg(t,e){var r,i,n;if(Bg("connecting to an MQTT broker..."),typeof t=="object"&&!e&&(e=t,t=""),e=e||{},t&&typeof t=="string"){let a=LS.default.parse(t,!0),u={};if(a.port!=null&&(u.port=Number(a.port)),u.host=a.hostname,u.query=a.query,u.auth=a.auth,u.protocol=a.protocol,u.path=a.path,u.protocol=(r=u.protocol)===null||r===void 0?void 0:r.replace(/:$/,""),e=Object.assign(Object.assign({},u),e),!e.protocol)throw new Error("Missing protocol")}if(e.unixSocket=e.unixSocket||((i=e.protocol)===null||i===void 0?void 0:i.includes("+unix")),e.unixSocket?e.protocol=e.protocol.replace("+unix",""):!((n=e.protocol)===null||n===void 0)&&n.startsWith("ws")||delete e.path,qS(e),e.query&&typeof e.query.clientId=="string"&&(e.clientId=e.query.clientId),e.cert&&e.key)if(e.protocol){if(["mqtts","wss","wxs","alis"].indexOf(e.protocol)===-1)switch(e.protocol){case"mqtt":e.protocol="mqtts";break;case"ws":e.protocol="wss";break;case"wx":e.protocol="wxs";break;case"ali":e.protocol="alis";break;default:throw new Error(`Unknown protocol for secure connection: "${e.protocol}"!`)}}else throw new Error("Missing secure protocol key");if(!Re[e.protocol]){let a=["mqtts","wss"].indexOf(e.protocol)!==-1;e.protocol=["mqtt","mqtts","ws","wss","wx","wxs","ali","alis"].filter((u,c)=>a&&c%2===0?!1:typeof Re[u]=="function")[0];}if(e.clean===!1&&!e.clientId)throw new Error("Missing clientId for unclean clients");e.protocol&&(e.defaultProtocol=e.protocol);function o(a){return e.servers&&((!a._reconnectCount||a._reconnectCount===e.servers.length)&&(a._reconnectCount=0),e.host=e.servers[a._reconnectCount].host,e.port=e.servers[a._reconnectCount].port,e.protocol=e.servers[a._reconnectCount].protocol?e.servers[a._reconnectCount].protocol:e.defaultProtocol,e.hostname=e.host,a._reconnectCount++),Bg("calling streambuilder for",e.protocol),Re[e.protocol](a,e)}let s=new US.default(o,e);return s.on("error",()=>{}),s}function DS(t,e,r=!0){return new Promise((i,n)=>{let o=Pg(t,e),s={connect:u=>{a(),i(o);},end:()=>{a(),i(o);},error:u=>{a(),o.end(),n(u);}};r===!1&&(s.close=()=>{s.error(new Error("Couldn't connect to server"));});function a(){Object.keys(s).forEach(u=>{o.off(u,s[u]);});}Object.keys(s).forEach(u=>{o.on(u,s[u]);});})}Rr.connectAsync=DS;Rr.default=Pg;});var ml=M(G=>{v();m();_();var Og=G&&G.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n);}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r];}),jS=G&&G.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e});}:function(t,e){t.default=e;}),FS=G&&G.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!=="default"&&Object.prototype.hasOwnProperty.call(t,r)&&Og(e,t,r);return jS(e,t),e},xg=G&&G.__exportStar||function(t,e){for(var r in t)r!=="default"&&!Object.prototype.hasOwnProperty.call(e,r)&&Og(e,t,r);},Ni=G&&G.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(G,"__esModule",{value:!0});G.ReasonCodes=G.KeepaliveManager=G.UniqueMessageIdProvider=G.DefaultMessageIdProvider=G.Store=G.MqttClient=G.connectAsync=G.connect=G.Client=void 0;var Mg=Ni(ss());G.MqttClient=Mg.default;var WS=Ni(Jo());G.DefaultMessageIdProvider=WS.default;var $S=Ni(Hp());G.UniqueMessageIdProvider=$S.default;var HS=Ni(ea());G.Store=HS.default;var Lg=FS(kg());G.connect=Lg.default;Object.defineProperty(G,"connectAsync",{enumerable:!0,get:function(){return Lg.connectAsync}});var VS=Ni(ja());G.KeepaliveManager=VS.default;G.Client=Mg.default;xg(ss(),G);xg(Jr(),G);var zS=Ai();Object.defineProperty(G,"ReasonCodes",{enumerable:!0,get:function(){return zS.ReasonCodes}});});var JS=M(We=>{v();m();_();var Ug=We&&We.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n);}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r];}),KS=We&&We.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e});}:function(t,e){t.default=e;}),GS=We&&We.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!=="default"&&Object.prototype.hasOwnProperty.call(t,r)&&Ug(e,t,r);return KS(e,t),e},QS=We&&We.__exportStar||function(t,e){for(var r in t)r!=="default"&&!Object.prototype.hasOwnProperty.call(e,r)&&Ug(e,t,r);};Object.defineProperty(We,"__esModule",{value:!0});var YS=GS(ml());We.default=YS;QS(ml(),We);});const mqtt = JS();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/

class MqttService {
  client;
  constructor(url, options) {
    this.client = mqtt.connect(url, options);
    this.client.on("connect", () => {
      console.log("MQTT connected");
    });
    this.client.on("error", (error) => {
      console.error("MQTT error:", error);
    });
    this.client.on("reconnect", () => {
      console.log("MQTT reconnecting...");
    });
  }
  /**
   * 
   *
   * @param callback 
   * @param callback.message 
   */
  messageList(callback) {
    this.client.on("message", (topic, message) => {
      callback(topic, message);
    });
  }
  subscribe(topic) {
    this.client.subscribe(topic, (err) => {
      if (!err) {
        console.log("Subscribe success:", topic);
      } else {
        console.error("Subscribe error:", err);
      }
    });
  }
  publish(topic, message, options) {
    this.client.publish(topic, message, options);
  }
  unsubscribe(topic) {
    this.client.unsubscribe(topic);
  }
  end() {
    this.client.end();
  }
}

const result = (attrName, condition, attrValue, attrValueRight) => {
  switch (condition) {
    case ">":
      return attrName > attrValue;
    case "<":
      return attrName < attrValue;
    case "===":
      return attrName === attrValue;
    case "!==":
      return attrName !== attrValue;
    case ">=":
      return attrName >= attrValue;
    case "<=":
      return attrName <= attrValue;
    case ">,<":
      return attrValue < attrName && attrName < attrValueRight;
    case ">,<=":
      return attrValue < attrName && attrName <= attrValueRight;
    case ">=,<":
      return attrValue <= attrName && attrName < attrValueRight;
    case ">=,<=":
      return attrValue <= attrName && attrName <= attrValueRight;
    default:
      return false;
  }
};
const valueChange = (formJson, graph, item, number) => {
  const cell = formJson?.cells.find((item1) => item1.nodeName == item.targetObject);
  console.log(item);
  const value = result(number, item.condition, Number(item.attrValue), Number(item?.attrValueRight));
  if (value) {
    const node = item.targetObject == "" ? graph.getCellById(item.nodeId) : graph.getCellById(cell.id);
    if (node.isNode()) {
      const nodeProp = node.prop();
      const nodePosition = { x: nodeProp.position.x, y: nodeProp.position.y };
      const nodeSize = { x: nodeProp.size.width, y: nodeProp.size.height };
      console.log(nodeProp, item);
      nodeEvent(node, item, item.event, nodePosition, nodeSize);
    } else {
      const edgeProp = node.prop();
      edgeEvent(node, item, edgeProp);
    }
  }
};
const allValueChangeList = (formJson) => {
  let valueEvents = [];
  formJson?.cells.map((item) => {
    item?.data?.map((item1) => {
      if (item1.event == "valueChange" && item1.watchObject.length > 2) {
        valueEvents.push({ ...item1, equipmentId: item1.watchObject[2], nodeId: item.id });
      }
    });
    item?.edgeData?.map((item2) => {
      if (item2.event == "valueChange" && item2.watchObject.length > 2) {
        valueEvents.push({ ...item2, equipmentId: item2.watchObject[2], nodeId: item.id });
      }
    });
  });
  return valueEvents;
};

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "proview",
  props: {
    formJson: {
      type: Object,
      default: () => {
      }
    }
  },
  setup(__props) {
    const props = __props;
    const container = ref$1(null);
    const graphs = ref$1(null);
    var mqttService, allValueChangeLists, topicList;
    const onMessageReceived = (topic, message2) => {
      const id = topic.substring(topic.lastIndexOf("/") + 1);
      const arr = allValueChangeLists.filter((item) => item.equipmentId == id);
      const messageObj = JSON.parse(message2.toString());
      arr.forEach((item) => {
        valueChange(props.formJson, graphs.value, item, messageObj.value);
      });
    };
    const openMadel = (val) => {
      console.log(val);
    };
    const subscribeAllValueChange = () => {
      mqttService = new MqttService("ws://192.168.1.158:8083", {
        clean: true,
        protocol: "ws",
        clientId: "vue3-test222",
        path: "/mqtt",
        username: "admin",
        //
        password: "Jykj@1234"
        //
      });
      topicList = Array.from(new Set(allValueChangeLists.map((item) => item.equipmentId)));
      mqttService.messageList(onMessageReceived);
      mqttService.publish("devices/init", "Jykj");
      topicList.forEach((item) => {
        mqttService.subscribe(`devices/${item}`);
      });
    };
    var graph;
    onMounted(() => {
      graphs.value = new Graph({
        container: container.value,
        grid: true,
        interacting: () => false,
        mousewheel: true,
        translating: {
          restrict: true
        },
        connecting: {
          router: "normal",
          connector: {
            name: "normal",
            args: {
              radius: 8
            }
          },
          anchor: "left",
          connectionPoint: "anchor",
          allowBlank: false,
          snap: {
            radius: 20
          },
          createEdge() {
            return new Edge({
              markup: [
                {
                  tagName: "path",
                  selector: "line3",
                  attrs: {
                    fill: "none"
                  }
                },
                {
                  tagName: "path",
                  selector: "line2",
                  attrs: {
                    fill: "none"
                  }
                },
                {
                  tagName: "path",
                  selector: "line",
                  attrs: {
                    fill: "none"
                  }
                },
                {
                  tagName: "circle",
                  selector: "circle"
                }
              ],
              attrs: {
                line3: {
                  connection: true,
                  stroke: "",
                  strokeWidth: 5
                },
                line2: {
                  connection: true,
                  stroke: "",
                  strokeWidth: 5
                },
                circle: {
                  r: 5,
                  fill: "#ffffff00",
                  atConnectionRatio: 0,
                  refCy: -10
                },
                line: {
                  stroke: "#A2B1C3",
                  strokeWidth: 2,
                  connection: true,
                  targetMarker: {
                    name: "",
                    width: 12,
                    height: 8
                  }
                }
              },
              // tools: [
              //   {
              //     name: 'vertices',
              //     args: {
              //       attrs: { fill: '#66666600' }
              //     }
              //   }
              // ],
              zIndex: 0
              //....
            });
          },
          validateConnection({ targetMagnet }) {
            return !!targetMagnet;
          }
        },
        highlighting: {
          magnetAdsorbed: {
            name: "stroke",
            args: {
              attrs: {
                fill: "#5F95FF",
                stroke: "#5F95FF"
              }
            }
          }
        }
      });
      graph = graphs.value;
      if (props.formJson) {
        allList(graph);
        graph.fromJSON(props.formJson);
        eventList(props.formJson, graph, openMadel);
        allValueChangeLists = allValueChangeList(props.formJson);
        if (allValueChangeLists.length > 0) {
          subscribeAllValueChange();
        }
      }
      Graph.registerConnector(
        "mindmap",
        (sourcePoint, targetPoint, options) => {
          const midX = sourcePoint.x + 10;
          const midY = sourcePoint.y;
          const ctrX = (targetPoint.x - midX) / 5 + midX;
          const ctrY = targetPoint.y;
          const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     L ${midX} ${midY}
     Q ${ctrX} ${ctrY} ${targetPoint.x} ${targetPoint.y}
    `;
          return options.raw ? Path.parse(pathData) : pathData;
        },
        true
      );
    });
    onUnmounted(() => {
      if (mqttService) {
        topicList.forEach((item, index) => {
          mqttService.unsubscribe(`devices/${item}`);
        });
        mqttService.end();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "proview-container"
      }, null, 512);
    };
  }
});

const proview_vue_vue_type_style_index_0_lang = '';

export { _sfc_main as UserGraph };
